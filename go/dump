
6.out:     file format elf64-x86-64


Disassembly of section .text:

0000000001000c00 <main.main>:
package main

func main() {
 1000c00:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1000c07:	ff ff 
 1000c09:	48 3b 21             	cmp    (%rcx),%rsp
 1000c0c:	77 05                	ja     1000c13 <main.main+0x13>
 1000c0e:	e8 e0 0c 00 00       	callq  10018f3 <runtime.morestack00>
 1000c13:	48 83 ec 10          	sub    $0x10,%rsp
	print("Hello, world!\n")
 1000c17:	48 8d 34 25 10 57 01 	lea    0x1015710,%rsi
 1000c1e:	01 
 1000c1f:	48 8d 3c 24          	lea    (%rsp),%rdi
 1000c23:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000c25:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000c27:	e8 9c 70 00 00       	callq  1007cc8 <runtime.printstring>
 1000c2c:	48 83 c4 10          	add    $0x10,%rsp
 1000c30:	c3                   	retq   

0000000001000c31 <main.init>:
 1000c31:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1000c38:	ff ff 
 1000c3a:	48 3b 21             	cmp    (%rcx),%rsp
 1000c3d:	77 05                	ja     1000c44 <main.init+0x13>
 1000c3f:	e8 af 0c 00 00       	callq  10018f3 <runtime.morestack00>
 1000c44:	8a 04 25 e1 4d 02 01 	mov    0x1024de1,%al
 1000c4b:	88 c3                	mov    %al,%bl
 1000c4d:	80 fb 00             	cmp    $0x0,%bl
 1000c50:	74 0d                	je     1000c5f <main.init+0x2e>
 1000c52:	88 c3                	mov    %al,%bl
 1000c54:	80 fb 02             	cmp    $0x2,%bl
 1000c57:	75 01                	jne    1000c5a <main.init+0x29>
 1000c59:	c3                   	retq   
 1000c5a:	e8 b0 90 00 00       	callq  1009d0f <runtime.throwinit>
 1000c5f:	c6 04 25 e1 4d 02 01 	movb   $0x2,0x1024de1
 1000c66:	02 
 1000c67:	c3                   	retq   

0000000001000c68 <runtime.(*TypeAssertionError).RuntimeError>:
	concreteString  string
	assertedString  string
	missingMethod   string // one method needed by Interface, missing from Concrete
}

func (*TypeAssertionError) RuntimeError() {}
 1000c68:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1000c6f:	ff ff 
 1000c71:	48 3b 21             	cmp    (%rcx),%rsp
 1000c74:	77 05                	ja     1000c7b <runtime.(*TypeAssertionError).RuntimeError+0x13>
 1000c76:	e8 d1 0c 00 00       	callq  100194c <runtime.morestack8>
 1000c7b:	c3                   	retq   

0000000001000c7c <runtime.(*TypeAssertionError).String>:

func (e *TypeAssertionError) String() string {
 1000c7c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1000c83:	ff ff 
 1000c85:	48 3b 21             	cmp    (%rcx),%rsp
 1000c88:	77 05                	ja     1000c8f <runtime.(*TypeAssertionError).String+0x13>
 1000c8a:	e8 cf 0c 00 00       	callq  100195e <runtime.morestack24>
 1000c8f:	48 83 ec 78          	sub    $0x78,%rsp
 1000c93:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
 1000c9a:	00 
	inter := e.interfaceString
 1000c9b:	48 89 c3             	mov    %rax,%rbx
 1000c9e:	48 83 c3 30          	add    $0x30,%rbx
 1000ca2:	48 8b 13             	mov    (%rbx),%rdx
 1000ca5:	8b 4b 08             	mov    0x8(%rbx),%ecx
	if inter == "" {
 1000ca8:	83 f9 00             	cmp    $0x0,%ecx
 1000cab:	75 0e                	jne    1000cbb <runtime.(*TypeAssertionError).String+0x3f>
		inter = "interface"
 1000cad:	48 8d 1c 25 60 4b 01 	lea    0x1014b60,%rbx
 1000cb4:	01 
 1000cb5:	48 8b 13             	mov    (%rbx),%rdx
 1000cb8:	8b 4b 08             	mov    0x8(%rbx),%ecx
	}
	if e.concreteType == nil {
 1000cbb:	48 89 c3             	mov    %rax,%rbx
 1000cbe:	48 83 c3 10          	add    $0x10,%rbx
 1000cc2:	48 83 3b 00          	cmpq   $0x0,(%rbx)
 1000cc6:	75 66                	jne    1000d2e <runtime.(*TypeAssertionError).String+0xb2>
		return "interface conversion: " + inter + " is nil, not " + e.assertedString
 1000cc8:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
 1000ccf:	48 8d 34 25 78 62 01 	lea    0x1016278,%rsi
 1000cd6:	01 
 1000cd7:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
 1000cdc:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000cde:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000ce0:	48 8d 5c 24 18       	lea    0x18(%rsp),%rbx
 1000ce5:	48 89 13             	mov    %rdx,(%rbx)
 1000ce8:	89 4b 08             	mov    %ecx,0x8(%rbx)
 1000ceb:	48 8d 34 25 d0 52 01 	lea    0x10152d0,%rsi
 1000cf2:	01 
 1000cf3:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
 1000cf8:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000cfa:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000cfc:	48 89 c6             	mov    %rax,%rsi
 1000cff:	48 83 c6 50          	add    $0x50,%rsi
 1000d03:	48 8d 7c 24 38       	lea    0x38(%rsp),%rdi
 1000d08:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d0a:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d0c:	e8 5e ad 00 00       	callq  100ba6f <runtime.concatstring>
 1000d11:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
 1000d16:	48 89 9c 24 88 00 00 	mov    %rbx,0x88(%rsp)
 1000d1d:	00 
 1000d1e:	8b 5c 24 50          	mov    0x50(%rsp),%ebx
 1000d22:	89 9c 24 90 00 00 00 	mov    %ebx,0x90(%rsp)
 1000d29:	48 83 c4 78          	add    $0x78,%rsp
 1000d2d:	c3                   	retq   
	}
	if e.missingMethod == "" {
 1000d2e:	48 89 c3             	mov    %rax,%rbx
 1000d31:	48 83 c3 60          	add    $0x60,%rbx
 1000d35:	8b 5b 08             	mov    0x8(%rbx),%ebx
 1000d38:	83 fb 00             	cmp    $0x0,%ebx
 1000d3b:	0f 85 87 00 00 00    	jne    1000dc8 <runtime.(*TypeAssertionError).String+0x14c>
		return "interface conversion: " + inter + " is " + e.concreteString +
			", not " + e.assertedString
 1000d41:	c7 04 24 06 00 00 00 	movl   $0x6,(%rsp)
 1000d48:	48 8d 34 25 78 62 01 	lea    0x1016278,%rsi
 1000d4f:	01 
 1000d50:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
 1000d55:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d57:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d59:	48 8d 5c 24 18       	lea    0x18(%rsp),%rbx
 1000d5e:	48 89 13             	mov    %rdx,(%rbx)
 1000d61:	89 4b 08             	mov    %ecx,0x8(%rbx)
 1000d64:	48 8d 34 25 80 40 01 	lea    0x1014080,%rsi
 1000d6b:	01 
 1000d6c:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
 1000d71:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d73:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d75:	48 89 c6             	mov    %rax,%rsi
 1000d78:	48 83 c6 40          	add    $0x40,%rsi
 1000d7c:	48 8d 7c 24 38       	lea    0x38(%rsp),%rdi
 1000d81:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d83:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d85:	48 8d 34 25 00 42 01 	lea    0x1014200,%rsi
 1000d8c:	01 
 1000d8d:	48 8d 7c 24 48       	lea    0x48(%rsp),%rdi
 1000d92:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d94:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000d96:	48 89 c6             	mov    %rax,%rsi
 1000d99:	48 83 c6 50          	add    $0x50,%rsi
 1000d9d:	48 8d 7c 24 58       	lea    0x58(%rsp),%rdi
 1000da2:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000da4:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000da6:	e8 c4 ac 00 00       	callq  100ba6f <runtime.concatstring>
 1000dab:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
 1000db0:	48 89 9c 24 88 00 00 	mov    %rbx,0x88(%rsp)
 1000db7:	00 
 1000db8:	8b 5c 24 70          	mov    0x70(%rsp),%ebx
 1000dbc:	89 9c 24 90 00 00 00 	mov    %ebx,0x90(%rsp)
 1000dc3:	48 83 c4 78          	add    $0x78,%rsp
 1000dc7:	c3                   	retq   
	}
	return "interface conversion: " + e.concreteString + " is not " + e.assertedString +
		": missing method " + e.missingMethod
 1000dc8:	c7 04 24 06 00 00 00 	movl   $0x6,(%rsp)
 1000dcf:	48 8d 34 25 78 62 01 	lea    0x1016278,%rsi
 1000dd6:	01 
 1000dd7:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
 1000ddc:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000dde:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000de0:	48 89 c6             	mov    %rax,%rsi
 1000de3:	48 83 c6 40          	add    $0x40,%rsi
 1000de7:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
 1000dec:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000dee:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000df0:	48 8d 34 25 98 40 01 	lea    0x1014098,%rsi
 1000df7:	01 
 1000df8:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
 1000dfd:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000dff:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000e01:	48 89 c6             	mov    %rax,%rsi
 1000e04:	48 83 c6 50          	add    $0x50,%rsi
 1000e08:	48 8d 7c 24 38       	lea    0x38(%rsp),%rdi
 1000e0d:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000e0f:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000e11:	48 8d 34 25 f0 56 01 	lea    0x10156f0,%rsi
 1000e18:	01 
 1000e19:	48 8d 7c 24 48       	lea    0x48(%rsp),%rdi
 1000e1e:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000e20:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000e22:	48 89 c6             	mov    %rax,%rsi
 1000e25:	48 83 c6 60          	add    $0x60,%rsi
 1000e29:	48 8d 7c 24 58       	lea    0x58(%rsp),%rdi
 1000e2e:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000e30:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1000e32:	e8 38 ac 00 00       	callq  100ba6f <runtime.concatstring>
 1000e37:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
 1000e3c:	48 89 9c 24 88 00 00 	mov    %rbx,0x88(%rsp)
 1000e43:	00 
 1000e44:	8b 5c 24 70          	mov    0x70(%rsp),%ebx
 1000e48:	89 9c 24 90 00 00 00 	mov    %ebx,0x90(%rsp)
 1000e4f:	48 83 c4 78          	add    $0x78,%rsp
 1000e53:	c3                   	retq   

0000000001000e54 <runtime.(*TypeAssertionError).Concrete>:
}

// Concrete returns the type of the concrete value in the failed type assertion.
// If the interface value was nil, Concrete returns nil.
func (e *TypeAssertionError) Concrete() Type {
 1000e54:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1000e5b:	ff ff 
 1000e5d:	48 3b 21             	cmp    (%rcx),%rsp
 1000e60:	77 05                	ja     1000e67 <runtime.(*TypeAssertionError).Concrete+0x13>
 1000e62:	e8 f7 0a 00 00       	callq  100195e <runtime.morestack24>
	return e.concreteType
 1000e67:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
 1000e6c:	48 83 c3 10          	add    $0x10,%rbx
 1000e70:	48 8b 2b             	mov    (%rbx),%rbp
 1000e73:	48 89 6c 24 10       	mov    %rbp,0x10(%rsp)
 1000e78:	48 8b 6b 08          	mov    0x8(%rbx),%rbp
 1000e7c:	48 89 6c 24 18       	mov    %rbp,0x18(%rsp)
 1000e81:	c3                   	retq   

0000000001000e82 <runtime.(*TypeAssertionError).Asserted>:
}

// Asserted returns the type incorrectly asserted by the type assertion.
func (e *TypeAssertionError) Asserted() Type {
 1000e82:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1000e89:	ff ff 
 1000e8b:	48 3b 21             	cmp    (%rcx),%rsp
 1000e8e:	77 05                	ja     1000e95 <runtime.(*TypeAssertionError).Asserted+0x13>
 1000e90:	e8 c9 0a 00 00       	callq  100195e <runtime.morestack24>
	return e.assertedType
 1000e95:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
 1000e9a:	48 83 c3 20          	add    $0x20,%rbx
 1000e9e:	48 8b 2b             	mov    (%rbx),%rbp
 1000ea1:	48 89 6c 24 10       	mov    %rbp,0x10(%rsp)
 1000ea6:	48 8b 6b 08          	mov    0x8(%rbx),%rbp
 1000eaa:	48 89 6c 24 18       	mov    %rbp,0x18(%rsp)
 1000eaf:	c3                   	retq   

0000000001000eb0 <runtime.(*TypeAssertionError).MissingMethod>:
// If the type assertion is to an interface type, MissingMethod returns the
// name of a method needed to satisfy that interface type but not implemented
// by Concrete.  If there are multiple such methods,
// MissingMethod returns one; which one is unspecified.
// If the type assertion is not to an interface type, MissingMethod returns an empty string.
func (e *TypeAssertionError) MissingMethod() string {
 1000eb0:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1000eb7:	ff ff 
 1000eb9:	48 3b 21             	cmp    (%rcx),%rsp
 1000ebc:	77 05                	ja     1000ec3 <runtime.(*TypeAssertionError).MissingMethod+0x13>
 1000ebe:	e8 9b 0a 00 00       	callq  100195e <runtime.morestack24>
	return e.missingMethod
 1000ec3:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
 1000ec8:	48 83 c3 60          	add    $0x60,%rbx
 1000ecc:	48 8b 2b             	mov    (%rbx),%rbp
 1000ecf:	48 89 6c 24 10       	mov    %rbp,0x10(%rsp)
 1000ed4:	8b 6b 08             	mov    0x8(%rbx),%ebp
 1000ed7:	89 6c 24 18          	mov    %ebp,0x18(%rsp)
 1000edb:	c3                   	retq   

0000000001000edc <runtime.newTypeAssertionError>:
}

// For calling from C.
func newTypeAssertionError(pt1, pt2, pt3 *Type, ps1, ps2, ps3 *string, pmeth *string, ret *interface{}) {
 1000edc:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1000ee3:	ff ff 
 1000ee5:	48 8d 44 24 f0       	lea    -0x10(%rsp),%rax
 1000eea:	48 3b 01             	cmp    (%rcx),%rax
 1000eed:	77 0a                	ja     1000ef9 <runtime.newTypeAssertionError+0x1d>
 1000eef:	b8 40 00 00 00       	mov    $0x40,%eax
 1000ef4:	e8 11 0a 00 00       	callq  100190a <runtime.morestack01>
 1000ef9:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
 1000f00:	4c 8b 8c 24 98 00 00 	mov    0x98(%rsp),%r9
 1000f07:	00 
 1000f08:	4c 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%r8
 1000f0f:	00 
 1000f10:	48 8b bc 24 a8 00 00 	mov    0xa8(%rsp),%rdi
 1000f17:	00 
 1000f18:	48 8b b4 24 b0 00 00 	mov    0xb0(%rsp),%rsi
 1000f1f:	00 
 1000f20:	48 8b 94 24 b8 00 00 	mov    0xb8(%rsp),%rdx
 1000f27:	00 
 1000f28:	48 8b 8c 24 c0 00 00 	mov    0xc0(%rsp),%rcx
 1000f2f:	00 
 1000f30:	48 8b 84 24 c8 00 00 	mov    0xc8(%rsp),%rax
 1000f37:	00 
	var t1, t2, t3 Type
 1000f38:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
 1000f3f:	00 00 
 1000f41:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
 1000f48:	00 00 
 1000f4a:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
 1000f51:	00 00 
 1000f53:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
 1000f5a:	00 00 
 1000f5c:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
 1000f63:	00 00 
 1000f65:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
 1000f6c:	00 00 
	var s1, s2, s3, meth string
 1000f6e:	48 c7 44 24 70 00 00 	movq   $0x0,0x70(%rsp)
 1000f75:	00 00 
 1000f77:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%rsp)
 1000f7e:	00 
 1000f7f:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
 1000f86:	00 00 
 1000f88:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%rsp)
 1000f8f:	00 
 1000f90:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
 1000f97:	00 00 
 1000f99:	c7 44 24 68 00 00 00 	movl   $0x0,0x68(%rsp)
 1000fa0:	00 
 1000fa1:	48 c7 84 24 80 00 00 	movq   $0x0,0x80(%rsp)
 1000fa8:	00 00 00 00 00 
 1000fad:	c7 84 24 88 00 00 00 	movl   $0x0,0x88(%rsp)
 1000fb4:	00 00 00 00 

	if pt1 != nil {
 1000fb8:	48 31 ed             	xor    %rbp,%rbp
 1000fbb:	49 39 e9             	cmp    %rbp,%r9
 1000fbe:	74 11                	je     1000fd1 <runtime.newTypeAssertionError+0xf5>
		t1 = *pt1
 1000fc0:	49 8b 29             	mov    (%r9),%rbp
 1000fc3:	48 89 6c 24 20       	mov    %rbp,0x20(%rsp)
 1000fc8:	49 8b 69 08          	mov    0x8(%r9),%rbp
 1000fcc:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
	}
	if pt2 != nil {
 1000fd1:	48 31 ed             	xor    %rbp,%rbp
 1000fd4:	49 39 e8             	cmp    %rbp,%r8
 1000fd7:	74 11                	je     1000fea <runtime.newTypeAssertionError+0x10e>
		t2 = *pt2
 1000fd9:	49 8b 28             	mov    (%r8),%rbp
 1000fdc:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
 1000fe1:	49 8b 68 08          	mov    0x8(%r8),%rbp
 1000fe5:	48 89 6c 24 58       	mov    %rbp,0x58(%rsp)
	}
	if pt3 != nil {
 1000fea:	48 31 ed             	xor    %rbp,%rbp
 1000fed:	48 39 ef             	cmp    %rbp,%rdi
 1000ff0:	74 11                	je     1001003 <runtime.newTypeAssertionError+0x127>
		t3 = *pt3
 1000ff2:	48 8b 2f             	mov    (%rdi),%rbp
 1000ff5:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
 1000ffa:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
 1000ffe:	48 89 6c 24 38       	mov    %rbp,0x38(%rsp)
	}
	if ps1 != nil {
 1001003:	48 31 ed             	xor    %rbp,%rbp
 1001006:	48 39 ee             	cmp    %rbp,%rsi
 1001009:	74 0f                	je     100101a <runtime.newTypeAssertionError+0x13e>
		s1 = *ps1
 100100b:	48 8b 2e             	mov    (%rsi),%rbp
 100100e:	48 89 6c 24 70       	mov    %rbp,0x70(%rsp)
 1001013:	8b 6e 08             	mov    0x8(%rsi),%ebp
 1001016:	89 6c 24 78          	mov    %ebp,0x78(%rsp)
	}
	if ps2 != nil {
 100101a:	48 31 ed             	xor    %rbp,%rbp
 100101d:	48 39 ea             	cmp    %rbp,%rdx
 1001020:	74 0f                	je     1001031 <runtime.newTypeAssertionError+0x155>
		s2 = *ps2
 1001022:	48 8b 2a             	mov    (%rdx),%rbp
 1001025:	48 89 6c 24 40       	mov    %rbp,0x40(%rsp)
 100102a:	8b 6a 08             	mov    0x8(%rdx),%ebp
 100102d:	89 6c 24 48          	mov    %ebp,0x48(%rsp)
	}
	if ps3 != nil {
 1001031:	48 31 ed             	xor    %rbp,%rbp
 1001034:	48 39 e9             	cmp    %rbp,%rcx
 1001037:	74 0f                	je     1001048 <runtime.newTypeAssertionError+0x16c>
		s3 = *ps3
 1001039:	48 8b 29             	mov    (%rcx),%rbp
 100103c:	48 89 6c 24 60       	mov    %rbp,0x60(%rsp)
 1001041:	8b 69 08             	mov    0x8(%rcx),%ebp
 1001044:	89 6c 24 68          	mov    %ebp,0x68(%rsp)
	}
	if pmeth != nil {
 1001048:	48 31 ed             	xor    %rbp,%rbp
 100104b:	48 39 e8             	cmp    %rbp,%rax
 100104e:	74 15                	je     1001065 <runtime.newTypeAssertionError+0x189>
		meth = *pmeth
 1001050:	48 8b 28             	mov    (%rax),%rbp
 1001053:	48 89 ac 24 80 00 00 	mov    %rbp,0x80(%rsp)
 100105a:	00 
 100105b:	8b 68 08             	mov    0x8(%rax),%ebp
 100105e:	89 ac 24 88 00 00 00 	mov    %ebp,0x88(%rsp)
	}
	*ret = &TypeAssertionError{t1, t2, t3, s1, s2, s3, meth}
 1001065:	c7 04 24 70 00 00 00 	movl   $0x70,(%rsp)
 100106c:	e8 03 21 00 00       	callq  1003174 <runtime.new>
 1001071:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
 1001076:	48 8b 6c 24 20       	mov    0x20(%rsp),%rbp
 100107b:	48 89 28             	mov    %rbp,(%rax)
 100107e:	48 8b 6c 24 28       	mov    0x28(%rsp),%rbp
 1001083:	48 89 68 08          	mov    %rbp,0x8(%rax)
 1001087:	48 89 c3             	mov    %rax,%rbx
 100108a:	48 83 c3 10          	add    $0x10,%rbx
 100108e:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
 1001093:	48 89 2b             	mov    %rbp,(%rbx)
 1001096:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 100109b:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
 100109f:	48 89 c3             	mov    %rax,%rbx
 10010a2:	48 83 c3 20          	add    $0x20,%rbx
 10010a6:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
 10010ab:	48 89 2b             	mov    %rbp,(%rbx)
 10010ae:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
 10010b3:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
 10010b7:	48 89 c3             	mov    %rax,%rbx
 10010ba:	48 83 c3 30          	add    $0x30,%rbx
 10010be:	48 8b 6c 24 70       	mov    0x70(%rsp),%rbp
 10010c3:	48 89 2b             	mov    %rbp,(%rbx)
 10010c6:	8b 6c 24 78          	mov    0x78(%rsp),%ebp
 10010ca:	89 6b 08             	mov    %ebp,0x8(%rbx)
 10010cd:	48 89 c3             	mov    %rax,%rbx
 10010d0:	48 83 c3 40          	add    $0x40,%rbx
 10010d4:	48 8b 6c 24 40       	mov    0x40(%rsp),%rbp
 10010d9:	48 89 2b             	mov    %rbp,(%rbx)
 10010dc:	8b 6c 24 48          	mov    0x48(%rsp),%ebp
 10010e0:	89 6b 08             	mov    %ebp,0x8(%rbx)
 10010e3:	48 89 c3             	mov    %rax,%rbx
 10010e6:	48 83 c3 50          	add    $0x50,%rbx
 10010ea:	48 8b 6c 24 60       	mov    0x60(%rsp),%rbp
 10010ef:	48 89 2b             	mov    %rbp,(%rbx)
 10010f2:	8b 6c 24 68          	mov    0x68(%rsp),%ebp
 10010f6:	89 6b 08             	mov    %ebp,0x8(%rbx)
 10010f9:	48 89 c3             	mov    %rax,%rbx
 10010fc:	48 83 c3 60          	add    $0x60,%rbx
 1001100:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
 1001107:	00 
 1001108:	48 89 2b             	mov    %rbp,(%rbx)
 100110b:	8b ac 24 88 00 00 00 	mov    0x88(%rsp),%ebp
 1001112:	89 6b 08             	mov    %ebp,0x8(%rbx)
 1001115:	48 c7 04 24 b0 18 01 	movq   $0x10118b0,(%rsp)
 100111c:	01 
 100111d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1001122:	e8 05 10 00 00       	callq  100212c <runtime.convT2E>
 1001127:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
 100112c:	48 8b bc 24 d0 00 00 	mov    0xd0(%rsp),%rdi
 1001133:	00 
 1001134:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001136:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
}
 1001138:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
 100113f:	c3                   	retq   

0000000001001140 <runtime.errorString.RuntimeError>:

// An errorString represents a runtime error described by a single string.
type errorString string

func (e errorString) RuntimeError() {}
 1001140:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001147:	ff ff 
 1001149:	48 3b 21             	cmp    (%rcx),%rsp
 100114c:	77 05                	ja     1001153 <runtime.errorString.RuntimeError+0x13>
 100114e:	e8 02 08 00 00       	callq  1001955 <runtime.morestack16>
 1001153:	c3                   	retq   

0000000001001154 <runtime.errorString.String>:

func (e errorString) String() string {
 1001154:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100115b:	ff ff 
 100115d:	48 3b 21             	cmp    (%rcx),%rsp
 1001160:	77 05                	ja     1001167 <runtime.errorString.String+0x13>
 1001162:	e8 00 08 00 00       	callq  1001967 <runtime.morestack32>
 1001167:	48 83 ec 38          	sub    $0x38,%rsp
	return "runtime error: " + string(e)
 100116b:	c7 04 24 02 00 00 00 	movl   $0x2,(%rsp)
 1001172:	48 8d 34 25 90 5b 01 	lea    0x1015b90,%rsi
 1001179:	01 
 100117a:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
 100117f:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001181:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001183:	48 8d 5c 24 18       	lea    0x18(%rsp),%rbx
 1001188:	48 8b 6c 24 40       	mov    0x40(%rsp),%rbp
 100118d:	48 89 2b             	mov    %rbp,(%rbx)
 1001190:	8b 6c 24 48          	mov    0x48(%rsp),%ebp
 1001194:	89 6b 08             	mov    %ebp,0x8(%rbx)
 1001197:	e8 d3 a8 00 00       	callq  100ba6f <runtime.concatstring>
 100119c:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
 10011a1:	48 89 5c 24 50       	mov    %rbx,0x50(%rsp)
 10011a6:	8b 5c 24 30          	mov    0x30(%rsp),%ebx
 10011aa:	89 5c 24 58          	mov    %ebx,0x58(%rsp)
 10011ae:	48 83 c4 38          	add    $0x38,%rsp
 10011b2:	c3                   	retq   

00000000010011b3 <runtime.newErrorString>:
}

// For calling from C.
func newErrorString(s string, ret *interface{}) {
 10011b3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10011ba:	ff ff 
 10011bc:	48 3b 21             	cmp    (%rcx),%rsp
 10011bf:	77 05                	ja     10011c6 <runtime.newErrorString+0x13>
 10011c1:	e8 98 07 00 00       	callq  100195e <runtime.morestack24>
 10011c6:	48 83 ec 28          	sub    $0x28,%rsp
	*ret = errorString(s)
 10011ca:	48 c7 04 24 08 0b 01 	movq   $0x1010b08,(%rsp)
 10011d1:	01 
 10011d2:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
 10011d7:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
 10011dc:	48 89 2b             	mov    %rbp,(%rbx)
 10011df:	8b 6c 24 38          	mov    0x38(%rsp),%ebp
 10011e3:	89 6b 08             	mov    %ebp,0x8(%rbx)
 10011e6:	e8 41 0f 00 00       	callq  100212c <runtime.convT2E>
 10011eb:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
 10011f0:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
 10011f5:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10011f7:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
}
 10011f9:	48 83 c4 28          	add    $0x28,%rsp
 10011fd:	c3                   	retq   

00000000010011fe <runtime.printany>:

// For calling from C.
// Prints an argument passed to panic.
// There's room for arbitrary complexity here, but we keep it
// simple and handle just a few important cases: int, string, and Stringer.
func printany(i interface{}) {
 10011fe:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001205:	ff ff 
 1001207:	48 3b 21             	cmp    (%rcx),%rsp
 100120a:	77 05                	ja     1001211 <runtime.printany+0x13>
 100120c:	e8 44 07 00 00       	callq  1001955 <runtime.morestack16>
 1001211:	48 83 ec 78          	sub    $0x78,%rsp
	switch v := i.(type) {
 1001215:	48 8b 9c 24 80 00 00 	mov    0x80(%rsp),%rbx
 100121c:	00 
 100121d:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
 1001222:	48 8b 9c 24 88 00 00 	mov    0x88(%rsp),%rbx
 1001229:	00 
 100122a:	48 89 5c 24 70       	mov    %rbx,0x70(%rsp)
		print("nil")
	case stringer:
		print(v.String())
	case int:
		print(v)
	case string:
 100122f:	48 8d 1c 24          	lea    (%rsp),%rbx
 1001233:	48 8b 6c 24 68       	mov    0x68(%rsp),%rbp
 1001238:	48 89 2b             	mov    %rbp,(%rbx)
 100123b:	48 8b 6c 24 70       	mov    0x70(%rsp),%rbp
 1001240:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
 1001244:	e8 6b 14 00 00       	callq  10026b4 <runtime.efacethash>
 1001249:	8b 5c 24 10          	mov    0x10(%rsp),%ebx
 100124d:	89 5c 24 34          	mov    %ebx,0x34(%rsp)
 1001251:	48 8d 5c 24 68       	lea    0x68(%rsp),%rbx
 1001256:	48 83 3b 00          	cmpq   $0x0,(%rbx)
 100125a:	75 2e                	jne    100128a <runtime.printany+0x8c>
// Prints an argument passed to panic.
// There's room for arbitrary complexity here, but we keep it
// simple and handle just a few important cases: int, string, and Stringer.
func printany(i interface{}) {
	switch v := i.(type) {
	case nil:
 100125c:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
 1001261:	48 89 5c 24 38       	mov    %rbx,0x38(%rsp)
 1001266:	48 8b 5c 24 70       	mov    0x70(%rsp),%rbx
 100126b:	48 89 5c 24 40       	mov    %rbx,0x40(%rsp)
		print("nil")
 1001270:	48 8d 34 25 a0 3f 01 	lea    0x1013fa0,%rsi
 1001277:	01 
 1001278:	48 8d 3c 24          	lea    (%rsp),%rdi
 100127c:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100127e:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001280:	e8 43 6a 00 00       	callq  1007cc8 <runtime.printstring>
	case string:
		print(v)
	default:
		print("(", typestring(i), ") ", i)
	}
}
 1001285:	48 83 c4 78          	add    $0x78,%rsp
 1001289:	c3                   	retq   
		print("nil")
	case stringer:
		print(v.String())
	case int:
		print(v)
	case string:
 100128a:	48 c7 04 24 08 03 01 	movq   $0x1010308,(%rsp)
 1001291:	01 
 1001292:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
 1001297:	48 8b 6c 24 68       	mov    0x68(%rsp),%rbp
 100129c:	48 89 2b             	mov    %rbp,(%rbx)
 100129f:	48 8b 6c 24 70       	mov    0x70(%rsp),%rbp
 10012a4:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
 10012a8:	e8 54 0f 00 00       	callq  1002201 <runtime.assertE2I2>
 10012ad:	48 8d 5c 24 18       	lea    0x18(%rsp),%rbx
 10012b2:	48 8b 2b             	mov    (%rbx),%rbp
 10012b5:	48 89 6c 24 48       	mov    %rbp,0x48(%rsp)
 10012ba:	48 8b 6b 08          	mov    0x8(%rbx),%rbp
 10012be:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
 10012c3:	8a 5c 24 28          	mov    0x28(%rsp),%bl
 10012c7:	88 d8                	mov    %bl,%al
 10012c9:	80 f8 00             	cmp    $0x0,%al
 10012cc:	74 2a                	je     10012f8 <runtime.printany+0xfa>
func printany(i interface{}) {
	switch v := i.(type) {
	case nil:
		print("nil")
	case stringer:
		print(v.String())
 10012ce:	48 8d 74 24 48       	lea    0x48(%rsp),%rsi
 10012d3:	48 8b 5e 08          	mov    0x8(%rsi),%rbx
 10012d7:	48 89 1c 24          	mov    %rbx,(%rsp)
 10012db:	48 8b 36             	mov    (%rsi),%rsi
 10012de:	48 8b 76 20          	mov    0x20(%rsi),%rsi
 10012e2:	ff d6                	callq  *%rsi
 10012e4:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
 10012e9:	48 8d 3c 24          	lea    (%rsp),%rdi
 10012ed:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10012ef:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10012f1:	e8 d2 69 00 00       	callq  1007cc8 <runtime.printstring>
	case string:
		print(v)
	default:
		print("(", typestring(i), ") ", i)
	}
}
 10012f6:	eb 8d                	jmp    1001285 <runtime.printany+0x87>
		print("nil")
	case stringer:
		print(v.String())
	case int:
		print(v)
	case string:
 10012f8:	8b 5c 24 34          	mov    0x34(%rsp),%ebx
 10012fc:	81 fb b4 5c ff e0    	cmp    $0xe0ff5cb4,%ebx
 1001302:	75 5f                	jne    1001363 <runtime.printany+0x165>
 1001304:	48 c7 04 24 48 f2 00 	movq   $0x100f248,(%rsp)
 100130b:	01 
 100130c:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
 1001311:	48 8b 6c 24 68       	mov    0x68(%rsp),%rbp
 1001316:	48 89 2b             	mov    %rbp,(%rbx)
 1001319:	48 8b 6c 24 70       	mov    0x70(%rsp),%rbp
 100131e:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
 1001322:	e8 5c 0e 00 00       	callq  1002183 <runtime.assertE2T2>
 1001327:	48 8d 5c 24 18       	lea    0x18(%rsp),%rbx
 100132c:	48 8b 2b             	mov    (%rbx),%rbp
 100132f:	48 89 6c 24 58       	mov    %rbp,0x58(%rsp)
 1001334:	8b 6b 08             	mov    0x8(%rbx),%ebp
 1001337:	89 6c 24 60          	mov    %ebp,0x60(%rsp)
 100133b:	8a 5c 24 28          	mov    0x28(%rsp),%bl
 100133f:	88 d8                	mov    %bl,%al
 1001341:	80 f8 00             	cmp    $0x0,%al
 1001344:	74 1d                	je     1001363 <runtime.printany+0x165>
		print(v)
 1001346:	48 8d 1c 24          	lea    (%rsp),%rbx
 100134a:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 100134f:	48 89 2b             	mov    %rbp,(%rbx)
 1001352:	8b 6c 24 60          	mov    0x60(%rsp),%ebp
 1001356:	89 6b 08             	mov    %ebp,0x8(%rbx)
 1001359:	e8 6a 69 00 00       	callq  1007cc8 <runtime.printstring>
	default:
		print("(", typestring(i), ") ", i)
	}
}
 100135e:	e9 22 ff ff ff       	jmpq   1001285 <runtime.printany+0x87>
		print("nil")
	case stringer:
		print(v.String())
	case int:
		print(v)
	case string:
 1001363:	8b 5c 24 34          	mov    0x34(%rsp),%ebx
 1001367:	81 fb fa 71 53 f7    	cmp    $0xf75371fa,%ebx
 100136d:	75 4b                	jne    10013ba <runtime.printany+0x1bc>
 100136f:	48 c7 04 24 e8 f0 00 	movq   $0x100f0e8,(%rsp)
 1001376:	01 
 1001377:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
 100137c:	48 8b 6c 24 68       	mov    0x68(%rsp),%rbp
 1001381:	48 89 2b             	mov    %rbp,(%rbx)
 1001384:	48 8b 6c 24 70       	mov    0x70(%rsp),%rbp
 1001389:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
 100138d:	e8 f1 0d 00 00       	callq  1002183 <runtime.assertE2T2>
 1001392:	8b 5c 24 18          	mov    0x18(%rsp),%ebx
 1001396:	89 5c 24 30          	mov    %ebx,0x30(%rsp)
 100139a:	8a 5c 24 1c          	mov    0x1c(%rsp),%bl
 100139e:	88 d8                	mov    %bl,%al
 10013a0:	80 f8 00             	cmp    $0x0,%al
 10013a3:	74 15                	je     10013ba <runtime.printany+0x1bc>
	case nil:
		print("nil")
	case stringer:
		print(v.String())
	case int:
		print(v)
 10013a5:	8b 5c 24 30          	mov    0x30(%rsp),%ebx
 10013a9:	48 63 db             	movslq %ebx,%rbx
 10013ac:	48 89 1c 24          	mov    %rbx,(%rsp)
 10013b0:	e8 d1 67 00 00       	callq  1007b86 <runtime.printint>
	case string:
		print(v)
	default:
		print("(", typestring(i), ") ", i)
	}
}
 10013b5:	e9 cb fe ff ff       	jmpq   1001285 <runtime.printany+0x87>
		print(v.String())
	case int:
		print(v)
	case string:
		print(v)
	default:
 10013ba:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
 10013bf:	48 8b 5c 24 70       	mov    0x70(%rsp),%rbx
		print("(", typestring(i), ") ", i)
 10013c4:	48 8d 34 25 80 3e 01 	lea    0x1013e80,%rsi
 10013cb:	01 
 10013cc:	48 8d 3c 24          	lea    (%rsp),%rdi
 10013d0:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10013d2:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10013d4:	e8 ef 68 00 00       	callq  1007cc8 <runtime.printstring>
 10013d9:	48 8d 1c 24          	lea    (%rsp),%rbx
 10013dd:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
 10013e4:	00 
 10013e5:	48 89 2b             	mov    %rbp,(%rbx)
 10013e8:	48 8b ac 24 88 00 00 	mov    0x88(%rsp),%rbp
 10013ef:	00 
 10013f0:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
 10013f4:	e8 43 69 00 00       	callq  1007d3c <runtime.typestring>
 10013f9:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
 10013fe:	48 8d 3c 24          	lea    (%rsp),%rdi
 1001402:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001404:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001406:	e8 bd 68 00 00       	callq  1007cc8 <runtime.printstring>
 100140b:	48 8d 34 25 90 3e 01 	lea    0x1013e90,%rsi
 1001412:	01 
 1001413:	48 8d 3c 24          	lea    (%rsp),%rdi
 1001417:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001419:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100141b:	e8 a8 68 00 00       	callq  1007cc8 <runtime.printstring>
 1001420:	48 8d 1c 24          	lea    (%rsp),%rbx
 1001424:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
 100142b:	00 
 100142c:	48 89 2b             	mov    %rbp,(%rbx)
 100142f:	48 8b ac 24 88 00 00 	mov    0x88(%rsp),%rbp
 1001436:	00 
 1001437:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
 100143b:	e8 ff 07 00 00       	callq  1001c3f <runtime.printeface>
	}
}
 1001440:	e9 40 fe ff ff       	jmpq   1001285 <runtime.printany+0x87>

0000000001001445 <runtime.panicwrap>:

// called from generated code
func panicwrap(pkg, typ, meth string) {
 1001445:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100144c:	ff ff 
 100144e:	48 8d 44 24 d8       	lea    -0x28(%rsp),%rax
 1001453:	48 3b 01             	cmp    (%rcx),%rax
 1001456:	77 05                	ja     100145d <runtime.panicwrap+0x18>
 1001458:	e8 1c 05 00 00       	callq  1001979 <runtime.morestack48>
 100145d:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
 1001464:	48 8b 8c 24 c0 00 00 	mov    0xc0(%rsp),%rcx
 100146b:	00 
 100146c:	8b 84 24 c8 00 00 00 	mov    0xc8(%rsp),%eax
	panic("value method " + pkg + "." + typ + "." + meth + " called using nil *" + typ + " pointer")
 1001473:	c7 04 24 09 00 00 00 	movl   $0x9,(%rsp)
 100147a:	48 8d 34 25 b0 5f 01 	lea    0x1015fb0,%rsi
 1001481:	01 
 1001482:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
 1001487:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001489:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100148b:	48 8d 5c 24 18       	lea    0x18(%rsp),%rbx
 1001490:	48 8b ac 24 b0 00 00 	mov    0xb0(%rsp),%rbp
 1001497:	00 
 1001498:	48 89 2b             	mov    %rbp,(%rbx)
 100149b:	8b ac 24 b8 00 00 00 	mov    0xb8(%rsp),%ebp
 10014a2:	89 6b 08             	mov    %ebp,0x8(%rbx)
 10014a5:	48 8d 34 25 a0 3e 01 	lea    0x1013ea0,%rsi
 10014ac:	01 
 10014ad:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
 10014b2:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10014b4:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10014b6:	48 8d 5c 24 38       	lea    0x38(%rsp),%rbx
 10014bb:	48 89 0b             	mov    %rcx,(%rbx)
 10014be:	89 43 08             	mov    %eax,0x8(%rbx)
 10014c1:	48 8d 34 25 a0 3e 01 	lea    0x1013ea0,%rsi
 10014c8:	01 
 10014c9:	48 8d 7c 24 48       	lea    0x48(%rsp),%rdi
 10014ce:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10014d0:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10014d2:	48 8d 5c 24 58       	lea    0x58(%rsp),%rbx
 10014d7:	48 8b ac 24 d0 00 00 	mov    0xd0(%rsp),%rbp
 10014de:	00 
 10014df:	48 89 2b             	mov    %rbp,(%rbx)
 10014e2:	8b ac 24 d8 00 00 00 	mov    0xd8(%rsp),%ebp
 10014e9:	89 6b 08             	mov    %ebp,0x8(%rbx)
 10014ec:	48 8d 34 25 b0 52 01 	lea    0x10152b0,%rsi
 10014f3:	01 
 10014f4:	48 8d 7c 24 68       	lea    0x68(%rsp),%rdi
 10014f9:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10014fb:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10014fd:	48 8d 5c 24 78       	lea    0x78(%rsp),%rbx
 1001502:	48 89 0b             	mov    %rcx,(%rbx)
 1001505:	89 43 08             	mov    %eax,0x8(%rbx)
 1001508:	48 8d 34 25 b0 40 01 	lea    0x10140b0,%rsi
 100150f:	01 
 1001510:	48 8d bc 24 88 00 00 	lea    0x88(%rsp),%rdi
 1001517:	00 
 1001518:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100151a:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100151c:	e8 4e a5 00 00       	callq  100ba6f <runtime.concatstring>
 1001521:	48 8d b4 24 98 00 00 	lea    0x98(%rsp),%rsi
 1001528:	00 
 1001529:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
 100152e:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001530:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001532:	48 c7 04 24 48 f2 00 	movq   $0x100f248,(%rsp)
 1001539:	01 
 100153a:	e8 ed 0b 00 00       	callq  100212c <runtime.convT2E>
 100153f:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
 1001544:	48 8d 3c 24          	lea    (%rsp),%rdi
 1001548:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100154a:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100154c:	e8 4b 81 00 00       	callq  100969c <runtime.panic>
}
 1001551:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
 1001558:	c3                   	retq   

0000000001001559 <runtime.(*errorString).RuntimeError>:
 1001559:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001560:	ff ff 
 1001562:	48 3b 21             	cmp    (%rcx),%rsp
 1001565:	77 05                	ja     100156c <runtime.(*errorString).RuntimeError+0x13>
 1001567:	e8 e0 03 00 00       	callq  100194c <runtime.morestack8>
 100156c:	48 83 ec 30          	sub    $0x30,%rsp
 1001570:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
 1001575:	48 31 ed             	xor    %rbp,%rbp
 1001578:	48 39 eb             	cmp    %rbp,%rbx
 100157b:	75 37                	jne    10015b4 <runtime.(*errorString).RuntimeError+0x5b>
 100157d:	48 8d 34 25 c8 4f 01 	lea    0x1014fc8,%rsi
 1001584:	01 
 1001585:	48 8d 3c 24          	lea    (%rsp),%rdi
 1001589:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100158b:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100158d:	48 8d 34 25 d8 48 01 	lea    0x10148d8,%rsi
 1001594:	01 
 1001595:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
 100159a:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100159c:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100159e:	48 8d 34 25 b0 57 01 	lea    0x10157b0,%rsi
 10015a5:	01 
 10015a6:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
 10015ab:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10015ad:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10015af:	e8 91 fe ff ff       	callq  1001445 <runtime.panicwrap>
 10015b4:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
 10015b9:	48 8d 3c 24          	lea    (%rsp),%rdi
 10015bd:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10015bf:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10015c1:	e8 7a fb ff ff       	callq  1001140 <runtime.errorString.RuntimeError>
 10015c6:	48 83 c4 30          	add    $0x30,%rsp
 10015ca:	c3                   	retq   

00000000010015cb <runtime.(*errorString).String>:
 10015cb:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10015d2:	ff ff 
 10015d4:	48 3b 21             	cmp    (%rcx),%rsp
 10015d7:	77 05                	ja     10015de <runtime.(*errorString).String+0x13>
 10015d9:	e8 80 03 00 00       	callq  100195e <runtime.morestack24>
 10015de:	48 83 ec 30          	sub    $0x30,%rsp
 10015e2:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
 10015e7:	48 31 ed             	xor    %rbp,%rbp
 10015ea:	48 39 eb             	cmp    %rbp,%rbx
 10015ed:	75 37                	jne    1001626 <runtime.(*errorString).String+0x5b>
 10015ef:	48 8d 34 25 c8 4f 01 	lea    0x1014fc8,%rsi
 10015f6:	01 
 10015f7:	48 8d 3c 24          	lea    (%rsp),%rdi
 10015fb:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10015fd:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 10015ff:	48 8d 34 25 d8 48 01 	lea    0x10148d8,%rsi
 1001606:	01 
 1001607:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
 100160c:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100160e:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001610:	48 8d 34 25 18 45 01 	lea    0x1014518,%rsi
 1001617:	01 
 1001618:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
 100161d:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 100161f:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001621:	e8 1f fe ff ff       	callq  1001445 <runtime.panicwrap>
 1001626:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
 100162b:	48 8d 3c 24          	lea    (%rsp),%rdi
 100162f:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001631:	48 a5                	movsq  %ds:(%rsi),%es:(%rdi)
 1001633:	e8 1c fb ff ff       	callq  1001154 <runtime.errorString.String>
 1001638:	48 8d 5c 24 10       	lea    0x10(%rsp),%rbx
 100163d:	48 8b 2b             	mov    (%rbx),%rbp
 1001640:	48 89 6c 24 40       	mov    %rbp,0x40(%rsp)
 1001645:	8b 6b 08             	mov    0x8(%rbx),%ebp
 1001648:	89 6c 24 48          	mov    %ebp,0x48(%rsp)
 100164c:	48 83 c4 30          	add    $0x30,%rsp
 1001650:	c3                   	retq   

0000000001001651 <_rt0_amd64>:

#include "amd64/asm.h"

TEXT _rt0_amd64(SB),7,$-8
	// copy arguments forward on an even stack
	MOVQ	0(DI), AX		// argc
 1001651:	48 8b 07             	mov    (%rdi),%rax
	LEAQ	8(DI), BX		// argv
 1001654:	48 8d 5f 08          	lea    0x8(%rdi),%rbx
	SUBQ	$(4*8+7), SP		// 2args 2auto
 1001658:	48 83 ec 27          	sub    $0x27,%rsp
	ANDQ	$~15, SP
 100165c:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
	MOVQ	AX, 16(SP)
 1001660:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	MOVQ	BX, 24(SP)
 1001665:	48 89 5c 24 18       	mov    %rbx,0x18(%rsp)

	// if there is an initcgo, call it.
	MOVQ	initcgo(SB), AX
 100166a:	48 8b 04 25 98 4e 02 	mov    0x1024e98,%rax
 1001671:	01 
	TESTQ	AX, AX
 1001672:	48 85 c0             	test   %rax,%rax
	JZ	needtls
 1001675:	74 0c                	je     1001683 <_rt0_amd64+0x32>
	CALL	AX
 1001677:	ff d0                	callq  *%rax
	CMPL	runtime·iswindows(SB), $0
 1001679:	83 3c 25 1c 4e 02 01 	cmpl   $0x0,0x1024e1c
 1001680:	00 
	JEQ ok
 1001681:	74 31                	je     10016b4 <_rt0_amd64+0x63>

needtls:
	LEAQ	runtime·tls0(SB), DI
 1001683:	48 8d 3c 25 70 4f 02 	lea    0x1024f70,%rdi
 100168a:	01 
	CALL	runtime·settls(SB)
 100168b:	e8 19 b3 00 00       	callq  100c9a9 <runtime.settls>

	// store through it, to make sure it works
	get_tls(BX)
	MOVQ	$0x123, g(BX)
 1001690:	64 48 c7 04 25 f0 ff 	movq   $0x123,%fs:0xfffffffffffffff0
 1001697:	ff ff 23 01 00 00 
	MOVQ	runtime·tls0(SB), AX
 100169d:	48 8b 04 25 70 4f 02 	mov    0x1024f70,%rax
 10016a4:	01 
	CMPQ	AX, $0x123
 10016a5:	48 3d 23 01 00 00    	cmp    $0x123,%rax
	JEQ 2(PC)
 10016ab:	74 07                	je     10016b4 <_rt0_amd64+0x63>
	MOVL	AX, 0	// abort
 10016ad:	89 04 25 00 00 00 00 	mov    %eax,0x0
ok:
	// set the per-goroutine and per-mach "registers"
	get_tls(BX)
	LEAQ	runtime·g0(SB), CX
 10016b4:	48 8d 0c 25 10 50 02 	lea    0x1025010,%rcx
 10016bb:	01 
	MOVQ	CX, g(BX)
 10016bc:	64 48 89 0c 25 f0 ff 	mov    %rcx,%fs:0xfffffffffffffff0
 10016c3:	ff ff 
	LEAQ	runtime·m0(SB), AX
 10016c5:	48 8d 04 25 c8 53 02 	lea    0x10253c8,%rax
 10016cc:	01 
	MOVQ	AX, m(BX)
 10016cd:	64 48 89 04 25 f8 ff 	mov    %rax,%fs:0xfffffffffffffff8
 10016d4:	ff ff 

	// save m->g0 = g0
	MOVQ	CX, m_g0(AX)
 10016d6:	48 89 08             	mov    %rcx,(%rax)

	// create istack out of the given (operating system) stack
	LEAQ	(-8192+104)(SP), AX
 10016d9:	48 8d 84 24 68 e0 ff 	lea    -0x1f98(%rsp),%rax
 10016e0:	ff 
	MOVQ	AX, g_stackguard(CX)
 10016e1:	48 89 01             	mov    %rax,(%rcx)
	MOVQ	SP, g_stackbase(CX)
 10016e4:	48 89 61 08          	mov    %rsp,0x8(%rcx)

	CLD				// convention is D is always left cleared
 10016e8:	fc                   	cld    
	CALL	runtime·check(SB)
 10016e9:	e8 e0 8a 00 00       	callq  100a1ce <runtime.check>

	MOVL	16(SP), AX		// copy argc
 10016ee:	8b 44 24 10          	mov    0x10(%rsp),%eax
	MOVL	AX, 0(SP)
 10016f2:	89 04 24             	mov    %eax,(%rsp)
	MOVQ	24(SP), AX		// copy argv
 10016f5:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
	MOVQ	AX, 8(SP)
 10016fa:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	CALL	runtime·args(SB)
 10016ff:	e8 26 88 00 00       	callq  1009f2a <runtime.args>
	CALL	runtime·osinit(SB)
 1001704:	e8 12 b9 00 00       	callq  100d01b <runtime.osinit>
	CALL	runtime·schedinit(SB)
 1001709:	e8 ab 66 00 00       	callq  1007db9 <runtime.schedinit>

	// create a new goroutine to start program
	PUSHQ	$runtime·mainstart(SB)		// entry
 100170e:	68 27 17 00 01       	pushq  $0x1001727
	PUSHQ	$0			// arg size
 1001713:	6a 00                	pushq  $0x0
	CALL	runtime·newproc(SB)
 1001715:	e8 ac 7b 00 00       	callq  10092c6 <runtime.newproc>
	POPQ	AX
 100171a:	58                   	pop    %rax
	POPQ	AX
 100171b:	58                   	pop    %rax

	// start this M
	CALL	runtime·mstart(SB)
 100171c:	e8 2a 72 00 00       	callq  100894b <runtime.mstart>

	CALL	runtime·notok(SB)		// never returns
 1001721:	e8 cd b1 00 00       	callq  100c8f3 <runtime.notok>
	RET
 1001726:	c3                   	retq   

0000000001001727 <runtime.mainstart>:

TEXT runtime·mainstart(SB),7,$0
	CALL	main·init(SB)
 1001727:	e8 05 f5 ff ff       	callq  1000c31 <main.init>
	CALL	runtime·initdone(SB)
 100172c:	e8 e5 67 00 00       	callq  1007f16 <runtime.initdone>
	CALL	main·main(SB)
 1001731:	e8 ca f4 ff ff       	callq  1000c00 <main.main>
	PUSHQ	$0
 1001736:	6a 00                	pushq  $0x0
	CALL	runtime·exit(SB)
 1001738:	e8 34 b0 00 00       	callq  100c771 <runtime.exit>
	POPQ	AX
 100173d:	58                   	pop    %rax
	CALL	runtime·notok(SB)
 100173e:	e8 b0 b1 00 00       	callq  100c8f3 <runtime.notok>
	RET
 1001743:	c3                   	retq   

0000000001001744 <runtime.gosave>:
 */

// void gosave(Gobuf*)
// save state in Gobuf; setjmp
TEXT runtime·gosave(SB), 7, $0
	MOVQ	8(SP), AX		// gobuf
 1001744:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	LEAQ	8(SP), BX		// caller's SP
 1001749:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
	MOVQ	BX, gobuf_sp(AX)
 100174e:	48 89 18             	mov    %rbx,(%rax)
	MOVQ	0(SP), BX		// caller's PC
 1001751:	48 8b 1c 24          	mov    (%rsp),%rbx
	MOVQ	BX, gobuf_pc(AX)
 1001755:	48 89 58 08          	mov    %rbx,0x8(%rax)
	get_tls(CX)
	MOVQ	g(CX), BX
 1001759:	64 48 8b 1c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rbx
 1001760:	ff ff 
	MOVQ	BX, gobuf_g(AX)
 1001762:	48 89 58 10          	mov    %rbx,0x10(%rax)
	RET
 1001766:	c3                   	retq   

0000000001001767 <runtime.gogo>:

// void gogo(Gobuf*, uintptr)
// restore state from Gobuf; longjmp
TEXT runtime·gogo(SB), 7, $0
	MOVQ	16(SP), AX		// return 2nd arg
 1001767:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
	MOVQ	8(SP), BX		// gobuf
 100176c:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVQ	gobuf_g(BX), DX
 1001771:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	MOVQ	0(DX), CX		// make sure g != nil
 1001775:	48 8b 0a             	mov    (%rdx),%rcx
	get_tls(CX)
	MOVQ	DX, g(CX)
 1001778:	64 48 89 14 25 f0 ff 	mov    %rdx,%fs:0xfffffffffffffff0
 100177f:	ff ff 
	MOVQ	gobuf_sp(BX), SP	// restore SP
 1001781:	48 8b 23             	mov    (%rbx),%rsp
	MOVQ	gobuf_pc(BX), BX
 1001784:	48 8b 5b 08          	mov    0x8(%rbx),%rbx
	JMP	BX
 1001788:	ff e3                	jmpq   *%rbx

000000000100178a <runtime.gogocall>:

// void gogocall(Gobuf*, void (*fn)(void))
// restore state from Gobuf but then call fn.
// (call fn, returning to state in Gobuf)
TEXT runtime·gogocall(SB), 7, $0
	MOVQ	16(SP), AX		// fn
 100178a:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
	MOVQ	8(SP), BX		// gobuf
 100178f:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVQ	gobuf_g(BX), DX
 1001794:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	get_tls(CX)
	MOVQ	DX, g(CX)
 1001798:	64 48 89 14 25 f0 ff 	mov    %rdx,%fs:0xfffffffffffffff0
 100179f:	ff ff 
	MOVQ	0(DX), CX	// make sure g != nil
 10017a1:	48 8b 0a             	mov    (%rdx),%rcx
	MOVQ	gobuf_sp(BX), SP	// restore SP
 10017a4:	48 8b 23             	mov    (%rbx),%rsp
	MOVQ	gobuf_pc(BX), BX
 10017a7:	48 8b 5b 08          	mov    0x8(%rbx),%rbx
	PUSHQ	BX
 10017ab:	53                   	push   %rbx
	JMP	AX
 10017ac:	ff e0                	jmpq   *%rax

00000000010017ae <runtime.mcall>:
// void mcall(void (*fn)(G*))
// Switch to m->g0's stack, call fn(g).
// Fn must never return.  It should gogo(&g->sched)
// to keep running g.
TEXT runtime·mcall(SB), 7, $0
	MOVQ	fn+0(FP), DI
 10017ae:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	
	get_tls(CX)
	MOVQ	g(CX), AX	// save state in g->gobuf
 10017b3:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10017ba:	ff ff 
	MOVQ	0(SP), BX	// caller's PC
 10017bc:	48 8b 1c 24          	mov    (%rsp),%rbx
	MOVQ	BX, (g_sched+gobuf_pc)(AX)
 10017c0:	48 89 58 28          	mov    %rbx,0x28(%rax)
	LEAQ	8(SP), BX	// caller's SP
 10017c4:	48 8d 5c 24 08       	lea    0x8(%rsp),%rbx
	MOVQ	BX, (g_sched+gobuf_sp)(AX)
 10017c9:	48 89 58 20          	mov    %rbx,0x20(%rax)
	MOVQ	AX, (g_sched+gobuf_g)(AX)
 10017cd:	48 89 40 30          	mov    %rax,0x30(%rax)

	// switch to m->g0 & its stack, call fn
	MOVQ	m(CX), BX
 10017d1:	64 48 8b 1c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbx
 10017d8:	ff ff 
	MOVQ	m_g0(BX), SI
 10017da:	48 8b 33             	mov    (%rbx),%rsi
	CMPQ	SI, AX	// if g == m->g0 call badmcall
 10017dd:	48 39 c6             	cmp    %rax,%rsi
	JNE	2(PC)
 10017e0:	75 05                	jne    10017e7 <runtime.mcall+0x39>
	CALL	runtime·badmcall(SB)
 10017e2:	e8 88 81 00 00       	callq  100996f <runtime.badmcall>
	MOVQ	SI, g(CX)	// g = m->g0
 10017e7:	64 48 89 34 25 f0 ff 	mov    %rsi,%fs:0xfffffffffffffff0
 10017ee:	ff ff 
	MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m->g0->gobuf.sp
 10017f0:	48 8b 66 20          	mov    0x20(%rsi),%rsp
	PUSHQ	AX
 10017f4:	50                   	push   %rax
	CALL	DI
 10017f5:	ff d7                	callq  *%rdi
	POPQ	AX
 10017f7:	58                   	pop    %rax
	CALL	runtime·badmcall2(SB)
 10017f8:	e8 9c 81 00 00       	callq  1009999 <runtime.badmcall2>
	RET
 10017fd:	c3                   	retq   

00000000010017fe <runtime.morestack>:

// Called during function prolog when more stack is needed.
// Caller has already done get_tls(CX); MOVQ m(CX), BX.
TEXT runtime·morestack(SB),7,$0
	// Cannot grow scheduler stack (m->g0).
	MOVQ	m_g0(BX), SI
 10017fe:	48 8b 33             	mov    (%rbx),%rsi
	CMPQ	g(CX), SI
 1001801:	64 48 39 34 25 f0 ff 	cmp    %rsi,%fs:0xfffffffffffffff0
 1001808:	ff ff 
	JNE	2(PC)
 100180a:	75 02                	jne    100180e <runtime.morestack+0x10>
	INT	$3
 100180c:	cd 03                	int    $0x3

	// Called from f.
	// Set m->morebuf to f's caller.
	MOVQ	8(SP), AX	// f's caller's PC
 100180e:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	MOVQ	AX, (m_morebuf+gobuf_pc)(BX)
 1001813:	48 89 43 20          	mov    %rax,0x20(%rbx)
	LEAQ	16(SP), AX	// f's caller's SP
 1001817:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
	MOVQ	AX, (m_morebuf+gobuf_sp)(BX)
 100181c:	48 89 43 18          	mov    %rax,0x18(%rbx)
	MOVQ	AX, m_moreargp(BX)
 1001820:	48 89 43 10          	mov    %rax,0x10(%rbx)
	get_tls(CX)
	MOVQ	g(CX), SI
 1001824:	64 48 8b 34 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rsi
 100182b:	ff ff 
	MOVQ	SI, (m_morebuf+gobuf_g)(BX)
 100182d:	48 89 73 28          	mov    %rsi,0x28(%rbx)

	// Set m->morepc to f's PC.
	MOVQ	0(SP), AX
 1001831:	48 8b 04 24          	mov    (%rsp),%rax
	MOVQ	AX, m_morepc(BX)
 1001835:	48 89 43 08          	mov    %rax,0x8(%rbx)

	// Call newstack on m->g0's stack.
	MOVQ	m_g0(BX), BP
 1001839:	48 8b 2b             	mov    (%rbx),%rbp
	MOVQ	BP, g(CX)
 100183c:	64 48 89 2c 25 f0 ff 	mov    %rbp,%fs:0xfffffffffffffff0
 1001843:	ff ff 
	MOVQ	(g_sched+gobuf_sp)(BP), SP
 1001845:	48 8b 65 20          	mov    0x20(%rbp),%rsp
	CALL	runtime·newstack(SB)
 1001849:	e8 a4 76 00 00       	callq  1008ef2 <runtime.newstack>
	MOVQ	$0, 0x1003	// crash if newstack returns
 100184e:	48 c7 04 25 03 10 00 	movq   $0x0,0x1003
 1001855:	00 00 00 00 00 
	RET
 100185a:	c3                   	retq   

000000000100185b <reflect.call>:
// with the desired args running the desired function.
//
// func call(fn *byte, arg *byte, argsize uint32).
TEXT reflect·call(SB), 7, $0
	get_tls(CX)
	MOVQ	m(CX), BX
 100185b:	64 48 8b 1c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbx
 1001862:	ff ff 

	// Save our caller's state as the PC and SP to
	// restore when returning from f.
	MOVQ	0(SP), AX	// our caller's PC
 1001864:	48 8b 04 24          	mov    (%rsp),%rax
	MOVQ	AX, (m_morebuf+gobuf_pc)(BX)
 1001868:	48 89 43 20          	mov    %rax,0x20(%rbx)
	LEAQ	8(SP), AX	// our caller's SP
 100186c:	48 8d 44 24 08       	lea    0x8(%rsp),%rax
	MOVQ	AX, (m_morebuf+gobuf_sp)(BX)
 1001871:	48 89 43 18          	mov    %rax,0x18(%rbx)
	MOVQ	g(CX), AX
 1001875:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100187c:	ff ff 
	MOVQ	AX, (m_morebuf+gobuf_g)(BX)
 100187e:	48 89 43 28          	mov    %rax,0x28(%rbx)
	// We set f's frame size to 1, as a hint to newstack
	// that this is a call from reflect·call.
	// If it turns out that f needs a larger frame than
	// the default stack, f's usual stack growth prolog will
	// allocate a new segment (and recopy the arguments).
	MOVQ	8(SP), AX	// fn
 1001882:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	MOVQ	16(SP), DX	// arg frame
 1001887:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
	MOVL	24(SP), CX	// arg size
 100188c:	8b 4c 24 18          	mov    0x18(%rsp),%ecx

	MOVQ	AX, m_morepc(BX)	// f's PC
 1001890:	48 89 43 08          	mov    %rax,0x8(%rbx)
	MOVQ	DX, m_moreargp(BX)	// argument frame pointer
 1001894:	48 89 53 10          	mov    %rdx,0x10(%rbx)
	MOVL	CX, m_moreargsize(BX)	// f's argument size
 1001898:	89 4b 34             	mov    %ecx,0x34(%rbx)
	MOVL	$1, m_moreframesize(BX)	// f's frame size
 100189b:	c7 43 30 01 00 00 00 	movl   $0x1,0x30(%rbx)

	// Call newstack on m->g0's stack.
	MOVQ	m_g0(BX), BP
 10018a2:	48 8b 2b             	mov    (%rbx),%rbp
	get_tls(CX)
	MOVQ	BP, g(CX)
 10018a5:	64 48 89 2c 25 f0 ff 	mov    %rbp,%fs:0xfffffffffffffff0
 10018ac:	ff ff 
	MOVQ	(g_sched+gobuf_sp)(BP), SP
 10018ae:	48 8b 65 20          	mov    0x20(%rbp),%rsp
	CALL	runtime·newstack(SB)
 10018b2:	e8 3b 76 00 00       	callq  1008ef2 <runtime.newstack>
	MOVQ	$0, 0x1103	// crash if newstack returns
 10018b7:	48 c7 04 25 03 11 00 	movq   $0x0,0x1103
 10018be:	00 00 00 00 00 
	RET
 10018c3:	c3                   	retq   

00000000010018c4 <runtime.lessstack>:

// Return point when leaving stack.
TEXT runtime·lessstack(SB), 7, $0
	// Save return value in m->cret
	get_tls(CX)
	MOVQ	m(CX), BX
 10018c4:	64 48 8b 1c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbx
 10018cb:	ff ff 
	MOVQ	AX, m_cret(BX)
 10018cd:	48 89 43 38          	mov    %rax,0x38(%rbx)

	// Call oldstack on m->g0's stack.
	MOVQ	m_g0(BX), BP
 10018d1:	48 8b 2b             	mov    (%rbx),%rbp
	MOVQ	BP, g(CX)
 10018d4:	64 48 89 2c 25 f0 ff 	mov    %rbp,%fs:0xfffffffffffffff0
 10018db:	ff ff 
	MOVQ	(g_sched+gobuf_sp)(BP), SP
 10018dd:	48 8b 65 20          	mov    0x20(%rbp),%rsp
	CALL	runtime·oldstack(SB)
 10018e1:	e8 2b 75 00 00       	callq  1008e11 <runtime.oldstack>
	MOVQ	$0, 0x1004	// crash if oldstack returns
 10018e6:	48 c7 04 25 04 10 00 	movq   $0x0,0x1004
 10018ed:	00 00 00 00 00 
	RET
 10018f2:	c3                   	retq   

00000000010018f3 <runtime.morestack00>:

// morestack trampolines
TEXT runtime·morestack00(SB),7,$0
	get_tls(CX)
	MOVQ	m(CX), BX
 10018f3:	64 48 8b 1c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbx
 10018fa:	ff ff 
	MOVQ	$0, AX
 10018fc:	48 31 c0             	xor    %rax,%rax
	MOVQ	AX, m_moreframesize(BX)
 10018ff:	48 89 43 30          	mov    %rax,0x30(%rbx)
	MOVQ	$runtime·morestack(SB), AX
 1001903:	b8 fe 17 00 01       	mov    $0x10017fe,%eax
	JMP	AX
 1001908:	ff e0                	jmpq   *%rax

000000000100190a <runtime.morestack01>:

TEXT runtime·morestack01(SB),7,$0
	get_tls(CX)
	MOVQ	m(CX), BX
 100190a:	64 48 8b 1c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbx
 1001911:	ff ff 
	SHLQ	$32, AX
 1001913:	48 c1 e0 20          	shl    $0x20,%rax
	MOVQ	AX, m_moreframesize(BX)
 1001917:	48 89 43 30          	mov    %rax,0x30(%rbx)
	MOVQ	$runtime·morestack(SB), AX
 100191b:	b8 fe 17 00 01       	mov    $0x10017fe,%eax
	JMP	AX
 1001920:	ff e0                	jmpq   *%rax

0000000001001922 <runtime.morestack10>:

TEXT runtime·morestack10(SB),7,$0
	get_tls(CX)
	MOVQ	m(CX), BX
 1001922:	64 48 8b 1c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbx
 1001929:	ff ff 
	MOVLQZX	AX, AX
 100192b:	8b c0                	mov    %eax,%eax
	MOVQ	AX, m_moreframesize(BX)
 100192d:	48 89 43 30          	mov    %rax,0x30(%rbx)
	MOVQ	$runtime·morestack(SB), AX
 1001931:	b8 fe 17 00 01       	mov    $0x10017fe,%eax
	JMP	AX
 1001936:	ff e0                	jmpq   *%rax

0000000001001938 <runtime.morestack11>:

TEXT runtime·morestack11(SB),7,$0
	get_tls(CX)
	MOVQ	m(CX), BX
 1001938:	64 48 8b 1c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbx
 100193f:	ff ff 
	MOVQ	AX, m_moreframesize(BX)
 1001941:	48 89 43 30          	mov    %rax,0x30(%rbx)
	MOVQ	$runtime·morestack(SB), AX
 1001945:	b8 fe 17 00 01       	mov    $0x10017fe,%eax
	JMP	AX
 100194a:	ff e0                	jmpq   *%rax

000000000100194c <runtime.morestack8>:

// subcases of morestack01
// with const of 8,16,...48
TEXT runtime·morestack8(SB),7,$0
	PUSHQ	$1
 100194c:	6a 01                	pushq  $0x1
	MOVQ	$morestack<>(SB), AX
 100194e:	b8 82 19 00 01       	mov    $0x1001982,%eax
	JMP	AX
 1001953:	ff e0                	jmpq   *%rax

0000000001001955 <runtime.morestack16>:

TEXT runtime·morestack16(SB),7,$0
	PUSHQ	$2
 1001955:	6a 02                	pushq  $0x2
	MOVQ	$morestack<>(SB), AX
 1001957:	b8 82 19 00 01       	mov    $0x1001982,%eax
	JMP	AX
 100195c:	ff e0                	jmpq   *%rax

000000000100195e <runtime.morestack24>:

TEXT runtime·morestack24(SB),7,$0
	PUSHQ	$3
 100195e:	6a 03                	pushq  $0x3
	MOVQ	$morestack<>(SB), AX
 1001960:	b8 82 19 00 01       	mov    $0x1001982,%eax
	JMP	AX
 1001965:	ff e0                	jmpq   *%rax

0000000001001967 <runtime.morestack32>:

TEXT runtime·morestack32(SB),7,$0
	PUSHQ	$4
 1001967:	6a 04                	pushq  $0x4
	MOVQ	$morestack<>(SB), AX
 1001969:	b8 82 19 00 01       	mov    $0x1001982,%eax
	JMP	AX
 100196e:	ff e0                	jmpq   *%rax

0000000001001970 <runtime.morestack40>:

TEXT runtime·morestack40(SB),7,$0
	PUSHQ	$5
 1001970:	6a 05                	pushq  $0x5
	MOVQ	$morestack<>(SB), AX
 1001972:	b8 82 19 00 01       	mov    $0x1001982,%eax
	JMP	AX
 1001977:	ff e0                	jmpq   *%rax

0000000001001979 <runtime.morestack48>:

TEXT runtime·morestack48(SB),7,$0
	PUSHQ	$6
 1001979:	6a 06                	pushq  $0x6
	MOVQ	$morestack<>(SB), AX
 100197b:	b8 82 19 00 01       	mov    $0x1001982,%eax
	JMP	AX
 1001980:	ff e0                	jmpq   *%rax

0000000001001982 <morestack>:

TEXT morestack<>(SB),7,$0
	get_tls(CX)
	MOVQ	m(CX), BX
 1001982:	64 48 8b 1c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbx
 1001989:	ff ff 
	POPQ	AX
 100198b:	58                   	pop    %rax
	SHLQ	$35, AX
 100198c:	48 c1 e0 23          	shl    $0x23,%rax
	MOVQ	AX, m_moreframesize(BX)
 1001990:	48 89 43 30          	mov    %rax,0x30(%rbx)
	MOVQ	$runtime·morestack(SB), AX
 1001994:	b8 fe 17 00 01       	mov    $0x10017fe,%eax
	JMP	AX
 1001999:	ff e0                	jmpq   *%rax

000000000100199b <runtime.cas>:
//		*val = new;
//		return 1;
//	} else
//		return 0;
TEXT runtime·cas(SB), 7, $0
	MOVQ	8(SP), BX
 100199b:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVL	16(SP), AX
 10019a0:	8b 44 24 10          	mov    0x10(%rsp),%eax
	MOVL	20(SP), CX
 10019a4:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
	LOCK
 10019a8:	f0 0f b1 0b          	lock cmpxchg %ecx,(%rbx)
	CMPXCHGL	CX, 0(BX)
	JZ 3(PC)
 10019ac:	74 03                	je     10019b1 <runtime.cas+0x16>
	MOVL	$0, AX
 10019ae:	31 c0                	xor    %eax,%eax
	RET
 10019b0:	c3                   	retq   
	MOVL	$1, AX
 10019b1:	b8 01 00 00 00       	mov    $0x1,%eax
	RET
 10019b6:	c3                   	retq   

00000000010019b7 <runtime.casp>:
//		*val = new;
//		return 1;
//	} else
//		return 0;
TEXT runtime·casp(SB), 7, $0
	MOVQ	8(SP), BX
 10019b7:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVQ	16(SP), AX
 10019bc:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
	MOVQ	24(SP), CX
 10019c1:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
	LOCK
 10019c6:	f0 48 0f b1 0b       	lock cmpxchg %rcx,(%rbx)
	CMPXCHGQ	CX, 0(BX)
	JZ 3(PC)
 10019cb:	74 03                	je     10019d0 <runtime.casp+0x19>
	MOVL	$0, AX
 10019cd:	31 c0                	xor    %eax,%eax
	RET
 10019cf:	c3                   	retq   
	MOVL	$1, AX
 10019d0:	b8 01 00 00 00       	mov    $0x1,%eax
	RET
 10019d5:	c3                   	retq   

00000000010019d6 <runtime.xadd>:
// uint32 xadd(uint32 volatile *val, int32 delta)
// Atomically:
//	*val += delta;
//	return *val;
TEXT runtime·xadd(SB), 7, $0
	MOVQ	8(SP), BX
 10019d6:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVL	16(SP), AX
 10019db:	8b 44 24 10          	mov    0x10(%rsp),%eax
	MOVL	AX, CX
 10019df:	89 c1                	mov    %eax,%ecx
	LOCK
 10019e1:	f0 0f c1 03          	lock xadd %eax,(%rbx)
	XADDL	AX, 0(BX)
	ADDL	CX, AX
 10019e5:	01 c8                	add    %ecx,%eax
	RET
 10019e7:	c3                   	retq   

00000000010019e8 <runtime.xchg>:

TEXT runtime·xchg(SB), 7, $0
	MOVQ	8(SP), BX
 10019e8:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVL	16(SP), AX
 10019ed:	8b 44 24 10          	mov    0x10(%rsp),%eax
	XCHGL	AX, 0(BX)
 10019f1:	87 03                	xchg   %eax,(%rbx)
	RET
 10019f3:	c3                   	retq   

00000000010019f4 <runtime.procyield>:

TEXT runtime·procyield(SB),7,$0
	MOVL	8(SP), AX
 10019f4:	8b 44 24 08          	mov    0x8(%rsp),%eax
again:
	PAUSE
 10019f8:	f3 90                	pause  
	SUBL	$1, AX
 10019fa:	83 e8 01             	sub    $0x1,%eax
	JNZ	again
 10019fd:	75 f9                	jne    10019f8 <runtime.procyield+0x4>
	RET
 10019ff:	c3                   	retq   

0000000001001a00 <runtime.atomicstorep>:

TEXT runtime·atomicstorep(SB), 7, $0
	MOVQ	8(SP), BX
 1001a00:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVQ	16(SP), AX
 1001a05:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
	XCHGQ	AX, 0(BX)
 1001a0a:	48 87 03             	xchg   %rax,(%rbx)
	RET
 1001a0d:	c3                   	retq   

0000000001001a0e <runtime.atomicstore>:

TEXT runtime·atomicstore(SB), 7, $0
	MOVQ	8(SP), BX
 1001a0e:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVL	16(SP), AX
 1001a13:	8b 44 24 10          	mov    0x10(%rsp),%eax
	XCHGL	AX, 0(BX)
 1001a17:	87 03                	xchg   %eax,(%rbx)
	RET
 1001a19:	c3                   	retq   

0000000001001a1a <return>:
// Dummy function to use in saved gobuf.PC,
// to match SP pointing at a return address.
// The gobuf.PC is unused by the contortions here
// but setting it to return will make the traceback code work.
TEXT return<>(SB),7,$0
	RET
 1001a1a:	c3                   	retq   

0000000001001a1b <runtime.asmcgocall>:
// asmcgocall(void(*fn)(void*), void *arg)
// Call fn(arg) on the scheduler stack,
// aligned appropriately for the gcc ABI.
// See cgocall.c for more details.
TEXT runtime·asmcgocall(SB),7,$0
	MOVQ	fn+0(FP), AX
 1001a1b:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	MOVQ	arg+8(FP), BX
 1001a20:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
	MOVQ	SP, DX
 1001a25:	48 89 e2             	mov    %rsp,%rdx

	// Figure out if we need to switch to m->g0 stack.
	// We get called to create new OS threads too, and those
	// come in on the m->g0 stack already.
	get_tls(CX)
	MOVQ	m(CX), BP
 1001a28:	64 48 8b 2c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbp
 1001a2f:	ff ff 
	MOVQ	m_g0(BP), SI
 1001a31:	48 8b 75 00          	mov    0x0(%rbp),%rsi
	MOVQ	g(CX), DI
 1001a35:	64 48 8b 3c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rdi
 1001a3c:	ff ff 
	CMPQ	SI, DI
 1001a3e:	48 39 fe             	cmp    %rdi,%rsi
	JEQ	6(PC)
 1001a41:	74 1d                	je     1001a60 <runtime.asmcgocall+0x45>
	MOVQ	SP, (g_sched+gobuf_sp)(DI)
 1001a43:	48 89 67 20          	mov    %rsp,0x20(%rdi)
	MOVQ	$return<>(SB), (g_sched+gobuf_pc)(DI)
 1001a47:	48 c7 47 28 1a 1a 00 	movq   $0x1001a1a,0x28(%rdi)
 1001a4e:	01 
	MOVQ	DI, (g_sched+gobuf_g)(DI)
 1001a4f:	48 89 7f 30          	mov    %rdi,0x30(%rdi)
	MOVQ	SI, g(CX)
 1001a53:	64 48 89 34 25 f0 ff 	mov    %rsi,%fs:0xfffffffffffffff0
 1001a5a:	ff ff 
	MOVQ	(g_sched+gobuf_sp)(SI), SP
 1001a5c:	48 8b 66 20          	mov    0x20(%rsi),%rsp

	// Now on a scheduling stack (a pthread-created stack).
	SUBQ	$32, SP
 1001a60:	48 83 ec 20          	sub    $0x20,%rsp
	ANDQ	$~15, SP	// alignment for gcc ABI
 1001a64:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
	MOVQ	DI, 16(SP)	// save g
 1001a68:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
	MOVQ	DX, 8(SP)	// save SP
 1001a6d:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
	MOVQ	BX, DI		// DI = first argument in AMD64 ABI
 1001a72:	48 89 df             	mov    %rbx,%rdi
	MOVQ	BX, CX		// CX = first argument in Win64
 1001a75:	48 89 d9             	mov    %rbx,%rcx
	CALL	AX
 1001a78:	ff d0                	callq  *%rax

	// Restore registers, g, stack pointer.
	get_tls(CX)
	MOVQ	16(SP), DI
 1001a7a:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
	MOVQ	DI, g(CX)
 1001a7f:	64 48 89 3c 25 f0 ff 	mov    %rdi,%fs:0xfffffffffffffff0
 1001a86:	ff ff 
	MOVQ	8(SP), SP
 1001a88:	48 8b 64 24 08       	mov    0x8(%rsp),%rsp
	RET
 1001a8d:	c3                   	retq   

0000000001001a8e <runtime.stackcheck>:
	RET

// check that SP is in range [g->stackbase, g->stackguard)
TEXT runtime·stackcheck(SB), 7, $0
	get_tls(CX)
	MOVQ	g(CX), AX
 1001a8e:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1001a95:	ff ff 
	CMPQ	g_stackbase(AX), SP
 1001a97:	48 39 60 08          	cmp    %rsp,0x8(%rax)
	JHI	2(PC)
 1001a9b:	77 02                	ja     1001a9f <runtime.stackcheck+0x11>
	INT	$3
 1001a9d:	cd 03                	int    $0x3
	CMPQ	SP, g_stackguard(AX)
 1001a9f:	48 3b 20             	cmp    (%rax),%rsp
	JHI	2(PC)
 1001aa2:	77 02                	ja     1001aa6 <runtime.stackcheck+0x18>
	INT	$3
 1001aa4:	cd 03                	int    $0x3
	RET
 1001aa6:	c3                   	retq   

0000000001001aa7 <runtime.memclr>:

TEXT runtime·memclr(SB),7,$0
	MOVQ	8(SP), DI		// arg 1 addr
 1001aa7:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	MOVQ	16(SP), CX		// arg 2 count
 1001aac:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
	MOVQ	CX, BX
 1001ab1:	48 89 cb             	mov    %rcx,%rbx
	ANDQ	$7, BX
 1001ab4:	48 83 e3 07          	and    $0x7,%rbx
	SHRQ	$3, CX
 1001ab8:	48 c1 e9 03          	shr    $0x3,%rcx
	MOVQ	$0, AX
 1001abc:	48 31 c0             	xor    %rax,%rax
	CLD
 1001abf:	fc                   	cld    
	REP
 1001ac0:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	STOSQ
	MOVQ	BX, CX
 1001ac3:	48 89 d9             	mov    %rbx,%rcx
	REP
 1001ac6:	f3 aa                	rep stos %al,%es:(%rdi)
	STOSB
	RET
 1001ac8:	c3                   	retq   

0000000001001ac9 <runtime.getcallerpc>:

TEXT runtime·getcallerpc(SB),7,$0
	MOVQ	x+0(FP),AX		// addr of first arg
 1001ac9:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	MOVQ	-8(AX),AX		// get calling pc
 1001ace:	48 8b 40 f8          	mov    -0x8(%rax),%rax
	RET
 1001ad2:	c3                   	retq   

0000000001001ad3 <runtime.getcallersp>:
	MOVQ	x+8(FP), BX
	MOVQ	BX, -8(AX)		// set calling pc
	RET

TEXT runtime·getcallersp(SB),7,$0
	MOVQ	sp+0(FP), AX
 1001ad3:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
 1001ad8:	c3                   	retq   

0000000001001ad9 <runtime.atomicload>:

#pragma textflag 7
uint32
runtime·atomicload(uint32 volatile* addr)
{
	return *addr;
 1001ad9:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
 1001ade:	8b 00                	mov    (%rax),%eax
 1001ae0:	c3                   	retq   

0000000001001ae1 <runtime.atomicloadp>:
 1001ae1:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
 1001ae6:	48 8b 00             	mov    (%rax),%rax
 1001ae9:	c3                   	retq   

0000000001001aea <runtime.float64tobits>:
	u.f = f;
	return u.i;
}

uint64
runtime·float64tobits(float64 f)
 1001aea:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001af1:	ff ff 
 1001af3:	48 3b 21             	cmp    (%rcx),%rsp
 1001af6:	77 05                	ja     1001afd <runtime.float64tobits+0x13>
 1001af8:	e8 4f fe ff ff       	callq  100194c <runtime.morestack8>
 1001afd:	48 83 ec 10          	sub    $0x10,%rsp
	// not valid, and gcc miscompiles it.  Use a union instead.
	union {
		float64 f;
		uint64 i;
	} u;
	u.f = f;
 1001b01:	f2 0f 10 44 24 18    	movsd  0x18(%rsp),%xmm0
 1001b07:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
	return u.i;
 1001b0d:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
 1001b12:	48 83 c4 10          	add    $0x10,%rsp
 1001b16:	c3                   	retq   

0000000001001b17 <runtime.isInf>:
	u.i = i;
	return u.f;
}

bool
runtime·isInf(float64 f, int32 sign)
 1001b17:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001b1e:	ff ff 
 1001b20:	48 3b 21             	cmp    (%rcx),%rsp
 1001b23:	77 05                	ja     1001b2a <runtime.isInf+0x13>
 1001b25:	e8 2b fe ff ff       	callq  1001955 <runtime.morestack16>
 1001b2a:	48 83 ec 20          	sub    $0x20,%rsp
{
	uint64 x;

	x = runtime·float64tobits(f);
 1001b2e:	f2 0f 10 44 24 28    	movsd  0x28(%rsp),%xmm0
 1001b34:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 1001b39:	e8 ac ff ff ff       	callq  1001aea <runtime.float64tobits>
 1001b3e:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
 1001b42:	48 8b 2c 25 30 30 02 	mov    0x1023030,%rbp
 1001b49:	01 
 1001b4a:	48 8b 1c 25 38 30 02 	mov    0x1023038,%rbx
 1001b51:	01 
	if(sign == 0)
 1001b52:	83 f9 00             	cmp    $0x0,%ecx
 1001b55:	75 18                	jne    1001b6f <runtime.isInf+0x58>
		return x == uvinf || x == uvneginf;
 1001b57:	48 39 e8             	cmp    %rbp,%rax
 1001b5a:	74 0c                	je     1001b68 <runtime.isInf+0x51>
 1001b5c:	48 39 d8             	cmp    %rbx,%rax
 1001b5f:	74 07                	je     1001b68 <runtime.isInf+0x51>
 1001b61:	31 c0                	xor    %eax,%eax
 1001b63:	48 83 c4 20          	add    $0x20,%rsp
 1001b67:	c3                   	retq   
 1001b68:	b8 01 00 00 00       	mov    $0x1,%eax
 1001b6d:	eb f4                	jmp    1001b63 <runtime.isInf+0x4c>
	if(sign > 0)
 1001b6f:	83 f9 00             	cmp    $0x0,%ecx
 1001b72:	7e 13                	jle    1001b87 <runtime.isInf+0x70>
		return x == uvinf;
 1001b74:	48 39 e8             	cmp    %rbp,%rax
 1001b77:	75 0a                	jne    1001b83 <runtime.isInf+0x6c>
 1001b79:	b8 01 00 00 00       	mov    $0x1,%eax
 1001b7e:	48 83 c4 20          	add    $0x20,%rsp
 1001b82:	c3                   	retq   
 1001b83:	31 c0                	xor    %eax,%eax
 1001b85:	eb f7                	jmp    1001b7e <runtime.isInf+0x67>
	return x == uvneginf;
 1001b87:	48 39 d8             	cmp    %rbx,%rax
 1001b8a:	75 0a                	jne    1001b96 <runtime.isInf+0x7f>
 1001b8c:	b8 01 00 00 00       	mov    $0x1,%eax
 1001b91:	48 83 c4 20          	add    $0x20,%rsp
 1001b95:	c3                   	retq   
 1001b96:	31 c0                	xor    %eax,%eax
 1001b98:	eb f7                	jmp    1001b91 <runtime.isInf+0x7a>

0000000001001b9a <runtime.isNaN>:
{
	return runtime·float64frombits(uvnan);
}

bool
runtime·isNaN(float64 f)
 1001b9a:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001ba1:	ff ff 
 1001ba3:	48 3b 21             	cmp    (%rcx),%rsp
 1001ba6:	77 05                	ja     1001bad <runtime.isNaN+0x13>
 1001ba8:	e8 9f fd ff ff       	callq  100194c <runtime.morestack8>
 1001bad:	48 83 ec 28          	sub    $0x28,%rsp
{
	uint64 x;

	x = runtime·float64tobits(f);
 1001bb1:	f2 0f 10 44 24 30    	movsd  0x30(%rsp),%xmm0
 1001bb7:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 1001bbc:	e8 29 ff ff ff       	callq  1001aea <runtime.float64tobits>
 1001bc1:	48 89 c1             	mov    %rax,%rcx
 1001bc4:	48 c1 e9 34          	shr    $0x34,%rcx
 1001bc8:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
 1001bce:	81 f9 ff 07 00 00    	cmp    $0x7ff,%ecx
 1001bd4:	75 1d                	jne    1001bf3 <runtime.isNaN+0x59>
 1001bd6:	f2 0f 10 44 24 30    	movsd  0x30(%rsp),%xmm0
 1001bdc:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 1001be1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
 1001be8:	00 
 1001be9:	e8 29 ff ff ff       	callq  1001b17 <runtime.isInf>
 1001bee:	80 f8 00             	cmp    $0x0,%al
 1001bf1:	74 07                	je     1001bfa <runtime.isNaN+0x60>
 1001bf3:	31 c0                	xor    %eax,%eax
 1001bf5:	48 83 c4 28          	add    $0x28,%rsp
 1001bf9:	c3                   	retq   
 1001bfa:	b8 01 00 00 00       	mov    $0x1,%eax
 1001bff:	eb f4                	jmp    1001bf5 <runtime.isNaN+0x5b>

0000000001001c01 <runtime.printiface>:
	// not a valid empty interface.
	reflectFlags = 3,
};

void
runtime·printiface(Iface i)
 1001c01:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001c08:	ff ff 
 1001c0a:	48 3b 21             	cmp    (%rcx),%rsp
 1001c0d:	77 05                	ja     1001c14 <runtime.printiface+0x13>
 1001c0f:	e8 41 fd ff ff       	callq  1001955 <runtime.morestack16>
 1001c14:	48 83 ec 20          	sub    $0x20,%rsp
{
	runtime·printf("(%p,%p)", i.tab, i.data);
 1001c18:	b8 c8 38 02 01       	mov    $0x10238c8,%eax
 1001c1d:	48 89 04 24          	mov    %rax,(%rsp)
 1001c21:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1001c26:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1001c2b:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1001c30:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1001c35:	e8 04 57 00 00       	callq  100733e <runtime.printf>
 1001c3a:	48 83 c4 20          	add    $0x20,%rsp
 1001c3e:	c3                   	retq   

0000000001001c3f <runtime.printeface>:
}

void
runtime·printeface(Eface e)
 1001c3f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001c46:	ff ff 
 1001c48:	48 3b 21             	cmp    (%rcx),%rsp
 1001c4b:	77 05                	ja     1001c52 <runtime.printeface+0x13>
 1001c4d:	e8 03 fd ff ff       	callq  1001955 <runtime.morestack16>
 1001c52:	48 83 ec 20          	sub    $0x20,%rsp
{
	runtime·printf("(%p,%p)", e.type, e.data);
 1001c56:	b8 d0 38 02 01       	mov    $0x10238d0,%eax
 1001c5b:	48 89 04 24          	mov    %rax,(%rsp)
 1001c5f:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1001c64:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1001c69:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1001c6e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1001c73:	e8 c6 56 00 00       	callq  100733e <runtime.printf>
 1001c78:	48 83 c4 20          	add    $0x20,%rsp
 1001c7c:	c3                   	retq   

0000000001001c7d <itab>:

static	Itab*	hash[1009];
static	Lock	ifacelock;

static Itab*
itab(InterfaceType *inter, Type *type, int32 canfail)
 1001c7d:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1001c84:	ff ff 
 1001c86:	48 8d 44 24 c8       	lea    -0x38(%rsp),%rax
 1001c8b:	48 3b 01             	cmp    (%rcx),%rax
 1001c8e:	77 05                	ja     1001c95 <itab+0x18>
 1001c90:	e8 c9 fc ff ff       	callq  100195e <runtime.morestack24>
 1001c95:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
 1001c9c:	4c 8b a4 24 c8 00 00 	mov    0xc8(%rsp),%r12
 1001ca3:	00 
 1001ca4:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
 1001cab:	00 
	Itab *m;
	UncommonType *x;
	Type *itype;
	Eface err;

	if(inter->mhdr.len == 0)
 1001cac:	8b 47 40             	mov    0x40(%rdi),%eax
 1001caf:	83 f8 00             	cmp    $0x0,%eax
 1001cb2:	75 1e                	jne    1001cd2 <itab+0x55>
		runtime·throw("internal error - misuse of itab");
 1001cb4:	b8 d8 38 02 01       	mov    $0x10238d8,%eax
 1001cb9:	48 89 04 24          	mov    %rax,(%rsp)
 1001cbd:	e8 77 80 00 00       	callq  1009d39 <runtime.throw>
 1001cc2:	4c 8b a4 24 c8 00 00 	mov    0xc8(%rsp),%r12
 1001cc9:	00 
 1001cca:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
 1001cd1:	00 

	locked = 0;
 1001cd2:	c7 84 24 b4 00 00 00 	movl   $0x0,0xb4(%rsp)
 1001cd9:	00 00 00 00 

	// easy case
	x = type->x;
 1001cdd:	49 8b 44 24 28       	mov    0x28(%r12),%rax
	if(x == nil) {
 1001ce2:	48 83 f8 00          	cmp    $0x0,%rax
 1001ce6:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
 1001ceb:	0f 85 96 00 00 00    	jne    1001d87 <itab+0x10a>
		if(canfail)
 1001cf1:	83 bc 24 d0 00 00 00 	cmpl   $0x0,0xd0(%rsp)
 1001cf8:	00 
 1001cf9:	74 0b                	je     1001d06 <itab+0x89>
			return nil;
 1001cfb:	48 31 c0             	xor    %rax,%rax
 1001cfe:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
 1001d05:	c3                   	retq   
		iname = inter->m[0].name;
 1001d06:	48 8b 4f 48          	mov    0x48(%rdi),%rcx
		for(;; t++) {
			if(t >= et) {
				if(!canfail) {
				throw:
					// didn't find method
					runtime·newTypeAssertionError(nil, type, inter,
 1001d0a:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
 1001d11:	00 
 1001d12:	4c 89 64 24 08       	mov    %r12,0x8(%rsp)
 1001d17:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
 1001d1c:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
 1001d23:	00 00 
 1001d25:	49 8b 44 24 20       	mov    0x20(%r12),%rax
 1001d2a:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1001d2f:	48 8b 47 20          	mov    0x20(%rdi),%rax
 1001d33:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 1001d38:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
 1001d3d:	48 8d 44 24 50       	lea    0x50(%rsp),%rax
 1001d42:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
 1001d47:	e8 90 f1 ff ff       	callq  1000edc <runtime.newTypeAssertionError>
						nil, type->string, inter->string,
						iname, &err);
					if(locked)
 1001d4c:	83 bc 24 b4 00 00 00 	cmpl   $0x0,0xb4(%rsp)
 1001d53:	00 
 1001d54:	74 0e                	je     1001d64 <itab+0xe7>
						runtime·unlock(&ifacelock);
 1001d56:	b8 90 4e 02 01       	mov    $0x1024e90,%eax
 1001d5b:	48 89 04 24          	mov    %rax,(%rsp)
 1001d5f:	e8 1e b1 00 00       	callq  100ce82 <runtime.unlock>
					runtime·panic(err);
 1001d64:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1001d69:	48 89 04 24          	mov    %rax,(%rsp)
 1001d6d:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 1001d72:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1001d77:	e8 20 79 00 00       	callq  100969c <runtime.panic>
					return nil;	// not reached
 1001d7c:	48 31 c0             	xor    %rax,%rax
 1001d7f:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
 1001d86:	c3                   	retq   
		iname = inter->m[0].name;
		goto throw;
	}

	// compiler has provided some good hash codes for us.
	h = inter->hash;
 1001d87:	8b 57 18             	mov    0x18(%rdi),%edx
	h += 17 * type->hash;
 1001d8a:	41 8b 44 24 18       	mov    0x18(%r12),%eax
 1001d8f:	89 c1                	mov    %eax,%ecx
 1001d91:	c1 e1 04             	shl    $0x4,%ecx
 1001d94:	01 c1                	add    %eax,%ecx
 1001d96:	01 ca                	add    %ecx,%edx
	// TODO(rsc): h += 23 * x->mhash ?
	h %= nelem(hash);
 1001d98:	8b c2                	mov    %edx,%eax
 1001d9a:	31 d2                	xor    %edx,%edx
 1001d9c:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
 1001da1:	f7 f1                	div    %ecx
 1001da3:	89 94 24 8c 00 00 00 	mov    %edx,0x8c(%rsp)

	// look twice - once without lock, once with.
	// common case will be no lock contention.
	for(locked=0; locked<2; locked++) {
 1001daa:	45 31 d2             	xor    %r10d,%r10d
 1001dad:	41 83 fa 02          	cmp    $0x2,%r10d
 1001db1:	44 89 94 24 b4 00 00 	mov    %r10d,0xb4(%rsp)
 1001db8:	00 
 1001db9:	7d 7d                	jge    1001e38 <itab+0x1bb>
		if(locked)
 1001dbb:	41 83 fa 00          	cmp    $0x0,%r10d
 1001dbf:	74 0e                	je     1001dcf <itab+0x152>
			runtime·lock(&ifacelock);
 1001dc1:	b8 90 4e 02 01       	mov    $0x1024e90,%eax
 1001dc6:	48 89 04 24          	mov    %rax,(%rsp)
 1001dca:	e8 61 b0 00 00       	callq  100ce30 <runtime.lock>
		for(m=runtime·atomicloadp(&hash[h]); m!=nil; m=m->link) {
 1001dcf:	8b 94 24 8c 00 00 00 	mov    0x8c(%rsp),%edx
 1001dd6:	48 8d 0c d5 78 83 02 	lea    0x1028378(,%rdx,8),%rcx
 1001ddd:	01 
 1001dde:	48 89 0c 24          	mov    %rcx,(%rsp)
 1001de2:	e8 fa fc ff ff       	callq  1001ae1 <runtime.atomicloadp>
 1001de7:	4c 8b a4 24 c8 00 00 	mov    0xc8(%rsp),%r12
 1001dee:	00 
 1001def:	44 8b 94 24 b4 00 00 	mov    0xb4(%rsp),%r10d
 1001df6:	00 
 1001df7:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
 1001dfe:	00 
 1001dff:	48 89 c3             	mov    %rax,%rbx
 1001e02:	48 83 fb 00          	cmp    $0x0,%rbx
 1001e06:	74 1f                	je     1001e27 <itab+0x1aa>
			if(m->inter == inter && m->type == type) {
 1001e08:	48 8b 03             	mov    (%rbx),%rax
 1001e0b:	48 39 f8             	cmp    %rdi,%rax
 1001e0e:	75 0d                	jne    1001e1d <itab+0x1a0>
 1001e10:	48 8b 43 08          	mov    0x8(%rbx),%rax
 1001e14:	4c 39 e0             	cmp    %r12,%rax
 1001e17:	0f 84 99 01 00 00    	je     1001fb6 <itab+0x339>
	// look twice - once without lock, once with.
	// common case will be no lock contention.
	for(locked=0; locked<2; locked++) {
		if(locked)
			runtime·lock(&ifacelock);
		for(m=runtime·atomicloadp(&hash[h]); m!=nil; m=m->link) {
 1001e1d:	48 8b 5b 10          	mov    0x10(%rbx),%rbx
 1001e21:	48 83 fb 00          	cmp    $0x0,%rbx
 1001e25:	75 e1                	jne    1001e08 <itab+0x18b>
	// TODO(rsc): h += 23 * x->mhash ?
	h %= nelem(hash);

	// look twice - once without lock, once with.
	// common case will be no lock contention.
	for(locked=0; locked<2; locked++) {
 1001e27:	41 ff c2             	inc    %r10d
 1001e2a:	41 83 fa 02          	cmp    $0x2,%r10d
 1001e2e:	44 89 94 24 b4 00 00 	mov    %r10d,0xb4(%rsp)
 1001e35:	00 
 1001e36:	7c 83                	jl     1001dbb <itab+0x13e>
				return m;
			}
		}
	}

	ni = inter->mhdr.len;
 1001e38:	8b 4f 40             	mov    0x40(%rdi),%ecx
	m = runtime·malloc(sizeof(*m) + ni*sizeof m->fun[0]);
 1001e3b:	c1 e1 03             	shl    $0x3,%ecx
 1001e3e:	83 c1 20             	add    $0x20,%ecx
 1001e41:	48 63 c9             	movslq %ecx,%rcx
 1001e44:	48 89 0c 24          	mov    %rcx,(%rsp)
 1001e48:	e8 3e 0c 00 00       	callq  1002a8b <runtime.malloc>
 1001e4d:	4c 8b a4 24 c8 00 00 	mov    0xc8(%rsp),%r12
 1001e54:	00 
 1001e55:	44 8b 94 24 b4 00 00 	mov    0xb4(%rsp),%r10d
 1001e5c:	00 
 1001e5d:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
 1001e64:	00 
 1001e65:	48 89 c3             	mov    %rax,%rbx
	m->inter = inter;
 1001e68:	48 89 38             	mov    %rdi,(%rax)
	m->type = type;
 1001e6b:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
 1001e70:	4c 89 60 08          	mov    %r12,0x8(%rax)
search:
	// both inter and type have method sorted by name,
	// and interface names are unique,
	// so can iterate over both in lock step;
	// the loop is O(ni+nt) not O(ni*nt).
	i = inter->m;
 1001e74:	48 89 fe             	mov    %rdi,%rsi
 1001e77:	48 83 c6 48          	add    $0x48,%rsi
	ei = i + inter->mhdr.len;
 1001e7b:	8b 4f 40             	mov    0x40(%rdi),%ecx
 1001e7e:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 1001e82:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
 1001e86:	49 89 c3             	mov    %rax,%r11
	t = x->m;
 1001e89:	48 8b 6c 24 68       	mov    0x68(%rsp),%rbp
 1001e8e:	48 83 c5 20          	add    $0x20,%rbp
	et = t + x->mhdr.len;
 1001e92:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
 1001e97:	8b 49 18             	mov    0x18(%rcx),%ecx
 1001e9a:	48 6b c9 30          	imul   $0x30,%rcx,%rcx
 1001e9e:	48 89 ea             	mov    %rbp,%rdx
 1001ea1:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1001ea5:	49 89 c1             	mov    %rax,%r9
	for(; i < ei; i++) {
 1001ea8:	4c 39 de             	cmp    %r11,%rsi
 1001eab:	73 29                	jae    1001ed6 <itab+0x259>
		itype = i->type;
 1001ead:	4c 8b 46 10          	mov    0x10(%rsi),%r8
		iname = i->name;
 1001eb1:	48 8b 0e             	mov    (%rsi),%rcx
		ipkgPath = i->pkgPath;
 1001eb4:	48 8b 56 08          	mov    0x8(%rsi),%rdx
		for(;; t++) {
			if(t >= et) {
 1001eb8:	4c 39 cd             	cmp    %r9,%rbp
 1001ebb:	0f 82 8f 00 00 00    	jb     1001f50 <itab+0x2d3>
				if(!canfail) {
 1001ec1:	83 bc 24 d0 00 00 00 	cmpl   $0x0,0xd0(%rsp)
 1001ec8:	00 
 1001ec9:	0f 84 3b fe ff ff    	je     1001d0a <itab+0x8d>
					if(locked)
						runtime·unlock(&ifacelock);
					runtime·panic(err);
					return nil;	// not reached
				}
				m->bad = 1;
 1001ecf:	c7 43 18 01 00 00 00 	movl   $0x1,0x18(%rbx)
		if(m)
			m->fun[i - inter->m] = t->ifn;
	}

out:
	if(!locked)
 1001ed6:	41 83 fa 00          	cmp    $0x0,%r10d
 1001eda:	75 13                	jne    1001eef <itab+0x272>
		runtime·panicstring("invalid itab locking");
 1001edc:	b8 f8 38 02 01       	mov    $0x10238f8,%eax
 1001ee1:	48 89 04 24          	mov    %rax,(%rsp)
 1001ee5:	e8 ac 7e 00 00       	callq  1009d96 <runtime.panicstring>
 1001eea:	48 8b 5c 24 70       	mov    0x70(%rsp),%rbx
	m->link = hash[h];
 1001eef:	8b 94 24 8c 00 00 00 	mov    0x8c(%rsp),%edx
 1001ef6:	48 8b 0c d5 78 83 02 	mov    0x1028378(,%rdx,8),%rcx
 1001efd:	01 
 1001efe:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
	runtime·atomicstorep(&hash[h], m);
 1001f02:	8b 8c 24 8c 00 00 00 	mov    0x8c(%rsp),%ecx
 1001f09:	48 8d 04 cd 78 83 02 	lea    0x1028378(,%rcx,8),%rax
 1001f10:	01 
 1001f11:	48 89 04 24          	mov    %rax,(%rsp)
 1001f15:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 1001f1a:	e8 e1 fa ff ff       	callq  1001a00 <runtime.atomicstorep>
	runtime·unlock(&ifacelock);
 1001f1f:	b8 90 4e 02 01       	mov    $0x1024e90,%eax
 1001f24:	48 89 04 24          	mov    %rax,(%rsp)
 1001f28:	e8 55 af 00 00       	callq  100ce82 <runtime.unlock>
 1001f2d:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
	if(m->bad)
 1001f32:	8b 41 18             	mov    0x18(%rcx),%eax
 1001f35:	83 f8 00             	cmp    $0x0,%eax
 1001f38:	74 0b                	je     1001f45 <itab+0x2c8>
		return nil;
 1001f3a:	48 31 c0             	xor    %rax,%rax
 1001f3d:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
 1001f44:	c3                   	retq   
	return m;
 1001f45:	48 89 c8             	mov    %rcx,%rax
 1001f48:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
 1001f4f:	c3                   	retq   
					return nil;	// not reached
				}
				m->bad = 1;
				goto out;
			}
			if(t->mtyp == itype && t->name == iname && t->pkgPath == ipkgPath)
 1001f50:	48 8b 45 10          	mov    0x10(%rbp),%rax
 1001f54:	4c 39 c0             	cmp    %r8,%rax
 1001f57:	75 09                	jne    1001f62 <itab+0x2e5>
 1001f59:	48 8b 45 00          	mov    0x0(%rbp),%rax
 1001f5d:	48 39 c8             	cmp    %rcx,%rax
 1001f60:	74 09                	je     1001f6b <itab+0x2ee>
	et = t + x->mhdr.len;
	for(; i < ei; i++) {
		itype = i->type;
		iname = i->name;
		ipkgPath = i->pkgPath;
		for(;; t++) {
 1001f62:	48 83 c5 30          	add    $0x30,%rbp
			if(t >= et) {
 1001f66:	e9 4d ff ff ff       	jmpq   1001eb8 <itab+0x23b>
					return nil;	// not reached
				}
				m->bad = 1;
				goto out;
			}
			if(t->mtyp == itype && t->name == iname && t->pkgPath == ipkgPath)
 1001f6b:	48 8b 45 08          	mov    0x8(%rbp),%rax
 1001f6f:	48 39 d0             	cmp    %rdx,%rax
 1001f72:	75 ee                	jne    1001f62 <itab+0x2e5>
				break;
		}
		if(m)
 1001f74:	48 83 fb 00          	cmp    $0x0,%rbx
 1001f78:	74 33                	je     1001fad <itab+0x330>
			m->fun[i - inter->m] = t->ifn;
 1001f7a:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
 1001f7f:	48 89 f0             	mov    %rsi,%rax
 1001f82:	48 29 f8             	sub    %rdi,%rax
 1001f85:	48 83 c0 b8          	add    $0xffffffffffffffb8,%rax
 1001f89:	48 99                	cqto   
 1001f8b:	48 c7 44 24 38 18 00 	movq   $0x18,0x38(%rsp)
 1001f92:	00 00 
 1001f94:	48 f7 7c 24 38       	idivq  0x38(%rsp)
 1001f99:	48 89 c1             	mov    %rax,%rcx
 1001f9c:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 1001fa1:	48 8d 04 cb          	lea    (%rbx,%rcx,8),%rax
 1001fa5:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
 1001fa9:	48 89 48 20          	mov    %rcx,0x20(%rax)
	// the loop is O(ni+nt) not O(ni*nt).
	i = inter->m;
	ei = i + inter->mhdr.len;
	t = x->m;
	et = t + x->mhdr.len;
	for(; i < ei; i++) {
 1001fad:	48 83 c6 18          	add    $0x18,%rsi
 1001fb1:	e9 f2 fe ff ff       	jmpq   1001ea8 <itab+0x22b>
	for(locked=0; locked<2; locked++) {
		if(locked)
			runtime·lock(&ifacelock);
		for(m=runtime·atomicloadp(&hash[h]); m!=nil; m=m->link) {
			if(m->inter == inter && m->type == type) {
				if(m->bad) {
 1001fb6:	48 89 5c 24 70       	mov    %rbx,0x70(%rsp)
 1001fbb:	8b 43 18             	mov    0x18(%rbx),%eax
 1001fbe:	83 f8 00             	cmp    $0x0,%eax
 1001fc1:	74 16                	je     1001fd9 <itab+0x35c>
					m = nil;
 1001fc3:	48 31 db             	xor    %rbx,%rbx
 1001fc6:	48 89 5c 24 70       	mov    %rbx,0x70(%rsp)
					if(!canfail) {
 1001fcb:	83 bc 24 d0 00 00 00 	cmpl   $0x0,0xd0(%rsp)
 1001fd2:	00 
 1001fd3:	0f 84 9b fe ff ff    	je     1001e74 <itab+0x1f7>
						// down to the interface check, which will
						// do more work but give a better error.
						goto search;
					}
				}
				if(locked)
 1001fd9:	41 83 fa 00          	cmp    $0x0,%r10d
 1001fdd:	74 13                	je     1001ff2 <itab+0x375>
					runtime·unlock(&ifacelock);
 1001fdf:	b8 90 4e 02 01       	mov    $0x1024e90,%eax
 1001fe4:	48 89 04 24          	mov    %rax,(%rsp)
 1001fe8:	e8 95 ae 00 00       	callq  100ce82 <runtime.unlock>
 1001fed:	48 8b 5c 24 70       	mov    0x70(%rsp),%rbx
				return m;
 1001ff2:	48 89 d8             	mov    %rbx,%rax
 1001ff5:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
 1001ffc:	c3                   	retq   

0000000001001ffd <copyin>:
		return nil;
	return m;
}

static void
copyin(Type *t, void *src, void **dst)
 1001ffd:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002004:	ff ff 
 1002006:	48 3b 21             	cmp    (%rcx),%rsp
 1002009:	77 05                	ja     1002010 <copyin+0x13>
 100200b:	e8 4e f9 ff ff       	callq  100195e <runtime.morestack24>
 1002010:	48 83 ec 38          	sub    $0x38,%rsp
 1002014:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
{
	int32 wid, alg;
	void *p;

	wid = t->size;
 1002019:	48 8b 51 10          	mov    0x10(%rcx),%rdx
 100201d:	48 63 d2             	movslq %edx,%rdx
	alg = t->alg;
 1002020:	0f b6 41 1c          	movzbl 0x1c(%rcx),%eax
 1002024:	89 c3                	mov    %eax,%ebx
 1002026:	89 44 24 30          	mov    %eax,0x30(%rsp)

	if(wid <= sizeof(*dst))
 100202a:	83 fa 08             	cmp    $0x8,%edx
 100202d:	7f 2d                	jg     100205c <copyin+0x5f>
		runtime·algarray[alg].copy(wid, dst, src);
 100202f:	89 14 24             	mov    %edx,(%rsp)
 1002032:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1002037:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100203c:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002041:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1002046:	48 63 cb             	movslq %ebx,%rcx
 1002049:	48 c1 e1 05          	shl    $0x5,%rcx
 100204d:	48 8b 04 0d c8 3a 02 	mov    0x1023ac8(,%rcx,1),%rax
 1002054:	01 
 1002055:	ff d0                	callq  *%rax
	else {
		p = runtime·mal(wid);
		runtime·algarray[alg].copy(wid, p, src);
		*dst = p;
 1002057:	48 83 c4 38          	add    $0x38,%rsp
 100205b:	c3                   	retq   
	alg = t->alg;

	if(wid <= sizeof(*dst))
		runtime·algarray[alg].copy(wid, dst, src);
	else {
		p = runtime·mal(wid);
 100205c:	89 54 24 34          	mov    %edx,0x34(%rsp)
 1002060:	48 63 ca             	movslq %edx,%rcx
 1002063:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002067:	e8 c4 10 00 00       	callq  1003130 <runtime.mal>
 100206c:	48 89 c1             	mov    %rax,%rcx
		runtime·algarray[alg].copy(wid, p, src);
 100206f:	8b 44 24 34          	mov    0x34(%rsp),%eax
 1002073:	89 04 24             	mov    %eax,(%rsp)
 1002076:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
 100207b:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1002080:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002085:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100208a:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
 100208e:	48 63 c9             	movslq %ecx,%rcx
 1002091:	48 c1 e1 05          	shl    $0x5,%rcx
 1002095:	48 8b 04 0d c8 3a 02 	mov    0x1023ac8(,%rcx,1),%rax
 100209c:	01 
 100209d:	ff d0                	callq  *%rax
		*dst = p;
 100209f:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 10020a4:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 10020a9:	48 89 08             	mov    %rcx,(%rax)
 10020ac:	eb a9                	jmp    1002057 <copyin+0x5a>

00000000010020ae <copyout>:
	}
}

static void
copyout(Type *t, void **src, void *dst)
 10020ae:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10020b5:	ff ff 
 10020b7:	48 3b 21             	cmp    (%rcx),%rsp
 10020ba:	77 05                	ja     10020c1 <copyout+0x13>
 10020bc:	e8 9d f8 ff ff       	callq  100195e <runtime.morestack24>
 10020c1:	48 83 ec 30          	sub    $0x30,%rsp
 10020c5:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 10020ca:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
 10020cf:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
{
	int32 wid, alg;

	wid = t->size;
 10020d4:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
 10020d8:	48 63 c9             	movslq %ecx,%rcx
	alg = t->alg;
 10020db:	0f b6 42 1c          	movzbl 0x1c(%rdx),%eax
 10020df:	89 c2                	mov    %eax,%edx

	if(wid <= sizeof(*src))
 10020e1:	83 f9 08             	cmp    $0x8,%ecx
 10020e4:	7f 23                	jg     1002109 <copyout+0x5b>
		runtime·algarray[alg].copy(wid, dst, src);
 10020e6:	89 0c 24             	mov    %ecx,(%rsp)
 10020e9:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
 10020ee:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
 10020f3:	48 63 ca             	movslq %edx,%rcx
 10020f6:	48 c1 e1 05          	shl    $0x5,%rcx
 10020fa:	48 8b 04 0d c8 3a 02 	mov    0x1023ac8(,%rcx,1),%rax
 1002101:	01 
 1002102:	ff d0                	callq  *%rax
	else
		runtime·algarray[alg].copy(wid, dst, *src);
 1002104:	48 83 c4 30          	add    $0x30,%rsp
 1002108:	c3                   	retq   
 1002109:	89 0c 24             	mov    %ecx,(%rsp)
 100210c:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
 1002111:	48 8b 03             	mov    (%rbx),%rax
 1002114:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1002119:	48 63 ca             	movslq %edx,%rcx
 100211c:	48 c1 e1 05          	shl    $0x5,%rcx
 1002120:	48 8b 04 0d c8 3a 02 	mov    0x1023ac8(,%rcx,1),%rax
 1002127:	01 
 1002128:	ff d0                	callq  *%rax
 100212a:	eb d8                	jmp    1002104 <copyout+0x56>

000000000100212c <runtime.convT2E>:
}

// func convT2E(typ *byte, elem any) (ret any)
#pragma textflag 7
void
runtime·convT2E(Type *t, ...)
 100212c:	48 83 ec 40          	sub    $0x40,%rsp
{
	byte *elem;
	Eface *ret;
	int32 wid;

	elem = (byte*)(&t+1);
 1002130:	48 8d 44 24 50       	lea    0x50(%rsp),%rax
 1002135:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
	wid = t->size;
 100213a:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 100213f:	48 8b 40 10          	mov    0x10(%rax),%rax
 1002143:	48 63 c0             	movslq %eax,%rax
	ret = (Eface*)(elem + runtime·rnd(wid, Structrnd));
 1002146:	89 04 24             	mov    %eax,(%rsp)
 1002149:	b9 08 00 00 00       	mov    $0x8,%ecx
 100214e:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
 1002152:	e8 92 7d 00 00       	callq  1009ee9 <runtime.rnd>
 1002157:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
 100215c:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
 1002161:	48 01 e8             	add    %rbp,%rax
	ret->type = t;
 1002164:	48 89 18             	mov    %rbx,(%rax)
	copyin(t, elem, &ret->data);
 1002167:	48 89 1c 24          	mov    %rbx,(%rsp)
 100216b:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
 1002170:	48 83 c0 08          	add    $0x8,%rax
 1002174:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1002179:	e8 7f fe ff ff       	callq  1001ffd <copyin>
 100217e:	48 83 c4 40          	add    $0x40,%rsp
 1002182:	c3                   	retq   

0000000001002183 <runtime.assertE2T2>:
}

// func ifaceE2T2(sigt *byte, iface any) (ret any, ok bool);
#pragma textflag 7
void
runtime·assertE2T2(Type *t, Eface e, ...)
 1002183:	48 83 ec 40          	sub    $0x40,%rsp
 1002187:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
{
	byte *ret;
	bool *ok;
	int32 wid;

	if(((uintptr)e.type&reflectFlags) != 0)
 100218c:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1002191:	48 83 e0 03          	and    $0x3,%rax
 1002195:	48 83 f8 00          	cmp    $0x0,%rax
 1002199:	74 13                	je     10021ae <runtime.assertE2T2+0x2b>
		runtime·throw("invalid interface value");
 100219b:	b8 3d 39 02 01       	mov    $0x102393d,%eax
 10021a0:	48 89 04 24          	mov    %rax,(%rsp)
 10021a4:	e8 90 7b 00 00       	callq  1009d39 <runtime.throw>
 10021a9:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
	ret = (byte*)(&e+1);
 10021ae:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
 10021b3:	48 89 c3             	mov    %rax,%rbx
	wid = t->size;
 10021b6:	48 8b 6e 10          	mov    0x10(%rsi),%rbp
 10021ba:	48 63 ed             	movslq %ebp,%rbp
	ok = (bool*)(ret + wid);
 10021bd:	48 8d 04 28          	lea    (%rax,%rbp,1),%rax

	if(t != e.type) {
 10021c1:	48 3b 74 24 50       	cmp    0x50(%rsp),%rsi
 10021c6:	74 19                	je     10021e1 <runtime.assertE2T2+0x5e>
		*ok = false;
 10021c8:	c6 00 00             	movb   $0x0,(%rax)
		runtime·memclr(ret, wid);
 10021cb:	48 89 1c 24          	mov    %rbx,(%rsp)
 10021cf:	48 63 c5             	movslq %ebp,%rax
 10021d2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10021d7:	e8 cb f8 ff ff       	callq  1001aa7 <runtime.memclr>
		return;
 10021dc:	48 83 c4 40          	add    $0x40,%rsp
 10021e0:	c3                   	retq   
	}

	*ok = true;
 10021e1:	c6 00 01             	movb   $0x1,(%rax)
	copyout(t, &e.data, ret);
 10021e4:	48 89 34 24          	mov    %rsi,(%rsp)
 10021e8:	48 8d 44 24 58       	lea    0x58(%rsp),%rax
 10021ed:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10021f2:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
 10021f7:	e8 b2 fe ff ff       	callq  10020ae <copyout>
 10021fc:	48 83 c4 40          	add    $0x40,%rsp
 1002200:	c3                   	retq   

0000000001002201 <runtime.assertE2I2>:
	runtime·ifaceE2I(inter, e, &ret);
}

// ifaceE2I2(sigi *byte, iface any) (ret any, ok bool)
void
runtime·assertE2I2(InterfaceType *inter, Eface e, Iface ret, bool ok)
 1002201:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002208:	ff ff 
 100220a:	48 3b 21             	cmp    (%rcx),%rsp
 100220d:	77 05                	ja     1002214 <runtime.assertE2I2+0x13>
 100220f:	e8 65 f7 ff ff       	callq  1001979 <runtime.morestack48>
 1002214:	48 83 ec 20          	sub    $0x20,%rsp
{
	if(((uintptr)e.type&reflectFlags) != 0)
 1002218:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100221d:	48 83 e0 03          	and    $0x3,%rax
 1002221:	48 83 f8 00          	cmp    $0x0,%rax
 1002225:	74 0e                	je     1002235 <runtime.assertE2I2+0x34>
		runtime·throw("invalid interface value");
 1002227:	b8 6d 39 02 01       	mov    $0x102396d,%eax
 100222c:	48 89 04 24          	mov    %rax,(%rsp)
 1002230:	e8 04 7b 00 00       	callq  1009d39 <runtime.throw>
	if(e.type == nil) {
 1002235:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
 100223b:	75 1c                	jne    1002259 <runtime.assertE2I2+0x58>
		ok = 0;
 100223d:	c6 44 24 50 00       	movb   $0x0,0x50(%rsp)
		ret.data = nil;
 1002242:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
 1002249:	00 00 
		ret.tab = nil;
 100224b:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
 1002252:	00 00 
	} else {
		ok = 1;
		ret.data = e.data;
	}
	FLUSH(&ret);
	FLUSH(&ok);
 1002254:	48 83 c4 20          	add    $0x20,%rsp
 1002258:	c3                   	retq   
		runtime·throw("invalid interface value");
	if(e.type == nil) {
		ok = 0;
		ret.data = nil;
		ret.tab = nil;
	} else if((ret.tab = itab(inter, e.type, 1)) == nil) {
 1002259:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100225e:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002262:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1002267:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100226c:	b9 01 00 00 00       	mov    $0x1,%ecx
 1002271:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1002275:	e8 03 fa ff ff       	callq  1001c7d <itab>
 100227a:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
 100227f:	48 83 f8 00          	cmp    $0x0,%rax
 1002283:	75 10                	jne    1002295 <runtime.assertE2I2+0x94>
		ok = 0;
 1002285:	c6 44 24 50 00       	movb   $0x0,0x50(%rsp)
		ret.data = nil;
 100228a:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
 1002291:	00 00 
	} else {
		ok = 1;
		ret.data = e.data;
	}
	FLUSH(&ret);
	FLUSH(&ok);
 1002293:	eb bf                	jmp    1002254 <runtime.assertE2I2+0x53>
		ret.tab = nil;
	} else if((ret.tab = itab(inter, e.type, 1)) == nil) {
		ok = 0;
		ret.data = nil;
	} else {
		ok = 1;
 1002295:	c6 44 24 50 01       	movb   $0x1,0x50(%rsp)
		ret.data = e.data;
 100229a:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100229f:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
	}
	FLUSH(&ret);
	FLUSH(&ok);
 10022a4:	eb ae                	jmp    1002254 <runtime.assertE2I2+0x53>

00000000010022a6 <ifacehash1>:
	FLUSH(&ret);
	FLUSH(&ok);
}

static uintptr
ifacehash1(void *data, Type *t)
 10022a6:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10022ad:	ff ff 
 10022af:	48 3b 21             	cmp    (%rcx),%rsp
 10022b2:	77 05                	ja     10022b9 <ifacehash1+0x13>
 10022b4:	e8 9c f6 ff ff       	callq  1001955 <runtime.morestack16>
 10022b9:	48 83 ec 70          	sub    $0x70,%rsp
 10022bd:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
 10022c4:	00 
{
	int32 alg, wid;
	Eface err;

	if(t == nil)
 10022c5:	48 83 f9 00          	cmp    $0x0,%rcx
 10022c9:	75 08                	jne    10022d3 <ifacehash1+0x2d>
		return 0;
 10022cb:	48 31 c0             	xor    %rax,%rax
 10022ce:	48 83 c4 70          	add    $0x70,%rsp
 10022d2:	c3                   	retq   

	alg = t->alg;
 10022d3:	0f b6 41 1c          	movzbl 0x1c(%rcx),%eax
 10022d7:	89 c3                	mov    %eax,%ebx
	wid = t->size;
 10022d9:	48 8b 51 10          	mov    0x10(%rcx),%rdx
 10022dd:	48 63 d2             	movslq %edx,%rdx
 10022e0:	89 54 24 68          	mov    %edx,0x68(%rsp)
	if(runtime·algarray[alg].hash == runtime·nohash) {
 10022e4:	89 44 24 6c          	mov    %eax,0x6c(%rsp)
 10022e8:	48 63 c8             	movslq %eax,%rcx
 10022eb:	48 c1 e1 05          	shl    $0x5,%rcx
 10022ef:	48 8b 04 0d b0 3a 02 	mov    0x1023ab0(,%rcx,1),%rax
 10022f6:	01 
 10022f7:	48 3d 7a a9 00 01    	cmp    $0x100a97a,%rax
 10022fd:	0f 85 99 00 00 00    	jne    100239c <ifacehash1+0xf6>
		// calling nohash will panic too,
		// but we can print a better error.
		runtime·newErrorString(runtime·catstring(runtime·gostringnocopy((byte*)"hash of unhashable type "), *t->string), &err);
 1002303:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
 1002308:	48 89 04 24          	mov    %rax,(%rsp)
 100230c:	b8 b5 39 02 01       	mov    $0x10239b5,%eax
 1002311:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1002316:	e8 10 95 00 00       	callq  100b82b <runtime.gostringnocopy>
 100231b:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
 1002320:	48 89 04 24          	mov    %rax,(%rsp)
 1002324:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1002329:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100232e:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 1002333:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1002338:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
 100233f:	00 
 1002340:	48 8b 49 20          	mov    0x20(%rcx),%rcx
 1002344:	48 8b 01             	mov    (%rcx),%rax
 1002347:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 100234c:	48 8b 41 08          	mov    0x8(%rcx),%rax
 1002350:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1002355:	e8 1a 95 00 00       	callq  100b874 <runtime.catstring>
 100235a:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 100235f:	48 89 04 24          	mov    %rax,(%rsp)
 1002363:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002368:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100236d:	48 8d 44 24 58       	lea    0x58(%rsp),%rax
 1002372:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1002377:	e8 37 ee ff ff       	callq  10011b3 <runtime.newErrorString>
		runtime·panic(err);
 100237c:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 1002381:	48 89 04 24          	mov    %rax,(%rsp)
 1002385:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 100238a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100238f:	e8 08 73 00 00       	callq  100969c <runtime.panic>
 1002394:	8b 5c 24 6c          	mov    0x6c(%rsp),%ebx
 1002398:	8b 54 24 68          	mov    0x68(%rsp),%edx
	}
	if(wid <= sizeof(data))
 100239c:	83 fa 08             	cmp    $0x8,%edx
 100239f:	7f 23                	jg     10023c4 <ifacehash1+0x11e>
		return runtime·algarray[alg].hash(wid, &data);
 10023a1:	89 14 24             	mov    %edx,(%rsp)
 10023a4:	48 8d 4c 24 78       	lea    0x78(%rsp),%rcx
 10023a9:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10023ae:	48 63 cb             	movslq %ebx,%rcx
 10023b1:	48 c1 e1 05          	shl    $0x5,%rcx
 10023b5:	48 8b 04 0d b0 3a 02 	mov    0x1023ab0(,%rcx,1),%rax
 10023bc:	01 
 10023bd:	ff d0                	callq  *%rax
 10023bf:	48 83 c4 70          	add    $0x70,%rsp
 10023c3:	c3                   	retq   
	return runtime·algarray[alg].hash(wid, data);
 10023c4:	89 14 24             	mov    %edx,(%rsp)
 10023c7:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
 10023cc:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10023d1:	48 63 cb             	movslq %ebx,%rcx
 10023d4:	48 c1 e1 05          	shl    $0x5,%rcx
 10023d8:	48 8b 04 0d b0 3a 02 	mov    0x1023ab0(,%rcx,1),%rax
 10023df:	01 
 10023e0:	ff d0                	callq  *%rax
 10023e2:	48 83 c4 70          	add    $0x70,%rsp
 10023e6:	c3                   	retq   

00000000010023e7 <runtime.ifacehash>:
}

uintptr
runtime·ifacehash(Iface a)
 10023e7:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10023ee:	ff ff 
 10023f0:	48 3b 21             	cmp    (%rcx),%rsp
 10023f3:	77 05                	ja     10023fa <runtime.ifacehash+0x13>
 10023f5:	e8 5b f5 ff ff       	callq  1001955 <runtime.morestack16>
 10023fa:	48 83 ec 18          	sub    $0x18,%rsp
{
	if(a.tab == nil)
 10023fe:	48 83 7c 24 20 00    	cmpq   $0x0,0x20(%rsp)
 1002404:	75 08                	jne    100240e <runtime.ifacehash+0x27>
		return 0;
 1002406:	48 31 c0             	xor    %rax,%rax
 1002409:	48 83 c4 18          	add    $0x18,%rsp
 100240d:	c3                   	retq   
	return ifacehash1(a.data, a.tab->type);
 100240e:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 1002413:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002417:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 100241c:	48 8b 49 08          	mov    0x8(%rcx),%rcx
 1002420:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1002425:	e8 7c fe ff ff       	callq  10022a6 <ifacehash1>
 100242a:	48 83 c4 18          	add    $0x18,%rsp
 100242e:	c3                   	retq   

000000000100242f <runtime.efacehash>:
}

uintptr
runtime·efacehash(Eface a)
 100242f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002436:	ff ff 
 1002438:	48 3b 21             	cmp    (%rcx),%rsp
 100243b:	77 05                	ja     1002442 <runtime.efacehash+0x13>
 100243d:	e8 13 f5 ff ff       	callq  1001955 <runtime.morestack16>
 1002442:	48 83 ec 18          	sub    $0x18,%rsp
{
	return ifacehash1(a.data, a.type);
 1002446:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100244b:	48 89 0c 24          	mov    %rcx,(%rsp)
 100244f:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 1002454:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1002459:	e8 48 fe ff ff       	callq  10022a6 <ifacehash1>
 100245e:	48 83 c4 18          	add    $0x18,%rsp
 1002462:	c3                   	retq   

0000000001002463 <ifaceeq1>:
}

static bool
ifaceeq1(void *data1, void *data2, Type *t)
 1002463:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100246a:	ff ff 
 100246c:	48 3b 21             	cmp    (%rcx),%rsp
 100246f:	77 05                	ja     1002476 <ifaceeq1+0x13>
 1002471:	e8 e8 f4 ff ff       	callq  100195e <runtime.morestack24>
 1002476:	48 83 ec 70          	sub    $0x70,%rsp
 100247a:	48 8b 8c 24 88 00 00 	mov    0x88(%rsp),%rcx
 1002481:	00 
{
	int32 alg, wid;
	Eface err;

	alg = t->alg;
 1002482:	0f b6 41 1c          	movzbl 0x1c(%rcx),%eax
 1002486:	89 c3                	mov    %eax,%ebx
	wid = t->size;
 1002488:	48 8b 51 10          	mov    0x10(%rcx),%rdx
 100248c:	48 63 d2             	movslq %edx,%rdx
 100248f:	89 54 24 68          	mov    %edx,0x68(%rsp)

	if(runtime·algarray[alg].equal == runtime·noequal) {
 1002493:	89 44 24 6c          	mov    %eax,0x6c(%rsp)
 1002497:	48 63 c8             	movslq %eax,%rcx
 100249a:	48 c1 e1 05          	shl    $0x5,%rcx
 100249e:	48 8b 04 0d b8 3a 02 	mov    0x1023ab8(,%rcx,1),%rax
 10024a5:	01 
 10024a6:	48 3d a7 a9 00 01    	cmp    $0x100a9a7,%rax
 10024ac:	0f 85 99 00 00 00    	jne    100254b <ifaceeq1+0xe8>
		// calling noequal will panic too,
		// but we can print a better error.
		runtime·newErrorString(runtime·catstring(runtime·gostringnocopy((byte*)"comparing uncomparable type "), *t->string), &err);
 10024b2:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
 10024b7:	48 89 04 24          	mov    %rax,(%rsp)
 10024bb:	b8 ce 39 02 01       	mov    $0x10239ce,%eax
 10024c0:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10024c5:	e8 61 93 00 00       	callq  100b82b <runtime.gostringnocopy>
 10024ca:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
 10024cf:	48 89 04 24          	mov    %rax,(%rsp)
 10024d3:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 10024d8:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10024dd:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 10024e2:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 10024e7:	48 8b 8c 24 88 00 00 	mov    0x88(%rsp),%rcx
 10024ee:	00 
 10024ef:	48 8b 49 20          	mov    0x20(%rcx),%rcx
 10024f3:	48 8b 01             	mov    (%rcx),%rax
 10024f6:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 10024fb:	48 8b 41 08          	mov    0x8(%rcx),%rax
 10024ff:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1002504:	e8 6b 93 00 00       	callq  100b874 <runtime.catstring>
 1002509:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 100250e:	48 89 04 24          	mov    %rax,(%rsp)
 1002512:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002517:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100251c:	48 8d 44 24 58       	lea    0x58(%rsp),%rax
 1002521:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1002526:	e8 88 ec ff ff       	callq  10011b3 <runtime.newErrorString>
		runtime·panic(err);
 100252b:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 1002530:	48 89 04 24          	mov    %rax,(%rsp)
 1002534:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1002539:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100253e:	e8 59 71 00 00       	callq  100969c <runtime.panic>
 1002543:	8b 5c 24 6c          	mov    0x6c(%rsp),%ebx
 1002547:	8b 54 24 68          	mov    0x68(%rsp),%edx
	}

	if(wid <= sizeof(data1))
 100254b:	83 fa 08             	cmp    $0x8,%edx
 100254e:	7f 30                	jg     1002580 <ifaceeq1+0x11d>
		return runtime·algarray[alg].equal(wid, &data1, &data2);
 1002550:	89 14 24             	mov    %edx,(%rsp)
 1002553:	48 8d 4c 24 78       	lea    0x78(%rsp),%rcx
 1002558:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100255d:	48 8d 8c 24 80 00 00 	lea    0x80(%rsp),%rcx
 1002564:	00 
 1002565:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100256a:	48 63 cb             	movslq %ebx,%rcx
 100256d:	48 c1 e1 05          	shl    $0x5,%rcx
 1002571:	48 8b 04 0d b8 3a 02 	mov    0x1023ab8(,%rcx,1),%rax
 1002578:	01 
 1002579:	ff d0                	callq  *%rax
 100257b:	48 83 c4 70          	add    $0x70,%rsp
 100257f:	c3                   	retq   
	return runtime·algarray[alg].equal(wid, data1, data2);
 1002580:	89 14 24             	mov    %edx,(%rsp)
 1002583:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
 1002588:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100258d:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
 1002594:	00 
 1002595:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100259a:	48 63 cb             	movslq %ebx,%rcx
 100259d:	48 c1 e1 05          	shl    $0x5,%rcx
 10025a1:	48 8b 04 0d b8 3a 02 	mov    0x1023ab8(,%rcx,1),%rax
 10025a8:	01 
 10025a9:	ff d0                	callq  *%rax
 10025ab:	48 83 c4 70          	add    $0x70,%rsp
 10025af:	c3                   	retq   

00000000010025b0 <runtime.ifaceeq_c>:
}

bool
runtime·ifaceeq_c(Iface i1, Iface i2)
 10025b0:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10025b7:	ff ff 
 10025b9:	48 3b 21             	cmp    (%rcx),%rsp
 10025bc:	77 05                	ja     10025c3 <runtime.ifaceeq_c+0x13>
 10025be:	e8 a4 f3 ff ff       	callq  1001967 <runtime.morestack32>
 10025c3:	48 83 ec 20          	sub    $0x20,%rsp
{
	if(i1.tab != i2.tab)
 10025c7:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 10025cc:	48 3b 44 24 38       	cmp    0x38(%rsp),%rax
 10025d1:	74 07                	je     10025da <runtime.ifaceeq_c+0x2a>
		return false;
 10025d3:	31 c0                	xor    %eax,%eax
 10025d5:	48 83 c4 20          	add    $0x20,%rsp
 10025d9:	c3                   	retq   
	if(i1.tab == nil)
 10025da:	48 83 7c 24 28 00    	cmpq   $0x0,0x28(%rsp)
 10025e0:	75 0a                	jne    10025ec <runtime.ifaceeq_c+0x3c>
		return true;
 10025e2:	b8 01 00 00 00       	mov    $0x1,%eax
 10025e7:	48 83 c4 20          	add    $0x20,%rsp
 10025eb:	c3                   	retq   
	return ifaceeq1(i1.data, i2.data, i1.tab->type);
 10025ec:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 10025f1:	48 89 0c 24          	mov    %rcx,(%rsp)
 10025f5:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 10025fa:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10025ff:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 1002604:	48 8b 49 08          	mov    0x8(%rcx),%rcx
 1002608:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100260d:	e8 51 fe ff ff       	callq  1002463 <ifaceeq1>
 1002612:	48 83 c4 20          	add    $0x20,%rsp
 1002616:	c3                   	retq   

0000000001002617 <runtime.efaceeq_c>:
}

bool
runtime·efaceeq_c(Eface e1, Eface e2)
 1002617:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100261e:	ff ff 
 1002620:	48 3b 21             	cmp    (%rcx),%rsp
 1002623:	77 05                	ja     100262a <runtime.efaceeq_c+0x13>
 1002625:	e8 3d f3 ff ff       	callq  1001967 <runtime.morestack32>
 100262a:	48 83 ec 20          	sub    $0x20,%rsp
{
	if(((uintptr)e1.type&reflectFlags) != 0)
 100262e:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1002633:	48 83 e0 03          	and    $0x3,%rax
 1002637:	48 83 f8 00          	cmp    $0x0,%rax
 100263b:	74 0e                	je     100264b <runtime.efaceeq_c+0x34>
		runtime·throw("invalid interface value");
 100263d:	b8 eb 39 02 01       	mov    $0x10239eb,%eax
 1002642:	48 89 04 24          	mov    %rax,(%rsp)
 1002646:	e8 ee 76 00 00       	callq  1009d39 <runtime.throw>
	if(((uintptr)e2.type&reflectFlags) != 0)
 100264b:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 1002650:	48 83 e0 03          	and    $0x3,%rax
 1002654:	48 83 f8 00          	cmp    $0x0,%rax
 1002658:	74 0e                	je     1002668 <runtime.efaceeq_c+0x51>
		runtime·throw("invalid interface value");
 100265a:	b8 03 3a 02 01       	mov    $0x1023a03,%eax
 100265f:	48 89 04 24          	mov    %rax,(%rsp)
 1002663:	e8 d1 76 00 00       	callq  1009d39 <runtime.throw>
	if(e1.type != e2.type)
 1002668:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100266d:	48 3b 44 24 38       	cmp    0x38(%rsp),%rax
 1002672:	74 07                	je     100267b <runtime.efaceeq_c+0x64>
		return false;
 1002674:	31 c0                	xor    %eax,%eax
 1002676:	48 83 c4 20          	add    $0x20,%rsp
 100267a:	c3                   	retq   
	if(e1.type == nil)
 100267b:	48 83 7c 24 28 00    	cmpq   $0x0,0x28(%rsp)
 1002681:	75 0a                	jne    100268d <runtime.efaceeq_c+0x76>
		return true;
 1002683:	b8 01 00 00 00       	mov    $0x1,%eax
 1002688:	48 83 c4 20          	add    $0x20,%rsp
 100268c:	c3                   	retq   
	return ifaceeq1(e1.data, e2.data, e1.type);
 100268d:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1002692:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002696:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 100269b:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10026a0:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 10026a5:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 10026aa:	e8 b4 fd ff ff       	callq  1002463 <ifaceeq1>
 10026af:	48 83 c4 20          	add    $0x20,%rsp
 10026b3:	c3                   	retq   

00000000010026b4 <runtime.efacethash>:
	FLUSH(&ret);
}

// efacethash(e1 any) (ret uint32)
void
runtime·efacethash(Eface e1, uint32 ret)
 10026b4:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10026bb:	ff ff 
 10026bd:	48 3b 21             	cmp    (%rcx),%rsp
 10026c0:	77 05                	ja     10026c7 <runtime.efacethash+0x13>
 10026c2:	e8 97 f2 ff ff       	callq  100195e <runtime.morestack24>
 10026c7:	48 83 ec 20          	sub    $0x20,%rsp
{
	Type *t;

	if(((uintptr)e1.type&reflectFlags) != 0)
 10026cb:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 10026d0:	48 83 e0 03          	and    $0x3,%rax
 10026d4:	48 83 f8 00          	cmp    $0x0,%rax
 10026d8:	74 0e                	je     10026e8 <runtime.efacethash+0x34>
		runtime·throw("invalid interface value");
 10026da:	b8 1b 3a 02 01       	mov    $0x1023a1b,%eax
 10026df:	48 89 04 24          	mov    %rax,(%rsp)
 10026e3:	e8 51 76 00 00       	callq  1009d39 <runtime.throw>
	ret = 0;
 10026e8:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%rsp)
 10026ef:	00 
	t = e1.type;
 10026f0:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
	if(t != nil)
 10026f5:	48 83 f8 00          	cmp    $0x0,%rax
 10026f9:	74 07                	je     1002702 <runtime.efacethash+0x4e>
		ret = t->hash;
 10026fb:	8b 40 18             	mov    0x18(%rax),%eax
 10026fe:	89 44 24 38          	mov    %eax,0x38(%rsp)
 1002702:	48 83 c4 20          	add    $0x20,%rsp
 1002706:	c3                   	retq   

0000000001002707 <runtime.mallocgc>:

// Allocate an object of at least size bytes.
// Small objects are allocated from the per-thread cache's free lists.
// Large objects (> 32 kB) are allocated straight from the heap.
void*
runtime·mallocgc(uintptr size, uint32 flag, int32 dogc, int32 zeroed)
 1002707:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100270e:	ff ff 
 1002710:	48 3b 21             	cmp    (%rcx),%rsp
 1002713:	77 05                	ja     100271a <runtime.mallocgc+0x13>
 1002715:	e8 44 f2 ff ff       	callq  100195e <runtime.morestack24>
 100271a:	48 83 ec 58          	sub    $0x58,%rsp
 100271e:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
	MCache *c;
	uintptr npages;
	MSpan *s;
	void *v;

	if(runtime·gcwaiting && g != m->g0 && m->locks == 0)
 1002723:	83 3c 25 14 4e 02 01 	cmpl   $0x0,0x1024e14
 100272a:	00 
 100272b:	74 1e                	je     100274b <runtime.mallocgc+0x44>
 100272d:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1002734:	ff ff 
 1002736:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 100273d:	ff ff 
 100273f:	48 8b 09             	mov    (%rcx),%rcx
 1002742:	48 39 c8             	cmp    %rcx,%rax
 1002745:	0f 85 19 03 00 00    	jne    1002a64 <runtime.mallocgc+0x35d>
		runtime·gosched();
	if(m->mallocing)
 100274b:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002752:	ff ff 
 1002754:	8b 40 7c             	mov    0x7c(%rax),%eax
 1002757:	83 f8 00             	cmp    $0x0,%eax
 100275a:	74 13                	je     100276f <runtime.mallocgc+0x68>
		runtime·throw("malloc/free - deadlock");
 100275c:	b8 30 43 02 01       	mov    $0x1024330,%eax
 1002761:	48 89 04 24          	mov    %rax,(%rsp)
 1002765:	e8 cf 75 00 00       	callq  1009d39 <runtime.throw>
 100276a:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
	m->mallocing = 1;
 100276f:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002776:	ff ff 
 1002778:	c7 40 7c 01 00 00 00 	movl   $0x1,0x7c(%rax)
	if(size == 0)
 100277f:	48 83 fa 00          	cmp    $0x0,%rdx
 1002783:	75 07                	jne    100278c <runtime.mallocgc+0x85>
		size = 1;
 1002785:	48 c7 c2 01 00 00 00 	mov    $0x1,%rdx

	c = m->mcache;
 100278c:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002793:	ff ff 
 1002795:	48 8b 88 d8 00 00 00 	mov    0xd8(%rax),%rcx
	c->local_nmalloc++;
 100279c:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
 10027a1:	48 ff 81 f8 03 00 00 	incq   0x3f8(%rcx)
	if(size <= MaxSmallSize) {
 10027a8:	48 81 fa 00 80 00 00 	cmp    $0x8000,%rdx
 10027af:	0f 87 e5 01 00 00    	ja     100299a <runtime.mallocgc+0x293>
		// Allocate from mcache free lists.
		sizeclass = runtime·SizeToClass(size);
 10027b5:	48 63 ca             	movslq %edx,%rcx
 10027b8:	89 0c 24             	mov    %ecx,(%rsp)
 10027bb:	e8 f9 47 00 00       	callq  1006fb9 <runtime.SizeToClass>
 10027c0:	89 c2                	mov    %eax,%edx
		size = runtime·class_to_size[sizeclass];
 10027c2:	48 63 c8             	movslq %eax,%rcx
 10027c5:	8b 04 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%eax
 10027cc:	48 63 c0             	movslq %eax,%rax
		v = runtime·MCache_Alloc(c, sizeclass, size, zeroed);
 10027cf:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 10027d4:	48 89 0c 24          	mov    %rcx,(%rsp)
 10027d8:	89 54 24 54          	mov    %edx,0x54(%rsp)
 10027dc:	89 54 24 08          	mov    %edx,0x8(%rsp)
 10027e0:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
 10027e5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 10027ea:	8b 4c 24 70          	mov    0x70(%rsp),%ecx
 10027ee:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
 10027f2:	e8 12 0b 00 00       	callq  1003309 <runtime.MCache_Alloc>
 10027f7:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
 10027fc:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
 1002801:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		if(v == nil)
 1002806:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
 100280c:	75 18                	jne    1002826 <runtime.mallocgc+0x11f>
			runtime·throw("out of memory");
 100280e:	b8 47 43 02 01       	mov    $0x1024347,%eax
 1002813:	48 89 04 24          	mov    %rax,(%rsp)
 1002817:	e8 1d 75 00 00       	callq  1009d39 <runtime.throw>
 100281c:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
 1002821:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
		c->local_alloc += size;
 1002826:	48 01 9d e8 03 00 00 	add    %rbx,0x3e8(%rbp)
		c->local_total_alloc += size;
 100282d:	48 01 9d f0 03 00 00 	add    %rbx,0x3f0(%rbp)
		c->local_by_size[sizeclass].nmalloc++;
 1002834:	8b 4c 24 54          	mov    0x54(%rsp),%ecx
 1002838:	48 63 c9             	movslq %ecx,%rcx
 100283b:	48 c1 e1 04          	shl    $0x4,%rcx
 100283f:	48 89 ea             	mov    %rbp,%rdx
 1002842:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1002846:	48 ff 80 18 04 00 00 	incq   0x418(%rax)
		v = (void*)(s->start << PageShift);

		// setup for mark sweep
		runtime·markspan(v, 0, 0, true);
	}
	if(!(flag & FlagNoGC))
 100284d:	8b 44 24 68          	mov    0x68(%rsp),%eax
 1002851:	83 e0 04             	and    $0x4,%eax
 1002854:	83 f8 00             	cmp    $0x0,%eax
 1002857:	75 31                	jne    100288a <runtime.mallocgc+0x183>
		runtime·markallocated(v, size, (flag&FlagNoPointers) != 0);
 1002859:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100285e:	48 89 04 24          	mov    %rax,(%rsp)
 1002862:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 1002867:	8b 44 24 68          	mov    0x68(%rsp),%eax
 100286b:	83 e0 01             	and    $0x1,%eax
 100286e:	83 f8 00             	cmp    $0x0,%eax
 1002871:	0f 84 1c 01 00 00    	je     1002993 <runtime.mallocgc+0x28c>
 1002877:	b8 01 00 00 00       	mov    $0x1,%eax
 100287c:	88 44 24 10          	mov    %al,0x10(%rsp)
 1002880:	e8 41 2d 00 00       	callq  10055c6 <runtime.markallocated>
 1002885:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx

	m->mallocing = 0;
 100288a:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002891:	ff ff 
 1002893:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)

	if(!(flag & FlagNoProfiling) && (rate = runtime·MemProfileRate) > 0) {
 100289a:	8b 44 24 68          	mov    0x68(%rsp),%eax
 100289e:	83 e0 02             	and    $0x2,%eax
 10028a1:	83 f8 00             	cmp    $0x0,%eax
 10028a4:	75 0c                	jne    10028b2 <runtime.mallocgc+0x1ab>
 10028a6:	8b 0c 25 08 30 02 01 	mov    0x1023008,%ecx
 10028ad:	83 f9 00             	cmp    $0x0,%ecx
 10028b0:	7f 31                	jg     10028e3 <runtime.mallocgc+0x1dc>
			runtime·setblockspecial(v);
			runtime·MProf_Malloc(v, size);
		}
	}

	if(dogc && mstats.heap_alloc >= mstats.next_gc)
 10028b2:	83 7c 24 6c 00       	cmpl   $0x0,0x6c(%rsp)
 10028b7:	74 12                	je     10028cb <runtime.mallocgc+0x1c4>
 10028b9:	48 8b 04 25 88 62 02 	mov    0x1026288,%rax
 10028c0:	01 
 10028c1:	48 3b 04 25 e8 62 02 	cmp    0x10262e8,%rax
 10028c8:	01 
 10028c9:	73 0a                	jae    10028d5 <runtime.mallocgc+0x1ce>
		runtime·gc(0);
	return v;
 10028cb:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 10028d0:	48 83 c4 58          	add    $0x58,%rsp
 10028d4:	c3                   	retq   
			runtime·MProf_Malloc(v, size);
		}
	}

	if(dogc && mstats.heap_alloc >= mstats.next_gc)
		runtime·gc(0);
 10028d5:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
 10028dc:	e8 d2 26 00 00       	callq  1004fb3 <runtime.gc>
	return v;
 10028e1:	eb e8                	jmp    10028cb <runtime.mallocgc+0x1c4>
		runtime·markallocated(v, size, (flag&FlagNoPointers) != 0);

	m->mallocing = 0;

	if(!(flag & FlagNoProfiling) && (rate = runtime·MemProfileRate) > 0) {
		if(size >= rate)
 10028e3:	48 63 c1             	movslq %ecx,%rax
 10028e6:	48 39 c3             	cmp    %rax,%rbx
 10028e9:	72 28                	jb     1002913 <runtime.mallocgc+0x20c>
			// pick next profile time
			if(rate > 0x3fffffff)	// make 2*rate not overflow
				rate = 0x3fffffff;
			m->mcache->next_sample = runtime·fastrand1() % (2*rate);
		profile:
			runtime·setblockspecial(v);
 10028eb:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 10028f0:	48 89 04 24          	mov    %rax,(%rsp)
 10028f4:	e8 41 32 00 00       	callq  1005b3a <runtime.setblockspecial>
			runtime·MProf_Malloc(v, size);
 10028f9:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 10028fe:	48 89 04 24          	mov    %rax,(%rsp)
 1002902:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1002907:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100290c:	e8 2f 45 00 00       	callq  1006e40 <runtime.MProf_Malloc>
		}
	}

	if(dogc && mstats.heap_alloc >= mstats.next_gc)
 1002911:	eb 9f                	jmp    10028b2 <runtime.mallocgc+0x1ab>
	m->mallocing = 0;

	if(!(flag & FlagNoProfiling) && (rate = runtime·MemProfileRate) > 0) {
		if(size >= rate)
			goto profile;
		if(m->mcache->next_sample > size)
 1002913:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100291a:	ff ff 
 100291c:	48 8b 80 d8 00 00 00 	mov    0xd8(%rax),%rax
 1002923:	8b 80 10 04 00 00    	mov    0x410(%rax),%eax
 1002929:	48 63 c0             	movslq %eax,%rax
 100292c:	48 39 d8             	cmp    %rbx,%rax
 100292f:	76 1e                	jbe    100294f <runtime.mallocgc+0x248>
			m->mcache->next_sample -= size;
 1002931:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002938:	ff ff 
 100293a:	48 8b 80 d8 00 00 00 	mov    0xd8(%rax),%rax
 1002941:	48 63 cb             	movslq %ebx,%rcx
 1002944:	29 88 10 04 00 00    	sub    %ecx,0x410(%rax)
			runtime·setblockspecial(v);
			runtime·MProf_Malloc(v, size);
		}
	}

	if(dogc && mstats.heap_alloc >= mstats.next_gc)
 100294a:	e9 63 ff ff ff       	jmpq   10028b2 <runtime.mallocgc+0x1ab>
			goto profile;
		if(m->mcache->next_sample > size)
			m->mcache->next_sample -= size;
		else {
			// pick next profile time
			if(rate > 0x3fffffff)	// make 2*rate not overflow
 100294f:	81 f9 ff ff ff 3f    	cmp    $0x3fffffff,%ecx
 1002955:	89 4c 24 50          	mov    %ecx,0x50(%rsp)
 1002959:	7e 08                	jle    1002963 <runtime.mallocgc+0x25c>
				rate = 0x3fffffff;
 100295b:	c7 44 24 50 ff ff ff 	movl   $0x3fffffff,0x50(%rsp)
 1002962:	3f 
			m->mcache->next_sample = runtime·fastrand1() % (2*rate);
 1002963:	e8 d1 80 00 00       	callq  100aa39 <runtime.fastrand1>
 1002968:	31 d2                	xor    %edx,%edx
 100296a:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
 100296e:	01 c9                	add    %ecx,%ecx
 1002970:	89 4c 24 24          	mov    %ecx,0x24(%rsp)
 1002974:	f7 74 24 24          	divl   0x24(%rsp)
 1002978:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 100297f:	ff ff 
 1002981:	48 8b 89 d8 00 00 00 	mov    0xd8(%rcx),%rcx
 1002988:	89 91 10 04 00 00    	mov    %edx,0x410(%rcx)
		profile:
			runtime·setblockspecial(v);
 100298e:	e9 58 ff ff ff       	jmpq   10028eb <runtime.mallocgc+0x1e4>

		// setup for mark sweep
		runtime·markspan(v, 0, 0, true);
	}
	if(!(flag & FlagNoGC))
		runtime·markallocated(v, size, (flag&FlagNoPointers) != 0);
 1002993:	31 c0                	xor    %eax,%eax
 1002995:	e9 e2 fe ff ff       	jmpq   100287c <runtime.mallocgc+0x175>
		c->local_by_size[sizeclass].nmalloc++;
	} else {
		// TODO(rsc): Report tracebacks for very large allocations.

		// Allocate directly from heap.
		npages = size >> PageShift;
 100299a:	48 89 d0             	mov    %rdx,%rax
 100299d:	48 c1 e8 0c          	shr    $0xc,%rax
 10029a1:	48 89 c3             	mov    %rax,%rbx
		if((size & PageMask) != 0)
 10029a4:	48 89 d0             	mov    %rdx,%rax
 10029a7:	48 25 ff 0f 00 00    	and    $0xfff,%rax
 10029ad:	48 83 f8 00          	cmp    $0x0,%rax
 10029b1:	74 03                	je     10029b6 <runtime.mallocgc+0x2af>
			npages++;
 10029b3:	48 ff c3             	inc    %rbx
		s = runtime·MHeap_Alloc(&runtime·mheap, npages, 0, 1);
 10029b6:	b9 80 a0 03 01       	mov    $0x103a080,%ecx
 10029bb:	48 89 0c 24          	mov    %rcx,(%rsp)
 10029bf:	48 89 5c 24 40       	mov    %rbx,0x40(%rsp)
 10029c4:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 10029c9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
 10029d0:	00 
 10029d1:	b9 01 00 00 00       	mov    $0x1,%ecx
 10029d6:	89 4c 24 14          	mov    %ecx,0x14(%rsp)
 10029da:	e8 0b 34 00 00       	callq  1005dea <runtime.MHeap_Alloc>
 10029df:	48 89 c3             	mov    %rax,%rbx
		if(s == nil)
 10029e2:	48 83 f8 00          	cmp    $0x0,%rax
 10029e6:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
 10029eb:	75 13                	jne    1002a00 <runtime.mallocgc+0x2f9>
			runtime·throw("out of memory");
 10029ed:	b8 55 43 02 01       	mov    $0x1024355,%eax
 10029f2:	48 89 04 24          	mov    %rax,(%rsp)
 10029f6:	e8 3e 73 00 00       	callq  1009d39 <runtime.throw>
 10029fb:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
		size = npages<<PageShift;
 1002a00:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 1002a05:	48 c1 e0 0c          	shl    $0xc,%rax
 1002a09:	48 89 c2             	mov    %rax,%rdx
		c->local_alloc += size;
 1002a0c:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002a11:	48 01 90 e8 03 00 00 	add    %rdx,0x3e8(%rax)
		c->local_total_alloc += size;
 1002a18:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002a1d:	48 89 54 24 60       	mov    %rdx,0x60(%rsp)
 1002a22:	48 01 90 f0 03 00 00 	add    %rdx,0x3f0(%rax)
		v = (void*)(s->start << PageShift);
 1002a29:	48 8b 43 18          	mov    0x18(%rbx),%rax
 1002a2d:	48 c1 e0 0c          	shl    $0xc,%rax

		// setup for mark sweep
		runtime·markspan(v, 0, 0, true);
 1002a31:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
 1002a36:	48 89 04 24          	mov    %rax,(%rsp)
 1002a3a:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
 1002a41:	00 00 
 1002a43:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 1002a4a:	00 00 
 1002a4c:	b8 01 00 00 00       	mov    $0x1,%eax
 1002a51:	88 44 24 18          	mov    %al,0x18(%rsp)
 1002a55:	e8 56 2e 00 00       	callq  10058b0 <runtime.markspan>
 1002a5a:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
	}
	if(!(flag & FlagNoGC))
 1002a5f:	e9 e9 fd ff ff       	jmpq   100284d <runtime.mallocgc+0x146>
	MCache *c;
	uintptr npages;
	MSpan *s;
	void *v;

	if(runtime·gcwaiting && g != m->g0 && m->locks == 0)
 1002a64:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002a6b:	ff ff 
 1002a6d:	8b 80 84 00 00 00    	mov    0x84(%rax),%eax
 1002a73:	83 f8 00             	cmp    $0x0,%eax
 1002a76:	0f 85 cf fc ff ff    	jne    100274b <runtime.mallocgc+0x44>
		runtime·gosched();
 1002a7c:	e8 2f 63 00 00       	callq  1008db0 <runtime.gosched>
 1002a81:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
	if(m->mallocing)
 1002a86:	e9 c0 fc ff ff       	jmpq   100274b <runtime.mallocgc+0x44>

0000000001002a8b <runtime.malloc>:
		runtime·gc(0);
	return v;
}

void*
runtime·malloc(uintptr size)
 1002a8b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002a92:	ff ff 
 1002a94:	48 3b 21             	cmp    (%rcx),%rsp
 1002a97:	77 05                	ja     1002a9e <runtime.malloc+0x13>
 1002a99:	e8 ae ee ff ff       	callq  100194c <runtime.morestack8>
 1002a9e:	48 83 ec 20          	sub    $0x20,%rsp
{
	return runtime·mallocgc(size, 0, 0, 1);
 1002aa2:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 1002aa7:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002aab:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
 1002ab2:	00 
 1002ab3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
 1002aba:	00 
 1002abb:	b9 01 00 00 00       	mov    $0x1,%ecx
 1002ac0:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1002ac4:	e8 3e fc ff ff       	callq  1002707 <runtime.mallocgc>
 1002ac9:	48 83 c4 20          	add    $0x20,%rsp
 1002acd:	c3                   	retq   

0000000001002ace <runtime.free>:
}

// Free the object whose base pointer is v.
void
runtime·free(void *v)
 1002ace:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002ad5:	ff ff 
 1002ad7:	48 3b 21             	cmp    (%rcx),%rsp
 1002ada:	77 05                	ja     1002ae1 <runtime.free+0x13>
 1002adc:	e8 6b ee ff ff       	callq  100194c <runtime.morestack8>
 1002ae1:	48 83 ec 58          	sub    $0x58,%rsp
	MSpan *s;
	MCache *c;
	uint32 prof;
	uintptr size;

	if(v == nil)
 1002ae5:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
 1002aeb:	75 05                	jne    1002af2 <runtime.free+0x24>
		return;
 1002aed:	48 83 c4 58          	add    $0x58,%rsp
 1002af1:	c3                   	retq   
	
	// If you change this also change mgc0.c:/^sweepspan,
	// which has a copy of the guts of free.

	if(m->mallocing)
 1002af2:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002af9:	ff ff 
 1002afb:	8b 40 7c             	mov    0x7c(%rax),%eax
 1002afe:	83 f8 00             	cmp    $0x0,%eax
 1002b01:	74 0e                	je     1002b11 <runtime.free+0x43>
		runtime·throw("malloc/free - deadlock");
 1002b03:	b8 63 43 02 01       	mov    $0x1024363,%eax
 1002b08:	48 89 04 24          	mov    %rax,(%rsp)
 1002b0c:	e8 28 72 00 00       	callq  1009d39 <runtime.throw>
	m->mallocing = 1;
 1002b11:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002b18:	ff ff 
 1002b1a:	c7 40 7c 01 00 00 00 	movl   $0x1,0x7c(%rax)

	if(!runtime·mlookup(v, nil, nil, &s)) {
 1002b21:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
 1002b26:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002b2a:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
 1002b31:	00 00 
 1002b33:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 1002b3a:	00 00 
 1002b3c:	48 8d 4c 24 48       	lea    0x48(%rsp),%rcx
 1002b41:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 1002b46:	e8 95 01 00 00       	callq  1002ce0 <runtime.mlookup>
 1002b4b:	83 f8 00             	cmp    $0x0,%eax
 1002b4e:	75 26                	jne    1002b76 <runtime.free+0xa8>
		runtime·printf("free %p: not an allocated block\n", v);
 1002b50:	b8 7a 43 02 01       	mov    $0x102437a,%eax
 1002b55:	48 89 04 24          	mov    %rax,(%rsp)
 1002b59:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1002b5e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1002b63:	e8 d6 47 00 00       	callq  100733e <runtime.printf>
		runtime·throw("free runtime·mlookup");
 1002b68:	b8 9b 43 02 01       	mov    $0x102439b,%eax
 1002b6d:	48 89 04 24          	mov    %rax,(%rsp)
 1002b71:	e8 c3 71 00 00       	callq  1009d39 <runtime.throw>
	}
	prof = runtime·blockspecial(v);
 1002b76:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
 1002b7b:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002b7f:	e8 43 2f 00 00       	callq  1005ac7 <runtime.blockspecial>
 1002b84:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
 1002b89:	0f b6 c0             	movzbl %al,%eax
 1002b8c:	89 44 24 3c          	mov    %eax,0x3c(%rsp)

	// Find size class for v.
	sizeclass = s->sizeclass;
 1002b90:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002b95:	8b 50 34             	mov    0x34(%rax),%edx
	c = m->mcache;
 1002b98:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002b9f:	ff ff 
 1002ba1:	48 8b 80 d8 00 00 00 	mov    0xd8(%rax),%rax
 1002ba8:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
	if(sizeclass == 0) {
 1002bad:	83 fa 00             	cmp    $0x0,%edx
 1002bb0:	0f 85 b7 00 00 00    	jne    1002c6d <runtime.free+0x19f>
		// Large object.
		size = s->npages<<PageShift;
 1002bb6:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002bbb:	48 8b 40 20          	mov    0x20(%rax),%rax
 1002bbf:	48 c1 e0 0c          	shl    $0xc,%rax
 1002bc3:	48 89 c1             	mov    %rax,%rcx
		*(uintptr*)(s->start<<PageShift) = 1;	// mark as "needs to be zeroed"
 1002bc6:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002bcb:	48 8b 40 18          	mov    0x18(%rax),%rax
 1002bcf:	48 c1 e0 0c          	shl    $0xc,%rax
 1002bd3:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
		// Must mark v freed before calling unmarkspan and MHeap_Free:
		// they might coalesce v into other spans and change the bitmap further.
		runtime·markfreed(v, size);
 1002bda:	48 89 1c 24          	mov    %rbx,(%rsp)
 1002bde:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
 1002be3:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1002be8:	e8 ed 2a 00 00       	callq  10056da <runtime.markfreed>
		runtime·unmarkspan(v, 1<<PageShift);
 1002bed:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1002bf2:	48 89 04 24          	mov    %rax,(%rsp)
 1002bf6:	48 c7 c0 00 10 00 00 	mov    $0x1000,%rax
 1002bfd:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1002c02:	e8 ad 2d 00 00       	callq  10059b4 <runtime.unmarkspan>
		runtime·MHeap_Free(&runtime·mheap, s, 1);
 1002c07:	b8 80 a0 03 01       	mov    $0x103a080,%eax
 1002c0c:	48 89 04 24          	mov    %rax,(%rsp)
 1002c10:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1002c15:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1002c1a:	b8 01 00 00 00       	mov    $0x1,%eax
 1002c1f:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1002c23:	e8 d6 38 00 00       	callq  10064fe <runtime.MHeap_Free>
		// and change the bitmap further.
		runtime·markfreed(v, size);
		c->local_by_size[sizeclass].nfree++;
		runtime·MCache_Free(c, v, sizeclass, size);
	}
	c->local_alloc -= size;
 1002c28:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 1002c2d:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1002c32:	48 29 88 e8 03 00 00 	sub    %rcx,0x3e8(%rax)
	if(prof)
 1002c39:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%rsp)
 1002c3e:	74 18                	je     1002c58 <runtime.free+0x18a>
		runtime·MProf_Free(v, size);
 1002c40:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1002c45:	48 89 04 24          	mov    %rax,(%rsp)
 1002c49:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1002c4e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1002c53:	e8 d1 42 00 00       	callq  1006f29 <runtime.MProf_Free>
	m->mallocing = 0;
 1002c58:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002c5f:	ff ff 
 1002c61:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
 1002c68:	48 83 c4 58          	add    $0x58,%rsp
 1002c6c:	c3                   	retq   
		runtime·markfreed(v, size);
		runtime·unmarkspan(v, 1<<PageShift);
		runtime·MHeap_Free(&runtime·mheap, s, 1);
	} else {
		// Small object.
		size = runtime·class_to_size[sizeclass];
 1002c6d:	89 54 24 54          	mov    %edx,0x54(%rsp)
 1002c71:	48 63 ca             	movslq %edx,%rcx
 1002c74:	8b 0c 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%ecx
 1002c7b:	48 63 c9             	movslq %ecx,%rcx
		if(size > sizeof(uintptr))
 1002c7e:	48 83 f9 08          	cmp    $0x8,%rcx
 1002c82:	76 08                	jbe    1002c8c <runtime.free+0x1be>
			((uintptr*)v)[1] = 1;	// mark as "needs to be zeroed"
 1002c84:	48 c7 43 08 01 00 00 	movq   $0x1,0x8(%rbx)
 1002c8b:	00 
		// Must mark v freed before calling MCache_Free:
		// it might coalesce v and other blocks into a bigger span
		// and change the bitmap further.
		runtime·markfreed(v, size);
 1002c8c:	48 89 1c 24          	mov    %rbx,(%rsp)
 1002c90:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
 1002c95:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1002c9a:	e8 3b 2a 00 00       	callq  10056da <runtime.markfreed>
 1002c9f:	8b 6c 24 54          	mov    0x54(%rsp),%ebp
 1002ca3:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
		c->local_by_size[sizeclass].nfree++;
 1002ca8:	48 63 cd             	movslq %ebp,%rcx
 1002cab:	48 c1 e1 04          	shl    $0x4,%rcx
 1002caf:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
 1002cb3:	48 ff 80 20 04 00 00 	incq   0x420(%rax)
		runtime·MCache_Free(c, v, sizeclass, size);
 1002cba:	48 89 1c 24          	mov    %rbx,(%rsp)
 1002cbe:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1002cc3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1002cc8:	89 6c 24 10          	mov    %ebp,0x10(%rsp)
 1002ccc:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1002cd1:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1002cd6:	e8 19 08 00 00       	callq  10034f4 <runtime.MCache_Free>
	}
	c->local_alloc -= size;
 1002cdb:	e9 48 ff ff ff       	jmpq   1002c28 <runtime.free+0x15a>

0000000001002ce0 <runtime.mlookup>:
		runtime·MProf_Free(v, size);
	m->mallocing = 0;
}

int32
runtime·mlookup(void *v, byte **base, uintptr *size, MSpan **sp)
 1002ce0:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002ce7:	ff ff 
 1002ce9:	48 3b 21             	cmp    (%rcx),%rsp
 1002cec:	77 05                	ja     1002cf3 <runtime.mlookup+0x13>
 1002cee:	e8 74 ec ff ff       	callq  1001967 <runtime.morestack32>
 1002cf3:	48 83 ec 48          	sub    $0x48,%rsp
{
	uintptr n, i;
	byte *p;
	MSpan *s;

	m->mcache->local_nlookup++;
 1002cf7:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1002cfe:	ff ff 
 1002d00:	48 8b 80 d8 00 00 00 	mov    0xd8(%rax),%rax
 1002d07:	48 ff 80 08 04 00 00 	incq   0x408(%rax)
	s = runtime·MHeap_LookupMaybe(&runtime·mheap, v);
 1002d0e:	b9 80 a0 03 01       	mov    $0x103a080,%ecx
 1002d13:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002d17:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 1002d1c:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1002d21:	e8 13 37 00 00       	callq  1006439 <runtime.MHeap_LookupMaybe>
 1002d26:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
 1002d2b:	4c 8b 44 24 50       	mov    0x50(%rsp),%r8
 1002d30:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
 1002d35:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
 1002d3a:	48 89 c2             	mov    %rax,%rdx
	if(sp)
 1002d3d:	48 83 f9 00          	cmp    $0x0,%rcx
 1002d41:	74 03                	je     1002d46 <runtime.mlookup+0x66>
		*sp = s;
 1002d43:	48 89 11             	mov    %rdx,(%rcx)
	if(s == nil) {
 1002d46:	48 83 fa 00          	cmp    $0x0,%rdx
 1002d4a:	75 40                	jne    1002d8c <runtime.mlookup+0xac>
		runtime·checkfreed(v, 1);
 1002d4c:	4c 89 04 24          	mov    %r8,(%rsp)
 1002d50:	48 c7 c0 01 00 00 00 	mov    $0x1,%rax
 1002d57:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1002d5c:	e8 6f 2a 00 00       	callq  10057d0 <runtime.checkfreed>
 1002d61:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
 1002d66:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
		if(base)
 1002d6b:	48 83 fa 00          	cmp    $0x0,%rdx
 1002d6f:	74 07                	je     1002d78 <runtime.mlookup+0x98>
			*base = nil;
 1002d71:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
		if(size)
 1002d78:	48 83 f9 00          	cmp    $0x0,%rcx
 1002d7c:	74 07                	je     1002d85 <runtime.mlookup+0xa5>
			*size = 0;
 1002d7e:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
		return 0;
 1002d85:	31 c0                	xor    %eax,%eax
 1002d87:	48 83 c4 48          	add    $0x48,%rsp
 1002d8b:	c3                   	retq   
	}

	p = (byte*)((uintptr)s->start<<PageShift);
 1002d8c:	48 8b 42 18          	mov    0x18(%rdx),%rax
 1002d90:	48 c1 e0 0c          	shl    $0xc,%rax
 1002d94:	48 89 c5             	mov    %rax,%rbp
	if(s->sizeclass == 0) {
 1002d97:	8b 42 34             	mov    0x34(%rdx),%eax
 1002d9a:	83 f8 00             	cmp    $0x0,%eax
 1002d9d:	75 24                	jne    1002dc3 <runtime.mlookup+0xe3>
		// Large object.
		if(base)
 1002d9f:	48 83 ff 00          	cmp    $0x0,%rdi
 1002da3:	74 03                	je     1002da8 <runtime.mlookup+0xc8>
			*base = p;
 1002da5:	48 89 2f             	mov    %rbp,(%rdi)
		if(size)
 1002da8:	48 83 fe 00          	cmp    $0x0,%rsi
 1002dac:	74 0b                	je     1002db9 <runtime.mlookup+0xd9>
			*size = s->npages<<PageShift;
 1002dae:	48 8b 42 20          	mov    0x20(%rdx),%rax
 1002db2:	48 c1 e0 0c          	shl    $0xc,%rax
 1002db6:	48 89 06             	mov    %rax,(%rsi)
		return 1;
 1002db9:	b8 01 00 00 00       	mov    $0x1,%eax
 1002dbe:	48 83 c4 48          	add    $0x48,%rsp
 1002dc2:	c3                   	retq   
	}

	if((byte*)v >= (byte*)s->limit) {
 1002dc3:	48 8b 42 40          	mov    0x40(%rdx),%rax
 1002dc7:	49 39 c0             	cmp    %rax,%r8
 1002dca:	72 07                	jb     1002dd3 <runtime.mlookup+0xf3>
		// pointers past the last block do not count as pointers.
		return 0;
 1002dcc:	31 c0                	xor    %eax,%eax
 1002dce:	48 83 c4 48          	add    $0x48,%rsp
 1002dd2:	c3                   	retq   
	}

	n = runtime·class_to_size[s->sizeclass];
 1002dd3:	8b 4a 34             	mov    0x34(%rdx),%ecx
 1002dd6:	8b 1c 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%ebx
 1002ddd:	48 63 db             	movslq %ebx,%rbx
	if(base) {
 1002de0:	48 83 ff 00          	cmp    $0x0,%rdi
 1002de4:	74 25                	je     1002e0b <runtime.mlookup+0x12b>
		i = ((byte*)v - p)/n;
 1002de6:	4c 89 c0             	mov    %r8,%rax
 1002de9:	48 29 e8             	sub    %rbp,%rax
 1002dec:	31 d2                	xor    %edx,%edx
 1002dee:	48 f7 f3             	div    %rbx
		*base = p + i*n;
 1002df1:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1002df6:	48 f7 e3             	mul    %rbx
 1002df9:	48 89 c1             	mov    %rax,%rcx
 1002dfc:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 1002e01:	48 89 ea             	mov    %rbp,%rdx
 1002e04:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1002e08:	48 89 07             	mov    %rax,(%rdi)
	}
	if(size)
 1002e0b:	48 83 fe 00          	cmp    $0x0,%rsi
 1002e0f:	74 03                	je     1002e14 <runtime.mlookup+0x134>
		*size = n;
 1002e11:	48 89 1e             	mov    %rbx,(%rsi)

	return 1;
 1002e14:	b8 01 00 00 00       	mov    $0x1,%eax
 1002e19:	48 83 c4 48          	add    $0x48,%rsp
 1002e1d:	c3                   	retq   

0000000001002e1e <runtime.allocmcache>:
}

MCache*
runtime·allocmcache(void)
 1002e1e:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002e25:	ff ff 
 1002e27:	48 3b 21             	cmp    (%rcx),%rsp
 1002e2a:	77 05                	ja     1002e31 <runtime.allocmcache+0x13>
 1002e2c:	e8 c2 ea ff ff       	callq  10018f3 <runtime.morestack00>
 1002e31:	48 83 ec 20          	sub    $0x20,%rsp
{
	MCache *c;

	runtime·lock(&runtime·mheap);
 1002e35:	b8 80 a0 03 01       	mov    $0x103a080,%eax
 1002e3a:	48 89 04 24          	mov    %rax,(%rsp)
 1002e3e:	e8 ed 9f 00 00       	callq  100ce30 <runtime.lock>
	c = runtime·FixAlloc_Alloc(&runtime·mheap.cachealloc);
 1002e43:	b9 50 11 04 03       	mov    $0x3041150,%ecx
 1002e48:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002e4c:	e8 3a 13 00 00       	callq  100418b <runtime.FixAlloc_Alloc>
 1002e51:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
	mstats.mcache_inuse = runtime·mheap.cachealloc.inuse;
 1002e56:	48 8b 04 25 88 11 04 	mov    0x3041188,%rax
 1002e5d:	03 
 1002e5e:	48 89 04 25 d0 62 02 	mov    %rax,0x10262d0
 1002e65:	01 
	mstats.mcache_sys = runtime·mheap.cachealloc.sys;
 1002e66:	48 8b 04 25 90 11 04 	mov    0x3041190,%rax
 1002e6d:	03 
 1002e6e:	48 89 04 25 d8 62 02 	mov    %rax,0x10262d8
 1002e75:	01 
	runtime·unlock(&runtime·mheap);
 1002e76:	b8 80 a0 03 01       	mov    $0x103a080,%eax
 1002e7b:	48 89 04 24          	mov    %rax,(%rsp)
 1002e7f:	e8 fe 9f 00 00       	callq  100ce82 <runtime.unlock>
	return c;
 1002e84:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 1002e89:	48 83 c4 20          	add    $0x20,%rsp
 1002e8d:	c3                   	retq   

0000000001002e8e <runtime.purgecachedstats>:
}

void
runtime·purgecachedstats(M* m)
 1002e8e:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002e95:	ff ff 
 1002e97:	48 3b 21             	cmp    (%rcx),%rsp
 1002e9a:	77 05                	ja     1002ea1 <runtime.purgecachedstats+0x13>
 1002e9c:	e8 ab ea ff ff       	callq  100194c <runtime.morestack8>
 1002ea1:	48 83 ec 10          	sub    $0x10,%rsp
{
	MCache *c;

	// Protected by either heap or GC lock.
	c = m->mcache;
 1002ea5:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 1002eaa:	48 8b 88 d8 00 00 00 	mov    0xd8(%rax),%rcx
	mstats.heap_alloc += c->local_cachealloc;
 1002eb1:	48 8b 81 d8 03 00 00 	mov    0x3d8(%rcx),%rax
 1002eb8:	48 01 04 25 88 62 02 	add    %rax,0x1026288
 1002ebf:	01 
	c->local_cachealloc = 0;
 1002ec0:	48 c7 81 d8 03 00 00 	movq   $0x0,0x3d8(%rcx)
 1002ec7:	00 00 00 00 
	mstats.heap_objects += c->local_objects;
 1002ecb:	48 8b 81 e0 03 00 00 	mov    0x3e0(%rcx),%rax
 1002ed2:	48 01 04 25 a8 62 02 	add    %rax,0x10262a8
 1002ed9:	01 
	c->local_objects = 0;
 1002eda:	48 c7 81 e0 03 00 00 	movq   $0x0,0x3e0(%rcx)
 1002ee1:	00 00 00 00 
	mstats.nmalloc += c->local_nmalloc;
 1002ee5:	48 8b 81 f8 03 00 00 	mov    0x3f8(%rcx),%rax
 1002eec:	48 01 04 25 78 62 02 	add    %rax,0x1026278
 1002ef3:	01 
	c->local_nmalloc = 0;
 1002ef4:	48 c7 81 f8 03 00 00 	movq   $0x0,0x3f8(%rcx)
 1002efb:	00 00 00 00 
	mstats.nfree += c->local_nfree;
 1002eff:	48 8b 81 00 04 00 00 	mov    0x400(%rcx),%rax
 1002f06:	48 01 04 25 80 62 02 	add    %rax,0x1026280
 1002f0d:	01 
	c->local_nfree = 0;
 1002f0e:	48 c7 81 00 04 00 00 	movq   $0x0,0x400(%rcx)
 1002f15:	00 00 00 00 
	mstats.nlookup += c->local_nlookup;
 1002f19:	48 8b 81 08 04 00 00 	mov    0x408(%rcx),%rax
 1002f20:	48 01 04 25 70 62 02 	add    %rax,0x1026270
 1002f27:	01 
	c->local_nlookup = 0;
 1002f28:	48 c7 81 08 04 00 00 	movq   $0x0,0x408(%rcx)
 1002f2f:	00 00 00 00 
	mstats.alloc += c->local_alloc;
 1002f33:	48 8b 81 e8 03 00 00 	mov    0x3e8(%rcx),%rax
 1002f3a:	48 01 04 25 58 62 02 	add    %rax,0x1026258
 1002f41:	01 
	c->local_alloc= 0;
 1002f42:	48 c7 81 e8 03 00 00 	movq   $0x0,0x3e8(%rcx)
 1002f49:	00 00 00 00 
	mstats.total_alloc += c->local_total_alloc;
 1002f4d:	48 8b 81 f0 03 00 00 	mov    0x3f0(%rcx),%rax
 1002f54:	48 01 04 25 60 62 02 	add    %rax,0x1026260
 1002f5b:	01 
	c->local_total_alloc= 0;
 1002f5c:	48 c7 81 f0 03 00 00 	movq   $0x0,0x3f0(%rcx)
 1002f63:	00 00 00 00 
 1002f67:	48 83 c4 10          	add    $0x10,%rsp
 1002f6b:	c3                   	retq   

0000000001002f6c <runtime.mallocinit>:
uintptr runtime·sizeof_C_MStats = sizeof(MStats);

#define MaxArena32 (2U<<30)

void
runtime·mallocinit(void)
 1002f6c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1002f73:	ff ff 
 1002f75:	48 3b 21             	cmp    (%rcx),%rsp
 1002f78:	77 05                	ja     1002f7f <runtime.mallocinit+0x13>
 1002f7a:	e8 74 e9 ff ff       	callq  10018f3 <runtime.morestack00>
 1002f7f:	48 83 ec 38          	sub    $0x38,%rsp
{
	byte *p;
	uintptr arena_size, bitmap_size;
	extern byte end[];

	runtime·InitSizes();
 1002f83:	e8 9f 40 00 00       	callq  1007027 <runtime.InitSizes>
		// that matched a memory address.
		//
		// Actually we reserve 17 GB (because the bitmap ends up being 1 GB)
		// but it hardly matters: fc is not valid UTF-8 either, and we have to
		// allocate 15 GB before we get that far.
		arena_size = 16LL<<30;
 1002f88:	48 ba 00 00 00 00 04 	movabs $0x400000000,%rdx
 1002f8f:	00 00 00 
		bitmap_size = arena_size / (sizeof(void*)*8/4);
 1002f92:	48 89 d0             	mov    %rdx,%rax
 1002f95:	48 c1 e8 04          	shr    $0x4,%rax
		p = runtime·SysReserve((void*)(0x00f8ULL<<32), bitmap_size + arena_size);
 1002f99:	48 b9 00 00 00 00 f8 	movabs $0xf800000000,%rcx
 1002fa0:	00 00 00 
 1002fa3:	48 89 0c 24          	mov    %rcx,(%rsp)
 1002fa7:	48 89 c1             	mov    %rax,%rcx
 1002faa:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1002faf:	48 01 d1             	add    %rdx,%rcx
 1002fb2:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
 1002fb7:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1002fbc:	e8 b1 0d 00 00       	callq  1003d72 <runtime.SysReserve>
 1002fc1:	48 89 c2             	mov    %rax,%rdx
		if(p == nil)
 1002fc4:	48 83 f8 00          	cmp    $0x0,%rax
 1002fc8:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
 1002fcd:	75 13                	jne    1002fe2 <runtime.mallocinit+0x76>
			runtime·throw("runtime: cannot reserve arena virtual address space");
 1002fcf:	b8 b1 43 02 01       	mov    $0x10243b1,%eax
 1002fd4:	48 89 04 24          	mov    %rax,(%rsp)
 1002fd8:	e8 5c 6d 00 00       	callq  1009d39 <runtime.throw>
 1002fdd:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
		// Run with what we get back.
		p = runtime·SysReserve(end, bitmap_size + arena_size);
		if(p == nil)
			runtime·throw("runtime: cannot reserve arena virtual address space");
	}
	if((uintptr)p & (((uintptr)1<<PageShift)-1))
 1002fe2:	48 89 d0             	mov    %rdx,%rax
 1002fe5:	48 25 ff 0f 00 00    	and    $0xfff,%rax
 1002feb:	48 83 f8 00          	cmp    $0x0,%rax
 1002fef:	74 13                	je     1003004 <runtime.mallocinit+0x98>
		runtime·throw("runtime: SysReserve returned unaligned address");
 1002ff1:	b8 e5 43 02 01       	mov    $0x10243e5,%eax
 1002ff6:	48 89 04 24          	mov    %rax,(%rsp)
 1002ffa:	e8 3a 6d 00 00       	callq  1009d39 <runtime.throw>
 1002fff:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx

	runtime·mheap.bitmap = p;
 1003004:	48 89 14 25 d8 e8 03 	mov    %rdx,0x303e8d8
 100300b:	03 
	runtime·mheap.arena_start = p + bitmap_size;
 100300c:	48 89 d1             	mov    %rdx,%rcx
 100300f:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
 1003014:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1003018:	48 89 04 25 e8 e8 03 	mov    %rax,0x303e8e8
 100301f:	03 
	runtime·mheap.arena_used = runtime·mheap.arena_start;
 1003020:	48 8b 04 25 e8 e8 03 	mov    0x303e8e8,%rax
 1003027:	03 
 1003028:	48 89 04 25 f0 e8 03 	mov    %rax,0x303e8f0
 100302f:	03 
	runtime·mheap.arena_end = runtime·mheap.arena_start + arena_size;
 1003030:	48 8b 0c 25 e8 e8 03 	mov    0x303e8e8,%rcx
 1003037:	03 
 1003038:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 100303d:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1003041:	48 89 04 25 f8 e8 03 	mov    %rax,0x303e8f8
 1003048:	03 

	// Initialize the rest of the allocator.	
	runtime·MHeap_Init(&runtime·mheap, runtime·SysAlloc);
 1003049:	b8 80 a0 03 01       	mov    $0x103a080,%eax
 100304e:	48 89 04 24          	mov    %rax,(%rsp)
 1003052:	b8 99 3c 00 01       	mov    $0x1003c99,%eax
 1003057:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100305c:	e8 6e 2c 00 00       	callq  1005ccf <runtime.MHeap_Init>
	m->mcache = runtime·allocmcache();
 1003061:	e8 b8 fd ff ff       	callq  1002e1e <runtime.allocmcache>
 1003066:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 100306d:	ff ff 
 100306f:	48 89 81 d8 00 00 00 	mov    %rax,0xd8(%rcx)

	// See if it works.
	runtime·free(runtime·malloc(1));
 1003076:	48 c7 c1 01 00 00 00 	mov    $0x1,%rcx
 100307d:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003081:	e8 05 fa ff ff       	callq  1002a8b <runtime.malloc>
 1003086:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100308b:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
 1003090:	48 89 04 24          	mov    %rax,(%rsp)
 1003094:	e8 35 fa ff ff       	callq  1002ace <runtime.free>
 1003099:	48 83 c4 38          	add    $0x38,%rsp
 100309d:	c3                   	retq   

000000000100309e <runtime.MHeap_SysAlloc>:
}

void*
runtime·MHeap_SysAlloc(MHeap *h, uintptr n)
 100309e:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10030a5:	ff ff 
 10030a7:	48 3b 21             	cmp    (%rcx),%rsp
 10030aa:	77 05                	ja     10030b1 <runtime.MHeap_SysAlloc+0x13>
 10030ac:	e8 a4 e8 ff ff       	callq  1001955 <runtime.morestack16>
 10030b1:	48 83 ec 28          	sub    $0x28,%rsp
 10030b5:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
 10030ba:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
{
	byte *p;

	if(n <= h->arena_end - h->arena_used) {
 10030bf:	48 89 d0             	mov    %rdx,%rax
 10030c2:	48 05 78 48 00 02    	add    $0x2004878,%rax
 10030c8:	48 8b 00             	mov    (%rax),%rax
 10030cb:	48 89 d1             	mov    %rdx,%rcx
 10030ce:	48 81 c1 70 48 00 02 	add    $0x2004870,%rcx
 10030d5:	48 8b 09             	mov    (%rcx),%rcx
 10030d8:	48 29 c8             	sub    %rcx,%rax
 10030db:	48 39 c3             	cmp    %rax,%rbx
 10030de:	77 48                	ja     1003128 <runtime.MHeap_SysAlloc+0x8a>
		// Keep taking from our reservation.
		p = h->arena_used;
 10030e0:	48 89 d0             	mov    %rdx,%rax
 10030e3:	48 05 70 48 00 02    	add    $0x2004870,%rax
 10030e9:	48 8b 08             	mov    (%rax),%rcx
		runtime·SysMap(p, n);
 10030ec:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 10030f1:	48 89 0c 24          	mov    %rcx,(%rsp)
 10030f5:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 10030fa:	e8 94 0c 00 00       	callq  1003d93 <runtime.SysMap>
 10030ff:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
		h->arena_used += n;
 1003104:	48 89 d0             	mov    %rdx,%rax
 1003107:	48 05 70 48 00 02    	add    $0x2004870,%rax
 100310d:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 1003112:	48 01 08             	add    %rcx,(%rax)
		runtime·MHeap_MapBits(h);
 1003115:	48 89 14 24          	mov    %rdx,(%rsp)
 1003119:	e8 c0 2a 00 00       	callq  1005bde <runtime.MHeap_MapBits>
		return p;
 100311e:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1003123:	48 83 c4 28          	add    $0x28,%rsp
 1003127:	c3                   	retq   
	}
	
	// On 64-bit, our reservation is all we have.
	if(sizeof(void*) == 8)
		return nil;
 1003128:	48 31 c0             	xor    %rax,%rax
 100312b:	48 83 c4 28          	add    $0x28,%rsp
 100312f:	c3                   	retq   

0000000001003130 <runtime.mal>:
}

// Runtime stubs.

void*
runtime·mal(uintptr n)
 1003130:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003137:	ff ff 
 1003139:	48 3b 21             	cmp    (%rcx),%rsp
 100313c:	77 05                	ja     1003143 <runtime.mal+0x13>
 100313e:	e8 09 e8 ff ff       	callq  100194c <runtime.morestack8>
 1003143:	48 83 ec 20          	sub    $0x20,%rsp
{
	return runtime·mallocgc(n, 0, 1, 1);
 1003147:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100314c:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003150:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
 1003157:	00 
 1003158:	b9 01 00 00 00       	mov    $0x1,%ecx
 100315d:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 1003161:	b9 01 00 00 00       	mov    $0x1,%ecx
 1003166:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 100316a:	e8 98 f5 ff ff       	callq  1002707 <runtime.mallocgc>
 100316f:	48 83 c4 20          	add    $0x20,%rsp
 1003173:	c3                   	retq   

0000000001003174 <runtime.new>:
}

func new(n uint32) (ret *uint8) {
 1003174:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100317b:	ff ff 
 100317d:	48 3b 21             	cmp    (%rcx),%rsp
 1003180:	77 05                	ja     1003187 <runtime.new+0x13>
 1003182:	e8 ce e7 ff ff       	callq  1001955 <runtime.morestack16>
 1003187:	48 83 ec 10          	sub    $0x10,%rsp
	ret = runtime·mal(n);
 100318b:	8b 4c 24 18          	mov    0x18(%rsp),%ecx
 100318f:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003193:	e8 98 ff ff ff       	callq  1003130 <runtime.mal>
 1003198:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
}
 100319d:	48 83 c4 10          	add    $0x10,%rsp
 10031a1:	c3                   	retq   

00000000010031a2 <runtime.stackalloc>:

void*
runtime·stackalloc(uint32 n)
 10031a2:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10031a9:	ff ff 
 10031ab:	48 3b 21             	cmp    (%rcx),%rsp
 10031ae:	77 05                	ja     10031b5 <runtime.stackalloc+0x13>
 10031b0:	e8 97 e7 ff ff       	callq  100194c <runtime.morestack8>
 10031b5:	48 83 ec 20          	sub    $0x20,%rsp
 10031b9:	8b 54 24 28          	mov    0x28(%rsp),%edx
{
	// Stackalloc must be called on scheduler stack, so that we
	// never try to grow the stack during the code that stackalloc runs.
	// Doing so would cause a deadlock (issue 1547).
	if(g != m->g0)
 10031bd:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10031c4:	ff ff 
 10031c6:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 10031cd:	ff ff 
 10031cf:	48 8b 09             	mov    (%rcx),%rcx
 10031d2:	48 39 c8             	cmp    %rcx,%rax
 10031d5:	74 12                	je     10031e9 <runtime.stackalloc+0x47>
		runtime·throw("stackalloc not on scheduler stack");
 10031d7:	b8 49 44 02 01       	mov    $0x1024449,%eax
 10031dc:	48 89 04 24          	mov    %rax,(%rsp)
 10031e0:	e8 54 6b 00 00       	callq  1009d39 <runtime.throw>
 10031e5:	8b 54 24 28          	mov    0x28(%rsp),%edx
	// we have to do something else to avoid deadlock.
	// In that case, we fall back on a fixed-size free-list
	// allocator, assuming that inside malloc all the stack
	// frames are small, so that all the stack allocations
	// will be a single size, the minimum (right now, 5k).
	if(m->mallocing || m->gcing || n == FixedStack) {
 10031e9:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10031f0:	ff ff 
 10031f2:	8b 40 7c             	mov    0x7c(%rax),%eax
 10031f5:	83 f8 00             	cmp    $0x0,%eax
 10031f8:	75 14                	jne    100320e <runtime.stackalloc+0x6c>
 10031fa:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1003201:	ff ff 
 1003203:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
 1003209:	83 f8 00             	cmp    $0x0,%eax
 100320c:	74 4f                	je     100325d <runtime.stackalloc+0xbb>
		if(n != FixedStack) {
 100320e:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
 1003214:	74 29                	je     100323f <runtime.stackalloc+0x9d>
			runtime·printf("stackalloc: in malloc, size=%d want %d", FixedStack, n);
 1003216:	b8 6b 44 02 01       	mov    $0x102446b,%eax
 100321b:	48 89 04 24          	mov    %rax,(%rsp)
 100321f:	b8 00 10 00 00       	mov    $0x1000,%eax
 1003224:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1003228:	89 54 24 0c          	mov    %edx,0xc(%rsp)
 100322c:	e8 0d 41 00 00       	callq  100733e <runtime.printf>
			runtime·throw("stackalloc");
 1003231:	b8 93 44 02 01       	mov    $0x1024493,%eax
 1003236:	48 89 04 24          	mov    %rax,(%rsp)
 100323a:	e8 fa 6a 00 00       	callq  1009d39 <runtime.throw>
		}
		return runtime·FixAlloc_Alloc(m->stackalloc);
 100323f:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 1003246:	ff ff 
 1003248:	48 8b 89 e0 00 00 00 	mov    0xe0(%rcx),%rcx
 100324f:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003253:	e8 33 0f 00 00       	callq  100418b <runtime.FixAlloc_Alloc>
 1003258:	48 83 c4 20          	add    $0x20,%rsp
 100325c:	c3                   	retq   
	// we have to do something else to avoid deadlock.
	// In that case, we fall back on a fixed-size free-list
	// allocator, assuming that inside malloc all the stack
	// frames are small, so that all the stack allocations
	// will be a single size, the minimum (right now, 5k).
	if(m->mallocing || m->gcing || n == FixedStack) {
 100325d:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
 1003263:	74 a9                	je     100320e <runtime.stackalloc+0x6c>
			runtime·printf("stackalloc: in malloc, size=%d want %d", FixedStack, n);
			runtime·throw("stackalloc");
		}
		return runtime·FixAlloc_Alloc(m->stackalloc);
	}
	return runtime·mallocgc(n, FlagNoProfiling|FlagNoGC, 0, 0);
 1003265:	48 89 14 24          	mov    %rdx,(%rsp)
 1003269:	b9 06 00 00 00       	mov    $0x6,%ecx
 100326e:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1003272:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
 1003279:	00 
 100327a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
 1003281:	00 
 1003282:	e8 80 f4 ff ff       	callq  1002707 <runtime.mallocgc>
 1003287:	48 83 c4 20          	add    $0x20,%rsp
 100328b:	c3                   	retq   

000000000100328c <runtime.stackfree>:
}

void
runtime·stackfree(void *v, uintptr n)
 100328c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003293:	ff ff 
 1003295:	48 3b 21             	cmp    (%rcx),%rsp
 1003298:	77 05                	ja     100329f <runtime.stackfree+0x13>
 100329a:	e8 b6 e6 ff ff       	callq  1001955 <runtime.morestack16>
 100329f:	48 83 ec 18          	sub    $0x18,%rsp
 10032a3:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
{
	if(m->mallocing || m->gcing || n == FixedStack) {
 10032a8:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10032af:	ff ff 
 10032b1:	8b 40 7c             	mov    0x7c(%rax),%eax
 10032b4:	83 f8 00             	cmp    $0x0,%eax
 10032b7:	75 14                	jne    10032cd <runtime.stackfree+0x41>
 10032b9:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10032c0:	ff ff 
 10032c2:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
 10032c8:	83 f8 00             	cmp    $0x0,%eax
 10032cb:	74 23                	je     10032f0 <runtime.stackfree+0x64>
		runtime·FixAlloc_Free(m->stackalloc, v);
 10032cd:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10032d4:	ff ff 
 10032d6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
 10032dd:	48 89 04 24          	mov    %rax,(%rsp)
 10032e1:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10032e6:	e8 7e 0f 00 00       	callq  1004269 <runtime.FixAlloc_Free>
		return;
 10032eb:	48 83 c4 18          	add    $0x18,%rsp
 10032ef:	c3                   	retq   
}

void
runtime·stackfree(void *v, uintptr n)
{
	if(m->mallocing || m->gcing || n == FixedStack) {
 10032f0:	48 81 7c 24 28 00 10 	cmpq   $0x1000,0x28(%rsp)
 10032f7:	00 00 
 10032f9:	74 d2                	je     10032cd <runtime.stackfree+0x41>
 10032fb:	48 89 0c 24          	mov    %rcx,(%rsp)
 10032ff:	e8 ca f7 ff ff       	callq  1002ace <runtime.free>
 1003304:	48 83 c4 18          	add    $0x18,%rsp
 1003308:	c3                   	retq   

0000000001003309 <runtime.MCache_Alloc>:

#include "runtime.h"
#include "malloc.h"

void*
runtime·MCache_Alloc(MCache *c, int32 sizeclass, uintptr size, int32 zeroed)
 1003309:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003310:	ff ff 
 1003312:	48 3b 21             	cmp    (%rcx),%rsp
 1003315:	77 05                	ja     100331c <runtime.MCache_Alloc+0x13>
 1003317:	e8 4b e6 ff ff       	callq  1001967 <runtime.morestack32>
 100331c:	48 83 ec 48          	sub    $0x48,%rsp
 1003320:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
 1003325:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
 100332a:	8b 6c 24 58          	mov    0x58(%rsp),%ebp
	MCacheList *l;
	MLink *first, *v;
	int32 n;

	// Allocate from list.
	l = &c->list[sizeclass];
 100332e:	48 63 cd             	movslq %ebp,%rcx
 1003331:	48 c1 e1 04          	shl    $0x4,%rcx
 1003335:	48 8d 04 0f          	lea    (%rdi,%rcx,1),%rax
 1003339:	48 89 c3             	mov    %rax,%rbx
	if(l->list == nil) {
 100333c:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
 1003341:	48 8b 00             	mov    (%rax),%rax
 1003344:	48 83 f8 00          	cmp    $0x0,%rax
 1003348:	0f 85 86 00 00 00    	jne    10033d4 <runtime.MCache_Alloc+0xcb>
		// Replenish using central lists.
		n = runtime·MCentral_AllocList(&runtime·mheap.central[sizeclass],
 100334e:	48 63 d5             	movslq %ebp,%rdx
 1003351:	48 69 d2 a8 00 00 00 	imul   $0xa8,%rdx,%rdx
 1003358:	48 8d 0c 15 00 e9 03 	lea    0x303e900(,%rdx,1),%rcx
 100335f:	03 
 1003360:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003364:	48 63 d5             	movslq %ebp,%rdx
 1003367:	8b 0c 95 d0 52 02 01 	mov    0x10252d0(,%rdx,4),%ecx
 100336e:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1003372:	48 8d 4c 24 38       	lea    0x38(%rsp),%rcx
 1003377:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100337c:	e8 3b 03 00 00       	callq  10036bc <runtime.MCentral_AllocList>
 1003381:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
 1003386:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
 100338b:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
 1003390:	89 c5                	mov    %eax,%ebp
			runtime·class_to_transfercount[sizeclass], &first);
		if(n == 0)
 1003392:	83 f8 00             	cmp    $0x0,%eax
 1003395:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
 1003399:	75 21                	jne    10033bc <runtime.MCache_Alloc+0xb3>
			runtime·throw("out of memory");
 100339b:	b8 40 30 02 01       	mov    $0x1023040,%eax
 10033a0:	48 89 04 24          	mov    %rax,(%rsp)
 10033a4:	e8 90 69 00 00       	callq  1009d39 <runtime.throw>
 10033a9:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
 10033ae:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
 10033b3:	8b 6c 24 2c          	mov    0x2c(%rsp),%ebp
 10033b7:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
		l->list = first;
 10033bc:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 10033c1:	48 89 0b             	mov    %rcx,(%rbx)
		l->nlist = n;
 10033c4:	89 6b 08             	mov    %ebp,0x8(%rbx)
		c->size += n*size;
 10033c7:	48 63 c5             	movslq %ebp,%rax
 10033ca:	48 f7 e6             	mul    %rsi
 10033cd:	48 01 87 d0 03 00 00 	add    %rax,0x3d0(%rdi)
	}
	v = l->list;
 10033d4:	48 8b 13             	mov    (%rbx),%rdx
	l->list = v->next;
 10033d7:	48 8b 0a             	mov    (%rdx),%rcx
 10033da:	48 89 0b             	mov    %rcx,(%rbx)
	l->nlist--;
 10033dd:	ff 4b 08             	decl   0x8(%rbx)
	if(l->nlist < l->nlistmin)
 10033e0:	8b 43 08             	mov    0x8(%rbx),%eax
 10033e3:	8b 4b 0c             	mov    0xc(%rbx),%ecx
 10033e6:	39 c8                	cmp    %ecx,%eax
 10033e8:	73 06                	jae    10033f0 <runtime.MCache_Alloc+0xe7>
		l->nlistmin = l->nlist;
 10033ea:	8b 4b 08             	mov    0x8(%rbx),%ecx
 10033ed:	89 4b 0c             	mov    %ecx,0xc(%rbx)
	c->size -= size;
 10033f0:	48 29 b7 d0 03 00 00 	sub    %rsi,0x3d0(%rdi)

	// v is zeroed except for the link pointer
	// that we used above; zero that.
	v->next = nil;
 10033f7:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
	if(zeroed) {
 10033fe:	83 7c 24 68 00       	cmpl   $0x0,0x68(%rsp)
 1003403:	74 17                	je     100341c <runtime.MCache_Alloc+0x113>
		// block is zeroed iff second word is zero ...
		if(size > sizeof(uintptr) && ((uintptr*)v)[1] != 0)
 1003405:	48 83 fe 08          	cmp    $0x8,%rsi
 1003409:	76 0a                	jbe    1003415 <runtime.MCache_Alloc+0x10c>
 100340b:	48 8b 42 08          	mov    0x8(%rdx),%rax
 100340f:	48 83 f8 00          	cmp    $0x0,%rax
 1003413:	75 1d                	jne    1003432 <runtime.MCache_Alloc+0x129>
			runtime·memclr((byte*)v, size);
		else {
			// ... except for the link pointer
			// that we used above; zero that.
			v->next = nil;
 1003415:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
		}
	}
	c->local_cachealloc += size;
 100341c:	48 01 b7 d8 03 00 00 	add    %rsi,0x3d8(%rdi)
	c->local_objects++;
 1003423:	48 ff 87 e0 03 00 00 	incq   0x3e0(%rdi)
	return v;
 100342a:	48 89 d0             	mov    %rdx,%rax
 100342d:	48 83 c4 48          	add    $0x48,%rsp
 1003431:	c3                   	retq   
	// that we used above; zero that.
	v->next = nil;
	if(zeroed) {
		// block is zeroed iff second word is zero ...
		if(size > sizeof(uintptr) && ((uintptr*)v)[1] != 0)
			runtime·memclr((byte*)v, size);
 1003432:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
 1003437:	48 89 14 24          	mov    %rdx,(%rsp)
 100343b:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
 1003440:	e8 62 e6 ff ff       	callq  1001aa7 <runtime.memclr>
 1003445:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
 100344a:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
 100344f:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
			// ... except for the link pointer
			// that we used above; zero that.
			v->next = nil;
		}
	}
	c->local_cachealloc += size;
 1003454:	eb c6                	jmp    100341c <runtime.MCache_Alloc+0x113>

0000000001003456 <ReleaseN>:
	return v;
}

// Take n elements off l and return them to the central free list.
static void
ReleaseN(MCache *c, MCacheList *l, int32 n, int32 sizeclass)
 1003456:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100345d:	ff ff 
 100345f:	48 3b 21             	cmp    (%rcx),%rsp
 1003462:	77 05                	ja     1003469 <ReleaseN+0x13>
 1003464:	e8 f5 e4 ff ff       	callq  100195e <runtime.morestack24>
 1003469:	48 83 ec 40          	sub    $0x40,%rsp
 100346d:	8b 7c 24 5c          	mov    0x5c(%rsp),%edi
 1003471:	8b 6c 24 58          	mov    0x58(%rsp),%ebp
 1003475:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
{
	MLink *first, **lp;
	int32 i;

	// Cut off first n elements.
	first = l->list;
 100347a:	48 8b 33             	mov    (%rbx),%rsi
	lp = &l->list;
 100347d:	48 89 da             	mov    %rbx,%rdx
	for(i=0; i<n; i++)
 1003480:	31 c9                	xor    %ecx,%ecx
 1003482:	39 e9                	cmp    %ebp,%ecx
 1003484:	7d 09                	jge    100348f <ReleaseN+0x39>
		lp = &(*lp)->next;
 1003486:	48 8b 12             	mov    (%rdx),%rdx
	int32 i;

	// Cut off first n elements.
	first = l->list;
	lp = &l->list;
	for(i=0; i<n; i++)
 1003489:	ff c1                	inc    %ecx
 100348b:	39 e9                	cmp    %ebp,%ecx
 100348d:	7c f7                	jl     1003486 <ReleaseN+0x30>
		lp = &(*lp)->next;
	l->list = *lp;
 100348f:	48 8b 0a             	mov    (%rdx),%rcx
 1003492:	48 89 0b             	mov    %rcx,(%rbx)
	*lp = nil;
 1003495:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
	l->nlist -= n;
 100349c:	29 6b 08             	sub    %ebp,0x8(%rbx)
	if(l->nlist < l->nlistmin)
 100349f:	8b 43 08             	mov    0x8(%rbx),%eax
 10034a2:	8b 4b 0c             	mov    0xc(%rbx),%ecx
 10034a5:	39 c8                	cmp    %ecx,%eax
 10034a7:	73 06                	jae    10034af <ReleaseN+0x59>
		l->nlistmin = l->nlist;
 10034a9:	8b 4b 08             	mov    0x8(%rbx),%ecx
 10034ac:	89 4b 0c             	mov    %ecx,0xc(%rbx)
	c->size -= n*runtime·class_to_size[sizeclass];
 10034af:	89 e8                	mov    %ebp,%eax
 10034b1:	48 63 cf             	movslq %edi,%rcx
 10034b4:	0f af 04 8d d8 51 02 	imul   0x10251d8(,%rcx,4),%eax
 10034bb:	01 
 10034bc:	48 63 c0             	movslq %eax,%rax
 10034bf:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 10034c4:	48 29 81 d0 03 00 00 	sub    %rax,0x3d0(%rcx)

	// Return them to central free list.
	runtime·MCentral_FreeList(&runtime·mheap.central[sizeclass], n, first);
 10034cb:	48 63 cf             	movslq %edi,%rcx
 10034ce:	48 69 c9 a8 00 00 00 	imul   $0xa8,%rcx,%rcx
 10034d5:	48 8d 04 0d 00 e9 03 	lea    0x303e900(,%rcx,1),%rax
 10034dc:	03 
 10034dd:	48 89 04 24          	mov    %rax,(%rsp)
 10034e1:	89 6c 24 08          	mov    %ebp,0x8(%rsp)
 10034e5:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
 10034ea:	e8 52 03 00 00       	callq  1003841 <runtime.MCentral_FreeList>
 10034ef:	48 83 c4 40          	add    $0x40,%rsp
 10034f3:	c3                   	retq   

00000000010034f4 <runtime.MCache_Free>:
}

void
runtime·MCache_Free(MCache *c, void *v, int32 sizeclass, uintptr size)
 10034f4:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10034fb:	ff ff 
 10034fd:	48 3b 21             	cmp    (%rcx),%rsp
 1003500:	77 05                	ja     1003507 <runtime.MCache_Free+0x13>
 1003502:	e8 60 e4 ff ff       	callq  1001967 <runtime.morestack32>
 1003507:	48 83 ec 40          	sub    $0x40,%rsp
 100350b:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
 1003510:	8b 74 24 58          	mov    0x58(%rsp),%esi
 1003514:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
	int32 i, n;
	MCacheList *l;
	MLink *p;

	// Put back on list.
	l = &c->list[sizeclass];
 1003519:	48 63 ce             	movslq %esi,%rcx
 100351c:	48 c1 e1 04          	shl    $0x4,%rcx
 1003520:	48 89 ea             	mov    %rbp,%rdx
 1003523:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1003527:	48 89 c2             	mov    %rax,%rdx
	p = v;
 100352a:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
	p->next = l->list;
 100352f:	48 8b 08             	mov    (%rax),%rcx
 1003532:	48 89 0b             	mov    %rcx,(%rbx)
	l->list = p;
 1003535:	48 89 18             	mov    %rbx,(%rax)
	l->nlist++;
 1003538:	ff 40 08             	incl   0x8(%rax)
	c->size += size;
 100353b:	48 01 bd d0 03 00 00 	add    %rdi,0x3d0(%rbp)
	c->local_cachealloc -= size;
 1003542:	48 29 bd d8 03 00 00 	sub    %rdi,0x3d8(%rbp)
	c->local_objects--;
 1003549:	48 ff 8d e0 03 00 00 	decq   0x3e0(%rbp)

	if(l->nlist >= MaxMCacheListLen) {
 1003550:	8b 40 08             	mov    0x8(%rax),%eax
 1003553:	3d 00 01 00 00       	cmp    $0x100,%eax
 1003558:	72 25                	jb     100357f <runtime.MCache_Free+0x8b>
		// Release a chunk back.
		ReleaseN(c, l, runtime·class_to_transfercount[sizeclass], sizeclass);
 100355a:	48 89 2c 24          	mov    %rbp,(%rsp)
 100355e:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 1003563:	48 63 ce             	movslq %esi,%rcx
 1003566:	8b 04 8d d0 52 02 01 	mov    0x10252d0(,%rcx,4),%eax
 100356d:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1003571:	89 74 24 14          	mov    %esi,0x14(%rsp)
 1003575:	e8 dc fe ff ff       	callq  1003456 <ReleaseN>
 100357a:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
	}

	if(c->size >= MaxMCacheSize) {
 100357f:	48 8b 85 d0 03 00 00 	mov    0x3d0(%rbp),%rax
 1003586:	48 3d 00 00 20 00    	cmp    $0x200000,%rax
 100358c:	72 6e                	jb     10035fc <runtime.MCache_Free+0x108>
		// Scavenge.
		for(i=0; i<NumSizeClasses; i++) {
 100358e:	31 db                	xor    %ebx,%ebx
 1003590:	83 fb 3d             	cmp    $0x3d,%ebx
 1003593:	7d 67                	jge    10035fc <runtime.MCache_Free+0x108>
			l = &c->list[i];
 1003595:	48 63 cb             	movslq %ebx,%rcx
 1003598:	48 c1 e1 04          	shl    $0x4,%rcx
 100359c:	48 89 ea             	mov    %rbp,%rdx
 100359f:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 10035a3:	48 89 c2             	mov    %rax,%rdx
			n = l->nlistmin;
 10035a6:	8b 48 0c             	mov    0xc(%rax),%ecx
			// n is the minimum number of elements we've seen on
			// the list since the last scavenge.  If n > 0, it means that
			// we could have gotten by with n fewer elements
			// without needing to consult the central free list.
			// Move toward that situation by releasing n/2 of them.
			if(n > 0) {
 10035a9:	83 f9 00             	cmp    $0x0,%ecx
 10035ac:	7e 41                	jle    10035ef <runtime.MCache_Free+0xfb>
				if(n > 1)
 10035ae:	83 f9 01             	cmp    $0x1,%ecx
 10035b1:	7e 0f                	jle    10035c2 <runtime.MCache_Free+0xce>
					n /= 2;
 10035b3:	89 c8                	mov    %ecx,%eax
 10035b5:	81 f9 00 00 00 80    	cmp    $0x80000000,%ecx
 10035bb:	83 d8 ff             	sbb    $0xffffffffffffffff,%eax
 10035be:	d1 f8                	sar    %eax
 10035c0:	89 c1                	mov    %eax,%ecx
				ReleaseN(c, l, n, i);
 10035c2:	48 89 2c 24          	mov    %rbp,(%rsp)
 10035c6:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
 10035cb:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 10035d0:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 10035d4:	89 5c 24 3c          	mov    %ebx,0x3c(%rsp)
 10035d8:	89 5c 24 14          	mov    %ebx,0x14(%rsp)
 10035dc:	e8 75 fe ff ff       	callq  1003456 <ReleaseN>
 10035e1:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
 10035e6:	8b 5c 24 3c          	mov    0x3c(%rsp),%ebx
 10035ea:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
			}
			l->nlistmin = l->nlist;
 10035ef:	8b 4a 08             	mov    0x8(%rdx),%ecx
 10035f2:	89 4a 0c             	mov    %ecx,0xc(%rdx)
		ReleaseN(c, l, runtime·class_to_transfercount[sizeclass], sizeclass);
	}

	if(c->size >= MaxMCacheSize) {
		// Scavenge.
		for(i=0; i<NumSizeClasses; i++) {
 10035f5:	ff c3                	inc    %ebx
 10035f7:	83 fb 3d             	cmp    $0x3d,%ebx
 10035fa:	7c 99                	jl     1003595 <runtime.MCache_Free+0xa1>
			if(n > 0) {
				if(n > 1)
					n /= 2;
				ReleaseN(c, l, n, i);
			}
			l->nlistmin = l->nlist;
 10035fc:	48 83 c4 40          	add    $0x40,%rsp
 1003600:	c3                   	retq   

0000000001003601 <runtime.MCache_ReleaseAll>:
		}
	}
}

void
runtime·MCache_ReleaseAll(MCache *c)
 1003601:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003608:	ff ff 
 100360a:	48 3b 21             	cmp    (%rcx),%rsp
 100360d:	77 05                	ja     1003614 <runtime.MCache_ReleaseAll+0x13>
 100360f:	e8 38 e3 ff ff       	callq  100194c <runtime.morestack8>
 1003614:	48 83 ec 38          	sub    $0x38,%rsp
 1003618:	48 8b 6c 24 40       	mov    0x40(%rsp),%rbp
{
	int32 i;
	MCacheList *l;

	for(i=0; i<NumSizeClasses; i++) {
 100361d:	31 db                	xor    %ebx,%ebx
 100361f:	83 fb 3d             	cmp    $0x3d,%ebx
 1003622:	7d 4c                	jge    1003670 <runtime.MCache_ReleaseAll+0x6f>
		l = &c->list[i];
 1003624:	48 63 cb             	movslq %ebx,%rcx
 1003627:	48 c1 e1 04          	shl    $0x4,%rcx
 100362b:	48 89 ea             	mov    %rbp,%rdx
 100362e:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
		ReleaseN(c, l, l->nlist, i);
 1003632:	48 89 2c 24          	mov    %rbp,(%rsp)
 1003636:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100363b:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 1003640:	8b 40 08             	mov    0x8(%rax),%eax
 1003643:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1003647:	89 5c 24 34          	mov    %ebx,0x34(%rsp)
 100364b:	89 5c 24 14          	mov    %ebx,0x14(%rsp)
 100364f:	e8 02 fe ff ff       	callq  1003456 <ReleaseN>
 1003654:	48 8b 6c 24 40       	mov    0x40(%rsp),%rbp
 1003659:	8b 5c 24 34          	mov    0x34(%rsp),%ebx
		l->nlistmin = 0;
 100365d:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1003662:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
runtime·MCache_ReleaseAll(MCache *c)
{
	int32 i;
	MCacheList *l;

	for(i=0; i<NumSizeClasses; i++) {
 1003669:	ff c3                	inc    %ebx
 100366b:	83 fb 3d             	cmp    $0x3d,%ebx
 100366e:	7c b4                	jl     1003624 <runtime.MCache_ReleaseAll+0x23>
 1003670:	48 83 c4 38          	add    $0x38,%rsp
 1003674:	c3                   	retq   

0000000001003675 <runtime.MCentral_Init>:
static void* MCentral_Alloc(MCentral *c);
static void MCentral_Free(MCentral *c, void *v);

// Initialize a single central free list.
void
runtime·MCentral_Init(MCentral *c, int32 sizeclass)
 1003675:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100367c:	ff ff 
 100367e:	48 3b 21             	cmp    (%rcx),%rsp
 1003681:	77 05                	ja     1003688 <runtime.MCentral_Init+0x13>
 1003683:	e8 cd e2 ff ff       	callq  1001955 <runtime.morestack16>
 1003688:	48 83 ec 10          	sub    $0x10,%rsp
 100368c:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
{
	c->sizeclass = sizeclass;
 1003691:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
 1003695:	89 48 08             	mov    %ecx,0x8(%rax)
	runtime·MSpanList_Init(&c->nonempty);
 1003698:	48 83 c0 10          	add    $0x10,%rax
 100369c:	48 89 04 24          	mov    %rax,(%rsp)
 10036a0:	e8 ea 31 00 00       	callq  100688f <runtime.MSpanList_Init>
	runtime·MSpanList_Init(&c->empty);
 10036a5:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 10036aa:	48 83 c0 58          	add    $0x58,%rax
 10036ae:	48 89 04 24          	mov    %rax,(%rsp)
 10036b2:	e8 d8 31 00 00       	callq  100688f <runtime.MSpanList_Init>
 10036b7:	48 83 c4 10          	add    $0x10,%rsp
 10036bb:	c3                   	retq   

00000000010036bc <runtime.MCentral_AllocList>:
// Allocate up to n objects from the central free list.
// Return the number of objects allocated.
// The objects are linked together by their first words.
// On return, *pstart points at the first object and *pend at the last.
int32
runtime·MCentral_AllocList(MCentral *c, int32 n, MLink **pfirst)
 10036bc:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10036c3:	ff ff 
 10036c5:	48 3b 21             	cmp    (%rcx),%rsp
 10036c8:	77 05                	ja     10036cf <runtime.MCentral_AllocList+0x13>
 10036ca:	e8 8f e2 ff ff       	callq  100195e <runtime.morestack24>
 10036cf:	48 83 ec 38          	sub    $0x38,%rsp
{
	MLink *first, *last, *v;
	int32 i;

	runtime·lock(c);
 10036d3:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 10036d8:	48 89 04 24          	mov    %rax,(%rsp)
 10036dc:	e8 4f 97 00 00       	callq  100ce30 <runtime.lock>
	// Replenish central list if empty.
	if(runtime·MSpanList_IsEmpty(&c->nonempty)) {
 10036e1:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 10036e6:	48 83 c1 10          	add    $0x10,%rcx
 10036ea:	48 89 0c 24          	mov    %rcx,(%rsp)
 10036ee:	e8 14 32 00 00       	callq  1006907 <runtime.MSpanList_IsEmpty>
 10036f3:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
 10036f8:	80 f8 00             	cmp    $0x0,%al
 10036fb:	74 2f                	je     100372c <runtime.MCentral_AllocList+0x70>
		if(!MCentral_Grow(c)) {
 10036fd:	48 89 14 24          	mov    %rdx,(%rsp)
 1003701:	e8 7f 03 00 00       	callq  1003a85 <MCentral_Grow>
 1003706:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
 100370b:	80 f8 00             	cmp    $0x0,%al
 100370e:	75 1c                	jne    100372c <runtime.MCentral_AllocList+0x70>
			runtime·unlock(c);
 1003710:	48 89 14 24          	mov    %rdx,(%rsp)
 1003714:	e8 69 97 00 00       	callq  100ce82 <runtime.unlock>
			*pfirst = nil;
 1003719:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 100371e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			return 0;
 1003725:	31 c0                	xor    %eax,%eax
 1003727:	48 83 c4 38          	add    $0x38,%rsp
 100372b:	c3                   	retq   
		}
	}

	// Copy from list, up to n.
	// First one is guaranteed to work, because we just grew the list.
	first = MCentral_Alloc(c);
 100372c:	48 89 14 24          	mov    %rdx,(%rsp)
 1003730:	e8 79 00 00 00       	callq  10037ae <MCentral_Alloc>
 1003735:	48 8b 6c 24 40       	mov    0x40(%rsp),%rbp
	last = first;
 100373a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
 100373f:	48 89 c1             	mov    %rax,%rcx
 1003742:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	for(i=1; i<n && (v = MCentral_Alloc(c)) != nil; i++) {
 1003747:	bb 01 00 00 00       	mov    $0x1,%ebx
 100374c:	89 5c 24 1c          	mov    %ebx,0x1c(%rsp)
 1003750:	3b 5c 24 48          	cmp    0x48(%rsp),%ebx
 1003754:	7d 1d                	jge    1003773 <runtime.MCentral_AllocList+0xb7>
 1003756:	48 89 2c 24          	mov    %rbp,(%rsp)
 100375a:	e8 4f 00 00 00       	callq  10037ae <MCentral_Alloc>
 100375f:	48 8b 6c 24 40       	mov    0x40(%rsp),%rbp
 1003764:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 1003769:	8b 5c 24 1c          	mov    0x1c(%rsp),%ebx
 100376d:	48 83 f8 00          	cmp    $0x0,%rax
 1003771:	75 2c                	jne    100379f <runtime.MCentral_AllocList+0xe3>
		last->next = v;
		last = v;
	}
	last->next = nil;
 1003773:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
	c->nfree -= i;
 100377a:	29 9d a0 00 00 00    	sub    %ebx,0xa0(%rbp)

	runtime·unlock(c);
 1003780:	48 89 2c 24          	mov    %rbp,(%rsp)
 1003784:	e8 f9 96 00 00       	callq  100ce82 <runtime.unlock>
	*pfirst = first;
 1003789:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 100378e:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1003793:	48 89 08             	mov    %rcx,(%rax)
	return i;
 1003796:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
 100379a:	48 83 c4 38          	add    $0x38,%rsp
 100379e:	c3                   	retq   
	// Copy from list, up to n.
	// First one is guaranteed to work, because we just grew the list.
	first = MCentral_Alloc(c);
	last = first;
	for(i=1; i<n && (v = MCentral_Alloc(c)) != nil; i++) {
		last->next = v;
 100379f:	48 89 01             	mov    %rax,(%rcx)
		last = v;
 10037a2:	48 89 c1             	mov    %rax,%rcx
 10037a5:	48 89 44 24 28       	mov    %rax,0x28(%rsp)

	// Copy from list, up to n.
	// First one is guaranteed to work, because we just grew the list.
	first = MCentral_Alloc(c);
	last = first;
	for(i=1; i<n && (v = MCentral_Alloc(c)) != nil; i++) {
 10037aa:	ff c3                	inc    %ebx
 10037ac:	eb 9e                	jmp    100374c <runtime.MCentral_AllocList+0x90>

00000000010037ae <MCentral_Alloc>:
	return i;
}

// Helper: allocate one object from the central free list.
static void*
MCentral_Alloc(MCentral *c)
 10037ae:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10037b5:	ff ff 
 10037b7:	48 3b 21             	cmp    (%rcx),%rsp
 10037ba:	77 05                	ja     10037c1 <MCentral_Alloc+0x13>
 10037bc:	e8 8b e1 ff ff       	callq  100194c <runtime.morestack8>
 10037c1:	48 83 ec 30          	sub    $0x30,%rsp
{
	MSpan *s;
	MLink *v;

	if(runtime·MSpanList_IsEmpty(&c->nonempty))
 10037c5:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 10037ca:	48 83 c1 10          	add    $0x10,%rcx
 10037ce:	48 89 0c 24          	mov    %rcx,(%rsp)
 10037d2:	e8 30 31 00 00       	callq  1006907 <runtime.MSpanList_IsEmpty>
 10037d7:	80 f8 00             	cmp    $0x0,%al
 10037da:	74 08                	je     10037e4 <MCentral_Alloc+0x36>
		return nil;
 10037dc:	48 31 c0             	xor    %rax,%rax
 10037df:	48 83 c4 30          	add    $0x30,%rsp
 10037e3:	c3                   	retq   
	s = c->nonempty.next;
 10037e4:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 10037e9:	48 8b 50 10          	mov    0x10(%rax),%rdx
	s->ref++;
 10037ed:	ff 42 30             	incl   0x30(%rdx)
	v = s->freelist;
 10037f0:	48 8b 5a 28          	mov    0x28(%rdx),%rbx
	s->freelist = v->next;
 10037f4:	48 89 5c 24 20       	mov    %rbx,0x20(%rsp)
 10037f9:	48 8b 0b             	mov    (%rbx),%rcx
 10037fc:	48 89 4a 28          	mov    %rcx,0x28(%rdx)
	if(s->freelist == nil) {
 1003800:	48 8b 42 28          	mov    0x28(%rdx),%rax
 1003804:	48 83 f8 00          	cmp    $0x0,%rax
 1003808:	75 2f                	jne    1003839 <MCentral_Alloc+0x8b>
		runtime·MSpanList_Remove(s);
 100380a:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
 100380f:	48 89 14 24          	mov    %rdx,(%rsp)
 1003813:	e8 9e 30 00 00       	callq  10068b6 <runtime.MSpanList_Remove>
		runtime·MSpanList_Insert(&c->empty, s);
 1003818:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100381d:	48 83 c0 58          	add    $0x58,%rax
 1003821:	48 89 04 24          	mov    %rax,(%rsp)
 1003825:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100382a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100382f:	e8 fd 30 00 00       	callq  1006931 <runtime.MSpanList_Insert>
 1003834:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
	}
	return v;
 1003839:	48 89 d8             	mov    %rbx,%rax
 100383c:	48 83 c4 30          	add    $0x30,%rsp
 1003840:	c3                   	retq   

0000000001003841 <runtime.MCentral_FreeList>:
// Free n objects back into the central free list.
// Return the number of objects allocated.
// The objects are linked together by their first words.
// On return, *pstart points at the first object and *pend at the last.
void
runtime·MCentral_FreeList(MCentral *c, int32 n, MLink *start)
 1003841:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003848:	ff ff 
 100384a:	48 3b 21             	cmp    (%rcx),%rsp
 100384d:	77 05                	ja     1003854 <runtime.MCentral_FreeList+0x13>
 100384f:	e8 0a e1 ff ff       	callq  100195e <runtime.morestack24>
 1003854:	48 83 ec 30          	sub    $0x30,%rsp
	// Assume next == nil marks end of list.
	// n and end would be useful if we implemented
	// the transfer cache optimization in the TODO above.
	USED(n);

	runtime·lock(c);
 1003858:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100385d:	48 89 04 24          	mov    %rax,(%rsp)
 1003861:	e8 ca 95 00 00       	callq  100ce30 <runtime.lock>
	for(v=start; v; v=next) {
 1003866:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 100386b:	48 83 f9 00          	cmp    $0x0,%rcx
 100386f:	74 26                	je     1003897 <runtime.MCentral_FreeList+0x56>
		next = v->next;
 1003871:	48 8b 01             	mov    (%rcx),%rax
 1003874:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
		MCentral_Free(c, v);
 1003879:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100387e:	48 89 04 24          	mov    %rax,(%rsp)
 1003882:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1003887:	e8 1e 00 00 00       	callq  10038aa <MCentral_Free>
	// n and end would be useful if we implemented
	// the transfer cache optimization in the TODO above.
	USED(n);

	runtime·lock(c);
	for(v=start; v; v=next) {
 100388c:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 1003891:	48 83 f9 00          	cmp    $0x0,%rcx
 1003895:	75 da                	jne    1003871 <runtime.MCentral_FreeList+0x30>
		next = v->next;
		MCentral_Free(c, v);
	}
	runtime·unlock(c);
 1003897:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100389c:	48 89 04 24          	mov    %rax,(%rsp)
 10038a0:	e8 dd 95 00 00       	callq  100ce82 <runtime.unlock>
 10038a5:	48 83 c4 30          	add    $0x30,%rsp
 10038a9:	c3                   	retq   

00000000010038aa <MCentral_Free>:
}

// Helper: free one object back into the central free list.
static void
MCentral_Free(MCentral *c, void *v)
 10038aa:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10038b1:	ff ff 
 10038b3:	48 3b 21             	cmp    (%rcx),%rsp
 10038b6:	77 05                	ja     10038bd <MCentral_Free+0x13>
 10038b8:	e8 98 e0 ff ff       	callq  1001955 <runtime.morestack16>
 10038bd:	48 83 ec 40          	sub    $0x40,%rsp
	MSpan *s;
	MLink *p;
	int32 size;

	// Find span for v.
	s = runtime·MHeap_Lookup(&runtime·mheap, v);
 10038c1:	b9 80 a0 03 01       	mov    $0x103a080,%ecx
 10038c6:	48 89 0c 24          	mov    %rcx,(%rsp)
 10038ca:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 10038cf:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10038d4:	e8 1c 2b 00 00       	callq  10063f5 <runtime.MHeap_Lookup>
 10038d9:	48 89 c2             	mov    %rax,%rdx
	if(s == nil || s->ref == 0)
 10038dc:	48 83 f8 00          	cmp    $0x0,%rax
 10038e0:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
 10038e5:	0f 84 2d 01 00 00    	je     1003a18 <MCentral_Free+0x16e>
 10038eb:	8b 40 30             	mov    0x30(%rax),%eax
 10038ee:	83 f8 00             	cmp    $0x0,%eax
 10038f1:	0f 84 21 01 00 00    	je     1003a18 <MCentral_Free+0x16e>
		runtime·throw("invalid free");

	// Move to nonempty if necessary.
	if(s->freelist == nil) {
 10038f7:	48 8b 42 28          	mov    0x28(%rdx),%rax
 10038fb:	48 83 f8 00          	cmp    $0x0,%rax
 10038ff:	75 2a                	jne    100392b <MCentral_Free+0x81>
		runtime·MSpanList_Remove(s);
 1003901:	48 89 14 24          	mov    %rdx,(%rsp)
 1003905:	e8 ac 2f 00 00       	callq  10068b6 <runtime.MSpanList_Remove>
		runtime·MSpanList_Insert(&c->nonempty, s);
 100390a:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 100390f:	48 83 c0 10          	add    $0x10,%rax
 1003913:	48 89 04 24          	mov    %rax,(%rsp)
 1003917:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100391c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1003921:	e8 0b 30 00 00       	callq  1006931 <runtime.MSpanList_Insert>
 1003926:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
	}

	// Add v back to s's free list.
	p = v;
 100392b:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
	p->next = s->freelist;
 1003930:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
 1003934:	48 89 0b             	mov    %rcx,(%rbx)
	s->freelist = p;
 1003937:	48 89 5a 28          	mov    %rbx,0x28(%rdx)
	c->nfree++;
 100393b:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1003940:	ff 80 a0 00 00 00    	incl   0xa0(%rax)

	// If s is completely freed, return it to the heap.
	if(--s->ref == 0) {
 1003946:	ff 4a 30             	decl   0x30(%rdx)
 1003949:	8b 42 30             	mov    0x30(%rdx),%eax
 100394c:	83 f8 00             	cmp    $0x0,%eax
 100394f:	0f 85 be 00 00 00    	jne    1003a13 <MCentral_Free+0x169>
		size = runtime·class_to_size[c->sizeclass];
 1003955:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 100395a:	8b 49 08             	mov    0x8(%rcx),%ecx
 100395d:	48 63 c9             	movslq %ecx,%rcx
 1003960:	8b 04 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%eax
 1003967:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
		runtime·MSpanList_Remove(s);
 100396b:	48 89 14 24          	mov    %rdx,(%rsp)
 100396f:	e8 42 2f 00 00       	callq  10068b6 <runtime.MSpanList_Remove>
 1003974:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
		runtime·unmarkspan((byte*)(s->start<<PageShift), s->npages<<PageShift);
 1003979:	48 8b 41 18          	mov    0x18(%rcx),%rax
 100397d:	48 c1 e0 0c          	shl    $0xc,%rax
 1003981:	48 89 04 24          	mov    %rax,(%rsp)
 1003985:	48 8b 41 20          	mov    0x20(%rcx),%rax
 1003989:	48 c1 e0 0c          	shl    $0xc,%rax
 100398d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1003992:	e8 1d 20 00 00       	callq  10059b4 <runtime.unmarkspan>
 1003997:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
 100399c:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
		*(uintptr*)(s->start<<PageShift) = 1;  // needs zeroing
 10039a1:	48 8b 41 18          	mov    0x18(%rcx),%rax
 10039a5:	48 c1 e0 0c          	shl    $0xc,%rax
 10039a9:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
		s->freelist = nil;
 10039b0:	48 c7 41 28 00 00 00 	movq   $0x0,0x28(%rcx)
 10039b7:	00 
		c->nfree -= (s->npages << PageShift) / size;
 10039b8:	48 8b 41 20          	mov    0x20(%rcx),%rax
 10039bc:	48 c1 e0 0c          	shl    $0xc,%rax
 10039c0:	31 d2                	xor    %edx,%edx
 10039c2:	8b 4c 24 2c          	mov    0x2c(%rsp),%ecx
 10039c6:	48 63 c9             	movslq %ecx,%rcx
 10039c9:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 10039ce:	48 f7 74 24 18       	divq   0x18(%rsp)
 10039d3:	48 63 c0             	movslq %eax,%rax
 10039d6:	29 83 a0 00 00 00    	sub    %eax,0xa0(%rbx)
		runtime·unlock(c);
 10039dc:	48 89 1c 24          	mov    %rbx,(%rsp)
 10039e0:	e8 9d 94 00 00       	callq  100ce82 <runtime.unlock>
		runtime·MHeap_Free(&runtime·mheap, s, 0);
 10039e5:	b8 80 a0 03 01       	mov    $0x103a080,%eax
 10039ea:	48 89 04 24          	mov    %rax,(%rsp)
 10039ee:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 10039f3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10039f8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
 10039ff:	00 
 1003a00:	e8 f9 2a 00 00       	callq  10064fe <runtime.MHeap_Free>
		runtime·lock(c);
 1003a05:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1003a0a:	48 89 04 24          	mov    %rax,(%rsp)
 1003a0e:	e8 1d 94 00 00       	callq  100ce30 <runtime.lock>
 1003a13:	48 83 c4 40          	add    $0x40,%rsp
 1003a17:	c3                   	retq   
	int32 size;

	// Find span for v.
	s = runtime·MHeap_Lookup(&runtime·mheap, v);
	if(s == nil || s->ref == 0)
		runtime·throw("invalid free");
 1003a18:	b8 50 30 02 01       	mov    $0x1023050,%eax
 1003a1d:	48 89 04 24          	mov    %rax,(%rsp)
 1003a21:	e8 13 63 00 00       	callq  1009d39 <runtime.throw>
 1003a26:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx

	// Move to nonempty if necessary.
	if(s->freelist == nil) {
 1003a2b:	e9 c7 fe ff ff       	jmpq   10038f7 <MCentral_Free+0x4d>

0000000001003a30 <runtime.MGetSizeClassInfo>:
		runtime·lock(c);
	}
}

void
runtime·MGetSizeClassInfo(int32 sizeclass, uintptr *sizep, int32 *npagesp, int32 *nobj)
 1003a30:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003a37:	ff ff 
 1003a39:	48 3b 21             	cmp    (%rcx),%rsp
 1003a3c:	77 05                	ja     1003a43 <runtime.MGetSizeClassInfo+0x13>
 1003a3e:	e8 24 df ff ff       	callq  1001967 <runtime.morestack32>
 1003a43:	48 83 ec 10          	sub    $0x10,%rsp
 1003a47:	8b 5c 24 18          	mov    0x18(%rsp),%ebx
{
	int32 size;
	int32 npages;

	npages = runtime·class_to_allocnpages[sizeclass];
 1003a4b:	48 63 cb             	movslq %ebx,%rcx
 1003a4e:	8b 2c 8d e0 50 02 01 	mov    0x10250e0(,%rcx,4),%ebp
	size = runtime·class_to_size[sizeclass];
 1003a55:	48 63 cb             	movslq %ebx,%rcx
 1003a58:	8b 1c 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%ebx
	*npagesp = npages;
 1003a5f:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1003a64:	89 28                	mov    %ebp,(%rax)
	*sizep = size;
 1003a66:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1003a6b:	48 63 cb             	movslq %ebx,%rcx
 1003a6e:	48 89 08             	mov    %rcx,(%rax)
	*nobj = (npages << PageShift) / size;
 1003a71:	89 e8                	mov    %ebp,%eax
 1003a73:	c1 e0 0c             	shl    $0xc,%eax
 1003a76:	99                   	cltd   
 1003a77:	f7 fb                	idiv   %ebx
 1003a79:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1003a7e:	89 01                	mov    %eax,(%rcx)
 1003a80:	48 83 c4 10          	add    $0x10,%rsp
 1003a84:	c3                   	retq   

0000000001003a85 <MCentral_Grow>:
}

// Fetch a new span from the heap and
// carve into objects for the free list.
static bool
MCentral_Grow(MCentral *c)
 1003a85:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003a8c:	ff ff 
 1003a8e:	48 3b 21             	cmp    (%rcx),%rsp
 1003a91:	77 05                	ja     1003a98 <MCentral_Grow+0x13>
 1003a93:	e8 b4 de ff ff       	callq  100194c <runtime.morestack8>
 1003a98:	48 83 ec 68          	sub    $0x68,%rsp
	uintptr size;
	MLink **tailp, *v;
	byte *p;
	MSpan *s;

	runtime·unlock(c);
 1003a9c:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
 1003aa1:	48 89 04 24          	mov    %rax,(%rsp)
 1003aa5:	e8 d8 93 00 00       	callq  100ce82 <runtime.unlock>
	runtime·MGetSizeClassInfo(c->sizeclass, &size, &npages, &n);
 1003aaa:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
 1003aaf:	8b 40 08             	mov    0x8(%rax),%eax
 1003ab2:	89 04 24             	mov    %eax,(%rsp)
 1003ab5:	48 8d 44 24 50       	lea    0x50(%rsp),%rax
 1003aba:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1003abf:	48 8d 44 24 5c       	lea    0x5c(%rsp),%rax
 1003ac4:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1003ac9:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
 1003ace:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1003ad3:	e8 58 ff ff ff       	callq  1003a30 <runtime.MGetSizeClassInfo>
	s = runtime·MHeap_Alloc(&runtime·mheap, npages, c->sizeclass, 0);
 1003ad8:	b9 80 a0 03 01       	mov    $0x103a080,%ecx
 1003add:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003ae1:	8b 4c 24 5c          	mov    0x5c(%rsp),%ecx
 1003ae5:	48 63 c9             	movslq %ecx,%rcx
 1003ae8:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1003aed:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
 1003af2:	8b 49 08             	mov    0x8(%rcx),%ecx
 1003af5:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1003af9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%rsp)
 1003b00:	00 
 1003b01:	e8 e4 22 00 00       	callq  1005dea <runtime.MHeap_Alloc>
 1003b06:	48 89 c7             	mov    %rax,%rdi
	if(s == nil) {
 1003b09:	48 83 f8 00          	cmp    $0x0,%rax
 1003b0d:	75 15                	jne    1003b24 <MCentral_Grow+0x9f>
		// TODO(rsc): Log out of memory
		runtime·lock(c);
 1003b0f:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
 1003b14:	48 89 04 24          	mov    %rax,(%rsp)
 1003b18:	e8 13 93 00 00       	callq  100ce30 <runtime.lock>
		return false;
 1003b1d:	31 c0                	xor    %eax,%eax
 1003b1f:	48 83 c4 68          	add    $0x68,%rsp
 1003b23:	c3                   	retq   
	}

	// Carve span into sequence of blocks.
	tailp = &s->freelist;
 1003b24:	48 83 c0 28          	add    $0x28,%rax
 1003b28:	48 89 c5             	mov    %rax,%rbp
	p = (byte*)(s->start << PageShift);
 1003b2b:	48 8b 47 18          	mov    0x18(%rdi),%rax
 1003b2f:	48 c1 e0 0c          	shl    $0xc,%rax
 1003b33:	48 89 c3             	mov    %rax,%rbx
	s->limit = p + size*n;
 1003b36:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1003b3b:	8b 44 24 60          	mov    0x60(%rsp),%eax
 1003b3f:	48 63 c0             	movslq %eax,%rax
 1003b42:	48 f7 64 24 50       	mulq   0x50(%rsp)
 1003b47:	48 89 c1             	mov    %rax,%rcx
 1003b4a:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1003b4f:	48 89 da             	mov    %rbx,%rdx
 1003b52:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
 1003b56:	48 89 47 40          	mov    %rax,0x40(%rdi)
	for(i=0; i<n; i++) {
 1003b5a:	31 f6                	xor    %esi,%esi
 1003b5c:	3b 74 24 60          	cmp    0x60(%rsp),%esi
 1003b60:	7d 1a                	jge    1003b7c <MCentral_Grow+0xf7>
		v = (MLink*)p;
 1003b62:	48 89 da             	mov    %rbx,%rdx
		*tailp = v;
 1003b65:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
		tailp = &v->next;
 1003b69:	48 89 dd             	mov    %rbx,%rbp
		p += size;
 1003b6c:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1003b71:	48 01 c3             	add    %rax,%rbx

	// Carve span into sequence of blocks.
	tailp = &s->freelist;
	p = (byte*)(s->start << PageShift);
	s->limit = p + size*n;
	for(i=0; i<n; i++) {
 1003b74:	ff c6                	inc    %esi
 1003b76:	3b 74 24 60          	cmp    0x60(%rsp),%esi
 1003b7a:	7c e6                	jl     1003b62 <MCentral_Grow+0xdd>
		v = (MLink*)p;
		*tailp = v;
		tailp = &v->next;
		p += size;
	}
	*tailp = nil;
 1003b7c:	48 c7 45 00 00 00 00 	movq   $0x0,0x0(%rbp)
 1003b83:	00 
	runtime·markspan((byte*)(s->start<<PageShift), size, n, size*n < (s->npages<<PageShift));
 1003b84:	48 8b 47 18          	mov    0x18(%rdi),%rax
 1003b88:	48 c1 e0 0c          	shl    $0xc,%rax
 1003b8c:	48 89 04 24          	mov    %rax,(%rsp)
 1003b90:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1003b95:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1003b9a:	8b 44 24 60          	mov    0x60(%rsp),%eax
 1003b9e:	48 63 c0             	movslq %eax,%rax
 1003ba1:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1003ba6:	8b 44 24 60          	mov    0x60(%rsp),%eax
 1003baa:	48 63 c0             	movslq %eax,%rax
 1003bad:	48 f7 64 24 50       	mulq   0x50(%rsp)
 1003bb2:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
 1003bb7:	48 8b 4f 20          	mov    0x20(%rdi),%rcx
 1003bbb:	48 c1 e1 0c          	shl    $0xc,%rcx
 1003bbf:	48 39 c8             	cmp    %rcx,%rax
 1003bc2:	73 4c                	jae    1003c10 <MCentral_Grow+0x18b>
 1003bc4:	b8 01 00 00 00       	mov    $0x1,%eax
 1003bc9:	88 44 24 18          	mov    %al,0x18(%rsp)
 1003bcd:	e8 de 1c 00 00       	callq  10058b0 <runtime.markspan>

	runtime·lock(c);
 1003bd2:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
 1003bd7:	48 89 04 24          	mov    %rax,(%rsp)
 1003bdb:	e8 50 92 00 00       	callq  100ce30 <runtime.lock>
 1003be0:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
	c->nfree += n;
 1003be5:	8b 4c 24 60          	mov    0x60(%rsp),%ecx
 1003be9:	01 88 a0 00 00 00    	add    %ecx,0xa0(%rax)
	runtime·MSpanList_Insert(&c->nonempty, s);
 1003bef:	48 83 c0 10          	add    $0x10,%rax
 1003bf3:	48 89 04 24          	mov    %rax,(%rsp)
 1003bf7:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1003bfc:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1003c01:	e8 2b 2d 00 00       	callq  1006931 <runtime.MSpanList_Insert>
	return true;
 1003c06:	b8 01 00 00 00       	mov    $0x1,%eax
 1003c0b:	48 83 c4 68          	add    $0x68,%rsp
 1003c0f:	c3                   	retq   
 1003c10:	31 c0                	xor    %eax,%eax
 1003c12:	eb b5                	jmp    1003bc9 <MCentral_Grow+0x144>

0000000001003c14 <addrspace_free>:
{
	ENOMEM = 12,
};

static int32
addrspace_free(void *v, uintptr n)
 1003c14:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003c1b:	ff ff 
 1003c1d:	48 3b 21             	cmp    (%rcx),%rsp
 1003c20:	77 05                	ja     1003c27 <addrspace_free+0x13>
 1003c22:	e8 2e dd ff ff       	callq  1001955 <runtime.morestack16>
 1003c27:	48 83 ec 40          	sub    $0x40,%rsp
{
	uintptr page_size = 4096;
 1003c2b:	48 c7 c6 00 10 00 00 	mov    $0x1000,%rsi
	uintptr off;
	int8 one_byte;

	for(off = 0; off < n; off += page_size) {
 1003c32:	48 31 ed             	xor    %rbp,%rbp
 1003c35:	48 3b 6c 24 50       	cmp    0x50(%rsp),%rbp
 1003c3a:	73 4c                	jae    1003c88 <addrspace_free+0x74>
		int32 errval = runtime·mincore((int8 *)v + off, page_size, (void *)&one_byte);
 1003c3c:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
 1003c41:	48 89 eb             	mov    %rbp,%rbx
 1003c44:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
 1003c49:	48 8d 0c 13          	lea    (%rbx,%rdx,1),%rcx
 1003c4d:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003c51:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
 1003c56:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
 1003c5b:	48 8d 4c 24 2f       	lea    0x2f(%rsp),%rcx
 1003c60:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 1003c65:	e8 71 8b 00 00       	callq  100c7db <runtime.mincore>
 1003c6a:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
 1003c6f:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
		// errval is 0 if success, or -(error_code) if error.
		if (errval == 0 || errval != -ENOMEM)
 1003c74:	83 f8 00             	cmp    $0x0,%eax
 1003c77:	74 19                	je     1003c92 <addrspace_free+0x7e>
 1003c79:	83 f8 f4             	cmp    $0xfffffffffffffff4,%eax
 1003c7c:	75 14                	jne    1003c92 <addrspace_free+0x7e>
{
	uintptr page_size = 4096;
	uintptr off;
	int8 one_byte;

	for(off = 0; off < n; off += page_size) {
 1003c7e:	48 01 f5             	add    %rsi,%rbp
 1003c81:	48 3b 6c 24 50       	cmp    0x50(%rsp),%rbp
 1003c86:	72 b4                	jb     1003c3c <addrspace_free+0x28>
		if (errval == 0 || errval != -ENOMEM)
			return 0;
	}
	USED(v);
	USED(n);
	return 1;
 1003c88:	b8 01 00 00 00       	mov    $0x1,%eax
 1003c8d:	48 83 c4 40          	add    $0x40,%rsp
 1003c91:	c3                   	retq   

	for(off = 0; off < n; off += page_size) {
		int32 errval = runtime·mincore((int8 *)v + off, page_size, (void *)&one_byte);
		// errval is 0 if success, or -(error_code) if error.
		if (errval == 0 || errval != -ENOMEM)
			return 0;
 1003c92:	31 c0                	xor    %eax,%eax
 1003c94:	48 83 c4 40          	add    $0x40,%rsp
 1003c98:	c3                   	retq   

0000000001003c99 <runtime.SysAlloc>:
	return 1;
}


void*
runtime·SysAlloc(uintptr n)
 1003c99:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003ca0:	ff ff 
 1003ca2:	48 3b 21             	cmp    (%rcx),%rsp
 1003ca5:	77 05                	ja     1003cac <runtime.SysAlloc+0x13>
 1003ca7:	e8 a0 dc ff ff       	callq  100194c <runtime.morestack8>
 1003cac:	48 83 ec 38          	sub    $0x38,%rsp
 1003cb0:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
{
	void *p;

	mstats.sys += n;
 1003cb5:	48 01 14 25 68 62 02 	add    %rdx,0x1026268
 1003cbc:	01 
	p = runtime·mmap(nil, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_PRIVATE, -1, 0);
 1003cbd:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
 1003cc4:	00 
 1003cc5:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 1003cca:	b9 07 00 00 00       	mov    $0x7,%ecx
 1003ccf:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1003cd3:	b9 22 00 00 00       	mov    $0x22,%ecx
 1003cd8:	89 4c 24 14          	mov    %ecx,0x14(%rsp)
 1003cdc:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 1003ce1:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
 1003ce5:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%rsp)
 1003cec:	00 
 1003ced:	e8 aa 8b 00 00       	callq  100c89c <runtime.mmap>
	if(p < (void*)4096) {
 1003cf2:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
 1003cf8:	73 37                	jae    1003d31 <runtime.SysAlloc+0x98>
		if(p == (void*)EACCES) {
 1003cfa:	48 83 f8 0d          	cmp    $0xd,%rax
 1003cfe:	75 29                	jne    1003d29 <runtime.SysAlloc+0x90>
			runtime·printf("runtime: mmap: access denied\n");
 1003d00:	b8 90 33 02 01       	mov    $0x1023390,%eax
 1003d05:	48 89 04 24          	mov    %rax,(%rsp)
 1003d09:	e8 30 36 00 00       	callq  100733e <runtime.printf>
			runtime·printf("if you're running SELinux, enable execmem for this process.\n");
 1003d0e:	b8 ae 33 02 01       	mov    $0x10233ae,%eax
 1003d13:	48 89 04 24          	mov    %rax,(%rsp)
 1003d17:	e8 22 36 00 00       	callq  100733e <runtime.printf>
			runtime·exit(2);
 1003d1c:	b8 02 00 00 00       	mov    $0x2,%eax
 1003d21:	89 04 24             	mov    %eax,(%rsp)
 1003d24:	e8 48 8a 00 00       	callq  100c771 <runtime.exit>
		}
		return nil;
 1003d29:	48 31 c0             	xor    %rax,%rax
 1003d2c:	48 83 c4 38          	add    $0x38,%rsp
 1003d30:	c3                   	retq   
	}
	return p;
 1003d31:	48 83 c4 38          	add    $0x38,%rsp
 1003d35:	c3                   	retq   

0000000001003d36 <runtime.SysFree>:
	USED(n);
	// TODO(rsc): call madvise MADV_DONTNEED
}

void
runtime·SysFree(void *v, uintptr n)
 1003d36:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003d3d:	ff ff 
 1003d3f:	48 3b 21             	cmp    (%rcx),%rsp
 1003d42:	77 05                	ja     1003d49 <runtime.SysFree+0x13>
 1003d44:	e8 0c dc ff ff       	callq  1001955 <runtime.morestack16>
 1003d49:	48 83 ec 18          	sub    $0x18,%rsp
 1003d4d:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
{
	mstats.sys -= n;
 1003d52:	48 29 0c 25 68 62 02 	sub    %rcx,0x1026268
 1003d59:	01 
	runtime·munmap(v, n);
 1003d5a:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1003d5f:	48 89 04 24          	mov    %rax,(%rsp)
 1003d63:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1003d68:	e8 65 8b 00 00       	callq  100c8d2 <runtime.munmap>
 1003d6d:	48 83 c4 18          	add    $0x18,%rsp
 1003d71:	c3                   	retq   

0000000001003d72 <runtime.SysReserve>:
}

void*
runtime·SysReserve(void *v, uintptr n)
 1003d72:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003d79:	ff ff 
 1003d7b:	48 3b 21             	cmp    (%rcx),%rsp
 1003d7e:	77 05                	ja     1003d85 <runtime.SysReserve+0x13>
 1003d80:	e8 d0 db ff ff       	callq  1001955 <runtime.morestack16>
 1003d85:	48 83 ec 38          	sub    $0x38,%rsp

	// On 64-bit, people with ulimit -v set complain if we reserve too
	// much address space.  Instead, assume that the reservation is okay
	// and check the assumption in SysMap.
	if(sizeof(void*) == 8)
		return v;
 1003d89:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 1003d8e:	48 83 c4 38          	add    $0x38,%rsp
 1003d92:	c3                   	retq   

0000000001003d93 <runtime.SysMap>:
	}
	return p;
}

void
runtime·SysMap(void *v, uintptr n)
 1003d93:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003d9a:	ff ff 
 1003d9c:	48 3b 21             	cmp    (%rcx),%rsp
 1003d9f:	77 05                	ja     1003da6 <runtime.SysMap+0x13>
 1003da1:	e8 af db ff ff       	callq  1001955 <runtime.morestack16>
 1003da6:	48 83 ec 38          	sub    $0x38,%rsp
 1003daa:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
{
	void *p;
	
	mstats.sys += n;
 1003daf:	48 01 14 25 68 62 02 	add    %rdx,0x1026268
 1003db6:	01 

	// On 64-bit, we don't actually have v reserved, so tread carefully.
	if(sizeof(void*) == 8) {
		p = runtime·mmap(v, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_PRIVATE, -1, 0);
 1003db7:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 1003dbc:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003dc0:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 1003dc5:	b9 07 00 00 00       	mov    $0x7,%ecx
 1003dca:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1003dce:	b9 22 00 00 00       	mov    $0x22,%ecx
 1003dd3:	89 4c 24 14          	mov    %ecx,0x14(%rsp)
 1003dd7:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 1003ddc:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
 1003de0:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%rsp)
 1003de7:	00 
 1003de8:	e8 af 8a 00 00       	callq  100c89c <runtime.mmap>
 1003ded:	48 89 c1             	mov    %rax,%rcx
		if(p != v && addrspace_free(v, n)) {
 1003df0:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
 1003df5:	48 3b 44 24 40       	cmp    0x40(%rsp),%rax
 1003dfa:	74 22                	je     1003e1e <runtime.SysMap+0x8b>
 1003dfc:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 1003e01:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003e05:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 1003e0a:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1003e0f:	e8 00 fe ff ff       	callq  1003c14 <addrspace_free>
 1003e14:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1003e19:	83 f8 00             	cmp    $0x0,%eax
 1003e1c:	75 55                	jne    1003e73 <runtime.SysMap+0xe0>
			if(p > (void*)4096) {
				runtime·munmap(p, n);
			}
			p = runtime·mmap(v, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_FIXED|MAP_PRIVATE, -1, 0);
		}
		if(p == (void*)ENOMEM)
 1003e1e:	48 83 f9 0c          	cmp    $0xc,%rcx
 1003e22:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
 1003e27:	75 13                	jne    1003e3c <runtime.SysMap+0xa9>
			runtime·throw("runtime: out of memory");
 1003e29:	b8 eb 33 02 01       	mov    $0x10233eb,%eax
 1003e2e:	48 89 04 24          	mov    %rax,(%rsp)
 1003e32:	e8 02 5f 00 00       	callq  1009d39 <runtime.throw>
 1003e37:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
		if(p != v) {
 1003e3c:	48 3b 4c 24 40       	cmp    0x40(%rsp),%rcx
 1003e41:	74 2b                	je     1003e6e <runtime.SysMap+0xdb>
			runtime·printf("runtime: address space conflict: map(%p) = %p\n", v, p);
 1003e43:	b8 02 34 02 01       	mov    $0x1023402,%eax
 1003e48:	48 89 04 24          	mov    %rax,(%rsp)
 1003e4c:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 1003e51:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1003e56:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 1003e5b:	e8 de 34 00 00       	callq  100733e <runtime.printf>
			runtime·throw("runtime: address space conflict");
 1003e60:	b8 31 34 02 01       	mov    $0x1023431,%eax
 1003e65:	48 89 04 24          	mov    %rax,(%rsp)
 1003e69:	e8 cb 5e 00 00       	callq  1009d39 <runtime.throw>
		}
		return;
 1003e6e:	48 83 c4 38          	add    $0x38,%rsp
 1003e72:	c3                   	retq   
	if(sizeof(void*) == 8) {
		p = runtime·mmap(v, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_PRIVATE, -1, 0);
		if(p != v && addrspace_free(v, n)) {
			// On some systems, mmap ignores v without
			// MAP_FIXED, so retry if the address space is free.
			if(p > (void*)4096) {
 1003e73:	48 81 f9 00 10 00 00 	cmp    $0x1000,%rcx
 1003e7a:	76 13                	jbe    1003e8f <runtime.SysMap+0xfc>
				runtime·munmap(p, n);
 1003e7c:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003e80:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1003e85:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1003e8a:	e8 43 8a 00 00       	callq  100c8d2 <runtime.munmap>
			}
			p = runtime·mmap(v, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_FIXED|MAP_PRIVATE, -1, 0);
 1003e8f:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 1003e94:	48 89 0c 24          	mov    %rcx,(%rsp)
 1003e98:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 1003e9d:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1003ea2:	b9 07 00 00 00       	mov    $0x7,%ecx
 1003ea7:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1003eab:	b9 32 00 00 00       	mov    $0x32,%ecx
 1003eb0:	89 4c 24 14          	mov    %ecx,0x14(%rsp)
 1003eb4:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 1003eb9:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
 1003ebd:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%rsp)
 1003ec4:	00 
 1003ec5:	e8 d2 89 00 00       	callq  100c89c <runtime.mmap>
 1003eca:	48 89 c1             	mov    %rax,%rcx
 1003ecd:	e9 4c ff ff ff       	jmpq   1003e1e <runtime.SysMap+0x8b>

0000000001003ed2 <runtime.memmove>:
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

TEXT runtime·memmove(SB), 7, $0

	MOVQ	to+0(FP), DI
 1003ed2:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	MOVQ	fr+8(FP), SI
 1003ed7:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVLQSX	n+16(FP), BX
 1003edc:	48 63 5c 24 18       	movslq 0x18(%rsp),%rbx

/*
 * check and set for backwards
 */
	CMPQ	SI, DI
 1003ee1:	48 39 fe             	cmp    %rdi,%rsi
	JLS	back
 1003ee4:	76 19                	jbe    1003eff <runtime.memmove+0x2d>

/*
 * forward copy loop
 */
forward:	
	MOVQ	BX, CX
 1003ee6:	48 89 d9             	mov    %rbx,%rcx
	SHRQ	$3, CX
 1003ee9:	48 c1 e9 03          	shr    $0x3,%rcx
	ANDQ	$7, BX
 1003eed:	48 83 e3 07          	and    $0x7,%rbx

	REP;	MOVSQ
 1003ef1:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	MOVQ	BX, CX
 1003ef4:	48 89 d9             	mov    %rbx,%rcx
	REP;	MOVSB
 1003ef7:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)

	MOVQ	to+0(FP),AX
 1003ef9:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	RET
 1003efe:	c3                   	retq   
back:
/*
 * check overlap
 */
	MOVQ	SI, CX
 1003eff:	48 89 f1             	mov    %rsi,%rcx
	ADDQ	BX, CX
 1003f02:	48 01 d9             	add    %rbx,%rcx
	CMPQ	CX, DI
 1003f05:	48 39 f9             	cmp    %rdi,%rcx
	JLS	forward
 1003f08:	76 dc                	jbe    1003ee6 <runtime.memmove+0x14>
	
/*
 * whole thing backwards has
 * adjusted addresses
 */
	ADDQ	BX, DI
 1003f0a:	48 01 df             	add    %rbx,%rdi
	ADDQ	BX, SI
 1003f0d:	48 01 de             	add    %rbx,%rsi
	STD
 1003f10:	fd                   	std    

/*
 * copy
 */
	MOVQ	BX, CX
 1003f11:	48 89 d9             	mov    %rbx,%rcx
	SHRQ	$3, CX
 1003f14:	48 c1 e9 03          	shr    $0x3,%rcx
	ANDQ	$7, BX
 1003f18:	48 83 e3 07          	and    $0x7,%rbx

	SUBQ	$8, DI
 1003f1c:	48 83 ef 08          	sub    $0x8,%rdi
	SUBQ	$8, SI
 1003f20:	48 83 ee 08          	sub    $0x8,%rsi
	REP;	MOVSQ
 1003f24:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)

	ADDQ	$7, DI
 1003f27:	48 83 c7 07          	add    $0x7,%rdi
	ADDQ	$7, SI
 1003f2b:	48 83 c6 07          	add    $0x7,%rsi
	MOVQ	BX, CX
 1003f2f:	48 89 d9             	mov    %rbx,%rcx
	REP;	MOVSB
 1003f32:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)

	CLD
 1003f34:	fc                   	cld    
	MOVQ	to+0(FP),AX
 1003f35:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
 1003f3a:	c3                   	retq   

0000000001003f3b <lookfintab>:
	t->key[i] = k;
	t->val[i] = v;
}

static Finalizer*
lookfintab(Fintab *t, void *k, bool del)
 1003f3b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1003f42:	ff ff 
 1003f44:	48 3b 21             	cmp    (%rcx),%rsp
 1003f47:	77 05                	ja     1003f4e <lookfintab+0x13>
 1003f49:	e8 10 da ff ff       	callq  100195e <runtime.morestack24>
 1003f4e:	48 83 ec 28          	sub    $0x28,%rsp
 1003f52:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
 1003f57:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
{
	int32 i, j;
	Finalizer *v;

	if(t->max == 0)
 1003f5c:	8b 45 18             	mov    0x18(%rbp),%eax
 1003f5f:	83 f8 00             	cmp    $0x0,%eax
 1003f62:	75 08                	jne    1003f6c <lookfintab+0x31>
		return nil;
 1003f64:	48 31 c0             	xor    %rax,%rax
 1003f67:	48 83 c4 28          	add    $0x28,%rsp
 1003f6b:	c3                   	retq   
	i = (uintptr)k % (uintptr)t->max;
 1003f6c:	8b 4d 18             	mov    0x18(%rbp),%ecx
 1003f6f:	48 63 c9             	movslq %ecx,%rcx
 1003f72:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1003f77:	48 89 f8             	mov    %rdi,%rax
 1003f7a:	31 d2                	xor    %edx,%edx
 1003f7c:	48 f7 74 24 08       	divq   0x8(%rsp)
 1003f81:	48 63 c2             	movslq %edx,%rax
 1003f84:	89 c3                	mov    %eax,%ebx
	for(j=0; j<t->max; j++) {
 1003f86:	31 f6                	xor    %esi,%esi
 1003f88:	8b 45 18             	mov    0x18(%rbp),%eax
 1003f8b:	39 c6                	cmp    %eax,%esi
 1003f8d:	0f 8d 8b 00 00 00    	jge    100401e <lookfintab+0xe3>
		if(t->key[i] == nil)
 1003f93:	48 63 c3             	movslq %ebx,%rax
 1003f96:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 1003f9a:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
 1003f9e:	48 8b 00             	mov    (%rax),%rax
 1003fa1:	48 83 f8 00          	cmp    $0x0,%rax
 1003fa5:	75 08                	jne    1003faf <lookfintab+0x74>
			return nil;
 1003fa7:	48 31 c0             	xor    %rax,%rax
 1003faa:	48 83 c4 28          	add    $0x28,%rsp
 1003fae:	c3                   	retq   
		if(t->key[i] == k) {
 1003faf:	48 63 c3             	movslq %ebx,%rax
 1003fb2:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 1003fb6:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
 1003fba:	48 8b 00             	mov    (%rax),%rax
 1003fbd:	48 39 f8             	cmp    %rdi,%rax
 1003fc0:	75 44                	jne    1004006 <lookfintab+0xcb>
			v = t->val[i];
 1003fc2:	48 63 c3             	movslq %ebx,%rax
 1003fc5:	48 8b 4d 08          	mov    0x8(%rbp),%rcx
 1003fc9:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
 1003fcd:	48 8b 30             	mov    (%rax),%rsi
			if(del) {
 1003fd0:	80 7c 24 40 00       	cmpb   $0x0,0x40(%rsp)
 1003fd5:	74 27                	je     1003ffe <lookfintab+0xc3>
				t->key[i] = (void*)-1;
 1003fd7:	48 63 c3             	movslq %ebx,%rax
 1003fda:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 1003fde:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
 1003fe2:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
				t->val[i] = nil;
 1003fe9:	48 63 c3             	movslq %ebx,%rax
 1003fec:	48 8b 4d 08          	mov    0x8(%rbp),%rcx
 1003ff0:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
 1003ff4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
				t->ndead++;
 1003ffb:	ff 45 14             	incl   0x14(%rbp)
			}
			return v;
 1003ffe:	48 89 f0             	mov    %rsi,%rax
 1004001:	48 83 c4 28          	add    $0x28,%rsp
 1004005:	c3                   	retq   
		}
		if(++i == t->max)
 1004006:	ff c3                	inc    %ebx
 1004008:	8b 4d 18             	mov    0x18(%rbp),%ecx
 100400b:	39 cb                	cmp    %ecx,%ebx
 100400d:	75 02                	jne    1004011 <lookfintab+0xd6>
			i = 0;
 100400f:	31 db                	xor    %ebx,%ebx
	Finalizer *v;

	if(t->max == 0)
		return nil;
	i = (uintptr)k % (uintptr)t->max;
	for(j=0; j<t->max; j++) {
 1004011:	ff c6                	inc    %esi
 1004013:	8b 45 18             	mov    0x18(%rbp),%eax
 1004016:	39 c6                	cmp    %eax,%esi
 1004018:	0f 8c 75 ff ff ff    	jl     1003f93 <lookfintab+0x58>
		if(++i == t->max)
			i = 0;
	}

	// cannot happen - table is known to be non-full
	runtime·throw("finalizer table inconsistent");
 100401e:	b8 75 31 02 01       	mov    $0x1023175,%eax
 1004023:	48 89 04 24          	mov    %rax,(%rsp)
 1004027:	e8 0d 5d 00 00       	callq  1009d39 <runtime.throw>
	return nil;
 100402c:	48 31 c0             	xor    %rax,%rax
 100402f:	48 83 c4 28          	add    $0x28,%rsp
 1004033:	c3                   	retq   

0000000001004034 <runtime.getfinalizer>:
}

// get finalizer; if del, delete finalizer.
// caller is responsible for updating RefHasFinalizer bit.
Finalizer*
runtime·getfinalizer(void *p, bool del)
 1004034:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100403b:	ff ff 
 100403d:	48 3b 21             	cmp    (%rcx),%rsp
 1004040:	77 05                	ja     1004047 <runtime.getfinalizer+0x13>
 1004042:	e8 0e d9 ff ff       	callq  1001955 <runtime.morestack16>
 1004047:	48 83 ec 28          	sub    $0x28,%rsp
{
	Finalizer *f;
	
	runtime·lock(&finlock);
 100404b:	b8 68 4e 02 01       	mov    $0x1024e68,%eax
 1004050:	48 89 04 24          	mov    %rax,(%rsp)
 1004054:	e8 d7 8d 00 00       	callq  100ce30 <runtime.lock>
	f = lookfintab(&fintab, p, del);
 1004059:	b9 30 4f 02 01       	mov    $0x1024f30,%ecx
 100405e:	48 89 0c 24          	mov    %rcx,(%rsp)
 1004062:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1004067:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100406c:	0f b6 4c 24 38       	movzbl 0x38(%rsp),%ecx
 1004071:	88 4c 24 10          	mov    %cl,0x10(%rsp)
 1004075:	e8 c1 fe ff ff       	callq  1003f3b <lookfintab>
 100407a:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
	runtime·unlock(&finlock);
 100407f:	b8 68 4e 02 01       	mov    $0x1024e68,%eax
 1004084:	48 89 04 24          	mov    %rax,(%rsp)
 1004088:	e8 f5 8d 00 00       	callq  100ce82 <runtime.unlock>
	return f;
 100408d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1004092:	48 83 c4 28          	add    $0x28,%rsp
 1004096:	c3                   	retq   

0000000001004097 <runtime.walkfintab>:
}

void
runtime·walkfintab(void (*fn)(void*))
 1004097:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100409e:	ff ff 
 10040a0:	48 3b 21             	cmp    (%rcx),%rsp
 10040a3:	77 05                	ja     10040aa <runtime.walkfintab+0x13>
 10040a5:	e8 a2 d8 ff ff       	callq  100194c <runtime.morestack8>
 10040aa:	48 83 ec 28          	sub    $0x28,%rsp
{
	void **key;
	void **ekey;

	runtime·lock(&finlock);
 10040ae:	b8 68 4e 02 01       	mov    $0x1024e68,%eax
 10040b3:	48 89 04 24          	mov    %rax,(%rsp)
 10040b7:	e8 74 8d 00 00       	callq  100ce30 <runtime.lock>
	key = fintab.key;
 10040bc:	48 8b 1c 25 30 4f 02 	mov    0x1024f30,%rbx
 10040c3:	01 
	ekey = key + fintab.max;
 10040c4:	8b 0c 25 48 4f 02 01 	mov    0x1024f48,%ecx
 10040cb:	48 63 c9             	movslq %ecx,%rcx
 10040ce:	48 8d 04 cb          	lea    (%rbx,%rcx,8),%rax
 10040d2:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
	for(; key < ekey; key++)
 10040d7:	48 3b 5c 24 18       	cmp    0x18(%rsp),%rbx
 10040dc:	73 1d                	jae    10040fb <runtime.walkfintab+0x64>
		if(*key != nil && *key != ((void*)-1))
 10040de:	48 8b 03             	mov    (%rbx),%rax
 10040e1:	48 83 f8 00          	cmp    $0x0,%rax
 10040e5:	74 09                	je     10040f0 <runtime.walkfintab+0x59>
 10040e7:	48 8b 03             	mov    (%rbx),%rax
 10040ea:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
 10040ee:	75 1e                	jne    100410e <runtime.walkfintab+0x77>
	void **ekey;

	runtime·lock(&finlock);
	key = fintab.key;
	ekey = key + fintab.max;
	for(; key < ekey; key++)
 10040f0:	48 83 c3 08          	add    $0x8,%rbx
 10040f4:	48 3b 5c 24 18       	cmp    0x18(%rsp),%rbx
 10040f9:	72 e3                	jb     10040de <runtime.walkfintab+0x47>
		if(*key != nil && *key != ((void*)-1))
			fn(*key);
	runtime·unlock(&finlock);
 10040fb:	b8 68 4e 02 01       	mov    $0x1024e68,%eax
 1004100:	48 89 04 24          	mov    %rax,(%rsp)
 1004104:	e8 79 8d 00 00       	callq  100ce82 <runtime.unlock>
 1004109:	48 83 c4 28          	add    $0x28,%rsp
 100410d:	c3                   	retq   
	runtime·lock(&finlock);
	key = fintab.key;
	ekey = key + fintab.max;
	for(; key < ekey; key++)
		if(*key != nil && *key != ((void*)-1))
			fn(*key);
 100410e:	48 89 5c 24 20       	mov    %rbx,0x20(%rsp)
 1004113:	48 8b 03             	mov    (%rbx),%rax
 1004116:	48 89 04 24          	mov    %rax,(%rsp)
 100411a:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100411f:	ff d0                	callq  *%rax
 1004121:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
 1004126:	eb c8                	jmp    10040f0 <runtime.walkfintab+0x59>

0000000001004128 <runtime.FixAlloc_Init>:
#include "malloc.h"

// Initialize f to allocate objects of the given size,
// using the allocator to obtain chunks of memory.
void
runtime·FixAlloc_Init(FixAlloc *f, uintptr size, void *(*alloc)(uintptr), void (*first)(void*, byte*), void *arg)
 1004128:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100412f:	ff ff 
 1004131:	48 3b 21             	cmp    (%rcx),%rsp
 1004134:	77 05                	ja     100413b <runtime.FixAlloc_Init+0x13>
 1004136:	e8 35 d8 ff ff       	callq  1001970 <runtime.morestack40>
 100413b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
{
	f->size = size;
 1004140:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
 1004145:	48 89 0a             	mov    %rcx,(%rdx)
	f->alloc = alloc;
 1004148:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
 100414d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	f->first = first;
 1004151:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 1004156:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
	f->arg = arg;
 100415a:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100415f:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
	f->list = nil;
 1004163:	48 c7 42 20 00 00 00 	movq   $0x0,0x20(%rdx)
 100416a:	00 
	f->chunk = nil;
 100416b:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
 1004172:	00 
	f->nchunk = 0;
 1004173:	c7 42 30 00 00 00 00 	movl   $0x0,0x30(%rdx)
	f->inuse = 0;
 100417a:	48 c7 42 38 00 00 00 	movq   $0x0,0x38(%rdx)
 1004181:	00 
	f->sys = 0;
 1004182:	48 c7 42 40 00 00 00 	movq   $0x0,0x40(%rdx)
 1004189:	00 
 100418a:	c3                   	retq   

000000000100418b <runtime.FixAlloc_Alloc>:
}

void*
runtime·FixAlloc_Alloc(FixAlloc *f)
 100418b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004192:	ff ff 
 1004194:	48 3b 21             	cmp    (%rcx),%rsp
 1004197:	77 05                	ja     100419e <runtime.FixAlloc_Alloc+0x13>
 1004199:	e8 ae d7 ff ff       	callq  100194c <runtime.morestack8>
 100419e:	48 83 ec 28          	sub    $0x28,%rsp
 10041a2:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
{
	void *v;

	if(f->list) {
 10041a7:	48 8b 42 20          	mov    0x20(%rdx),%rax
 10041ab:	48 83 f8 00          	cmp    $0x0,%rax
 10041af:	74 1b                	je     10041cc <runtime.FixAlloc_Alloc+0x41>
		v = f->list;
 10041b1:	48 8b 42 20          	mov    0x20(%rdx),%rax
		f->list = *(void**)f->list;
 10041b5:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 10041b9:	48 8b 09             	mov    (%rcx),%rcx
 10041bc:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
		f->inuse += f->size;
 10041c0:	48 8b 0a             	mov    (%rdx),%rcx
 10041c3:	48 01 4a 38          	add    %rcx,0x38(%rdx)
		return v;
 10041c7:	48 83 c4 28          	add    $0x28,%rsp
 10041cb:	c3                   	retq   
	}
	if(f->nchunk < f->size) {
 10041cc:	8b 42 30             	mov    0x30(%rdx),%eax
 10041cf:	48 8b 0a             	mov    (%rdx),%rcx
 10041d2:	48 39 c8             	cmp    %rcx,%rax
 10041d5:	73 46                	jae    100421d <runtime.FixAlloc_Alloc+0x92>
		f->sys += FixAllocChunk;
 10041d7:	48 81 42 40 00 00 02 	addq   $0x20000,0x40(%rdx)
 10041de:	00 
		f->chunk = f->alloc(FixAllocChunk);
 10041df:	48 c7 c1 00 00 02 00 	mov    $0x20000,%rcx
 10041e6:	48 89 0c 24          	mov    %rcx,(%rsp)
 10041ea:	48 8b 42 08          	mov    0x8(%rdx),%rax
 10041ee:	ff d0                	callq  *%rax
 10041f0:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
 10041f5:	48 89 42 28          	mov    %rax,0x28(%rdx)
		if(f->chunk == nil)
 10041f9:	48 8b 42 28          	mov    0x28(%rdx),%rax
 10041fd:	48 83 f8 00          	cmp    $0x0,%rax
 1004201:	75 13                	jne    1004216 <runtime.FixAlloc_Alloc+0x8b>
			runtime·throw("out of memory (FixAlloc)");
 1004203:	b8 70 30 02 01       	mov    $0x1023070,%eax
 1004208:	48 89 04 24          	mov    %rax,(%rsp)
 100420c:	e8 28 5b 00 00       	callq  1009d39 <runtime.throw>
 1004211:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
		f->nchunk = FixAllocChunk;
 1004216:	c7 42 30 00 00 02 00 	movl   $0x20000,0x30(%rdx)
	}
	v = f->chunk;
 100421d:	48 8b 5a 28          	mov    0x28(%rdx),%rbx
	if(f->first)
 1004221:	48 8b 42 10          	mov    0x10(%rdx),%rax
 1004225:	48 83 f8 00          	cmp    $0x0,%rax
 1004229:	74 22                	je     100424d <runtime.FixAlloc_Alloc+0xc2>
		f->first(f->arg, v);
 100422b:	48 8b 42 18          	mov    0x18(%rdx),%rax
 100422f:	48 89 04 24          	mov    %rax,(%rsp)
 1004233:	48 89 5c 24 20       	mov    %rbx,0x20(%rsp)
 1004238:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 100423d:	48 8b 42 10          	mov    0x10(%rdx),%rax
 1004241:	ff d0                	callq  *%rax
 1004243:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
 1004248:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
	f->chunk += f->size;
 100424d:	48 8b 0a             	mov    (%rdx),%rcx
 1004250:	48 01 4a 28          	add    %rcx,0x28(%rdx)
	f->nchunk -= f->size;
 1004254:	48 8b 0a             	mov    (%rdx),%rcx
 1004257:	29 4a 30             	sub    %ecx,0x30(%rdx)
	f->inuse += f->size;
 100425a:	48 8b 0a             	mov    (%rdx),%rcx
 100425d:	48 01 4a 38          	add    %rcx,0x38(%rdx)
	return v;
 1004261:	48 89 d8             	mov    %rbx,%rax
 1004264:	48 83 c4 28          	add    $0x28,%rsp
 1004268:	c3                   	retq   

0000000001004269 <runtime.FixAlloc_Free>:
}

void
runtime·FixAlloc_Free(FixAlloc *f, void *p)
 1004269:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004270:	ff ff 
 1004272:	48 3b 21             	cmp    (%rcx),%rsp
 1004275:	77 05                	ja     100427c <runtime.FixAlloc_Free+0x13>
 1004277:	e8 d9 d6 ff ff       	callq  1001955 <runtime.morestack16>
 100427c:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
 1004281:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
{
	f->inuse -= f->size;
 1004286:	48 8b 0a             	mov    (%rdx),%rcx
 1004289:	48 29 4a 38          	sub    %rcx,0x38(%rdx)
	*(void**)p = f->list;
 100428d:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 1004291:	48 89 0b             	mov    %rcx,(%rbx)
 1004294:	48 89 5a 20          	mov    %rbx,0x20(%rdx)
 1004298:	c3                   	retq   

0000000001004299 <scanblock>:
// unscanned objects left.  Instead of using an explicit recursion, it keeps
// a work list in the Workbuf* structures and loops in the main function
// body.  Keeping an explicit work list is easier on the stack allocator and
// more efficient.
static void
scanblock(byte *b, int64 n)
 1004299:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10042a0:	ff ff 
 10042a2:	48 8d 44 24 b0       	lea    -0x50(%rsp),%rax
 10042a7:	48 3b 01             	cmp    (%rcx),%rax
 10042aa:	77 05                	ja     10042b1 <scanblock+0x18>
 10042ac:	e8 a4 d6 ff ff       	callq  1001955 <runtime.morestack16>
 10042b1:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
 10042b8:	48 8b ac 24 d8 00 00 	mov    0xd8(%rsp),%rbp
 10042bf:	00 
 10042c0:	48 8b 8c 24 e0 00 00 	mov    0xe0(%rsp),%rcx
 10042c7:	00 
	MSpan *s;
	PageID k;
	void **bw, **w, **ew;
	Workbuf *wbuf;

	if((int64)(uintptr)n != n || n < 0) {
 10042c8:	48 39 c9             	cmp    %rcx,%rcx
 10042cb:	0f 85 37 04 00 00    	jne    1004708 <scanblock+0x46f>
 10042d1:	48 83 f9 00          	cmp    $0x0,%rcx
 10042d5:	0f 8c 2d 04 00 00    	jl     1004708 <scanblock+0x46f>
		runtime·printf("scanblock %p %D\n", b, n);
		runtime·throw("scanblock");
	}

	// Memory arena parameters.
	arena_start = runtime·mheap.arena_start;
 10042db:	4c 8b 04 25 e8 e8 03 	mov    0x303e8e8,%r8
 10042e2:	03 
 10042e3:	4c 89 84 24 c0 00 00 	mov    %r8,0xc0(%rsp)
 10042ea:	00 
	
	wbuf = nil;  // current work buffer
 10042eb:	48 31 f6             	xor    %rsi,%rsi
	ew = nil;  // end of work buffer
 10042ee:	4d 31 e4             	xor    %r12,%r12
	bw = nil;  // beginning of work buffer
 10042f1:	4d 31 d2             	xor    %r10,%r10
	w = nil;  // current pointer into work buffer
 10042f4:	48 31 ff             	xor    %rdi,%rdi

	// Align b to a word boundary.
	off = (uintptr)b & (PtrSize-1);
 10042f7:	48 89 ea             	mov    %rbp,%rdx
 10042fa:	48 83 e2 07          	and    $0x7,%rdx
	if(off != 0) {
 10042fe:	48 83 fa 00          	cmp    $0x0,%rdx
 1004302:	74 1a                	je     100431e <scanblock+0x85>
		b += PtrSize - off;
 1004304:	48 c7 c0 08 00 00 00 	mov    $0x8,%rax
 100430b:	48 29 d0             	sub    %rdx,%rax
 100430e:	48 01 c5             	add    %rax,%rbp
		n -= PtrSize - off;
 1004311:	48 c7 c0 08 00 00 00 	mov    $0x8,%rax
 1004318:	48 29 d0             	sub    %rdx,%rax
 100431b:	48 29 c1             	sub    %rax,%rcx
		// Each iteration scans the block b of length n, queueing pointers in
		// the work buffer.
		if(Debug > 1)
			runtime·printf("scanblock %p %D\n", b, n);

		vp = (void**)b;
 100431e:	48 89 ac 24 b0 00 00 	mov    %rbp,0xb0(%rsp)
 1004325:	00 
		n /= PtrSize;
 1004326:	48 89 c8             	mov    %rcx,%rax
 1004329:	48 99                	cqto   
 100432b:	48 c7 c1 08 00 00 00 	mov    $0x8,%rcx
 1004332:	48 f7 f9             	idiv   %rcx
 1004335:	48 89 84 24 e0 00 00 	mov    %rax,0xe0(%rsp)
 100433c:	00 
		for(i=0; i<n; i++) {
 100433d:	4d 31 ed             	xor    %r13,%r13
 1004340:	4c 3b ac 24 e0 00 00 	cmp    0xe0(%rsp),%r13
 1004347:	00 
 1004348:	0f 83 d6 00 00 00    	jae    1004424 <scanblock+0x18b>
			obj = (byte*)vp[i];
 100434e:	4c 89 ac 24 88 00 00 	mov    %r13,0x88(%rsp)
 1004355:	00 
 1004356:	48 8b 94 24 b0 00 00 	mov    0xb0(%rsp),%rdx
 100435d:	00 
 100435e:	4a 8b 0c ea          	mov    (%rdx,%r13,8),%rcx
			
			// Words outside the arena cannot be pointers.
			if((byte*)obj < arena_start || (byte*)obj >= runtime·mheap.arena_used)
 1004362:	4c 39 c1             	cmp    %r8,%rcx
 1004365:	0f 82 a8 00 00 00    	jb     1004413 <scanblock+0x17a>
 100436b:	48 3b 0c 25 f0 e8 03 	cmp    0x303e8f0,%rcx
 1004372:	03 
 1004373:	0f 83 9a 00 00 00    	jae    1004413 <scanblock+0x17a>
			
			// obj may be a pointer to a live object.
			// Try to find the beginning of the object.
			
			// Round down to word boundary.
			obj = (void*)((uintptr)obj & ~((uintptr)PtrSize-1));
 1004379:	48 89 c8             	mov    %rcx,%rax
 100437c:	48 83 e0 f8          	and    $0xfffffffffffffff8,%rax

			// Find bits for this word.
			off = (uintptr*)obj - (uintptr*)arena_start;
 1004380:	48 89 c5             	mov    %rax,%rbp
 1004383:	48 89 84 24 c8 00 00 	mov    %rax,0xc8(%rsp)
 100438a:	00 
 100438b:	4c 29 c0             	sub    %r8,%rax
 100438e:	48 c1 f8 03          	sar    $0x3,%rax
 1004392:	48 89 c2             	mov    %rax,%rdx
			bitp = (uintptr*)arena_start - off/wordsPerBitmapWord - 1;
 1004395:	48 c1 e8 04          	shr    $0x4,%rax
 1004399:	48 c1 e0 03          	shl    $0x3,%rax
 100439d:	4d 89 c1             	mov    %r8,%r9
 10043a0:	49 29 c1             	sub    %rax,%r9
 10043a3:	49 83 c1 f8          	add    $0xfffffffffffffff8,%r9
			shift = off % wordsPerBitmapWord;
 10043a7:	48 83 e2 0f          	and    $0xf,%rdx
			xbits = *bitp;
 10043ab:	49 8b 01             	mov    (%r9),%rax
			bits = xbits >> shift;
 10043ae:	48 63 ca             	movslq %edx,%rcx
 10043b1:	49 89 c3             	mov    %rax,%r11
 10043b4:	48 d3 e8             	shr    %cl,%rax
 10043b7:	48 89 c3             	mov    %rax,%rbx

			// Pointing at the beginning of a block?
			if((bits & (bitAllocated|bitBlockBoundary)) != 0)
 10043ba:	48 25 01 00 01 00    	and    $0x10001,%rax
 10043c0:	48 83 f8 00          	cmp    $0x0,%rax
 10043c4:	0f 84 f5 01 00 00    	je     10045bf <scanblock+0x326>

		found:
			// Now we have bits, bitp, and shift correct for
			// obj pointing at the base of the object.
			// If not allocated or already marked, done.
			if((bits & bitAllocated) == 0 || (bits & bitMarked) != 0)
 10043ca:	48 89 d8             	mov    %rbx,%rax
 10043cd:	48 83 e0 01          	and    $0x1,%rax
 10043d1:	48 83 f8 00          	cmp    $0x0,%rax
 10043d5:	74 3c                	je     1004413 <scanblock+0x17a>
 10043d7:	48 89 d8             	mov    %rbx,%rax
 10043da:	48 b9 00 00 00 00 01 	movabs $0x100000000,%rcx
 10043e1:	00 00 00 
 10043e4:	48 21 c8             	and    %rcx,%rax
 10043e7:	48 83 f8 00          	cmp    $0x0,%rax
 10043eb:	75 26                	jne    1004413 <scanblock+0x17a>
				continue;
			*bitp |= bitMarked<<shift;
 10043ed:	48 63 ca             	movslq %edx,%rcx
 10043f0:	48 b8 00 00 00 00 01 	movabs $0x100000000,%rax
 10043f7:	00 00 00 
 10043fa:	48 d3 e0             	shl    %cl,%rax
 10043fd:	49 09 01             	or     %rax,(%r9)

			// If object has no pointers, don't need to scan further.
			if((bits & bitNoPointers) != 0)
 1004400:	48 89 d8             	mov    %rbx,%rax
 1004403:	48 25 00 00 01 00    	and    $0x10000,%rax
 1004409:	48 83 f8 00          	cmp    $0x0,%rax
 100440d:	0f 84 60 01 00 00    	je     1004573 <scanblock+0x2da>
		if(Debug > 1)
			runtime·printf("scanblock %p %D\n", b, n);

		vp = (void**)b;
		n /= PtrSize;
		for(i=0; i<n; i++) {
 1004413:	49 ff c5             	inc    %r13
 1004416:	4c 3b ac 24 e0 00 00 	cmp    0xe0(%rsp),%r13
 100441d:	00 
 100441e:	0f 82 2a ff ff ff    	jb     100434e <scanblock+0xb5>
		
		// Done scanning [b, b+n).  Prepare for the next iteration of
		// the loop by setting b and n to the parameters for the next block.

		// Fetch b from the work buffers.
		if(w <= bw) {
 1004424:	4c 39 d7             	cmp    %r10,%rdi
 1004427:	77 3e                	ja     1004467 <scanblock+0x1ce>
			// Emptied our buffer: refill.
			wbuf = getfull(wbuf);
 1004429:	48 89 34 24          	mov    %rsi,(%rsp)
 100442d:	e8 c7 03 00 00       	callq  10047f9 <getfull>
 1004432:	4c 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%r8
 1004439:	00 
 100443a:	48 89 c6             	mov    %rax,%rsi
			if(wbuf == nil)
 100443d:	48 83 f8 00          	cmp    $0x0,%rax
 1004441:	75 08                	jne    100444b <scanblock+0x1b2>
		// turns negative, which is undefined in C.		

		for(j=1; j<bitShift; j++) {
			if(((bits>>j)&boundary) != 0 || shift>=j && ((xbits>>(shift-j))&boundary) != 0) {
				n = j*PtrSize;
				goto scan;
 1004443:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
 100444a:	c3                   	retq   
		if(w <= bw) {
			// Emptied our buffer: refill.
			wbuf = getfull(wbuf);
			if(wbuf == nil)
				break;
			bw = wbuf->w;
 100444b:	48 83 c0 10          	add    $0x10,%rax
 100444f:	49 89 c2             	mov    %rax,%r10
			ew = wbuf->w + nelem(wbuf->w);
 1004452:	49 89 f4             	mov    %rsi,%r12
 1004455:	49 81 c4 00 40 00 00 	add    $0x4000,%r12
			w = bw+wbuf->nw;
 100445c:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
 1004460:	48 8d 04 c8          	lea    (%rax,%rcx,8),%rax
 1004464:	48 89 c7             	mov    %rax,%rdi
		}
		b = *--w;
 1004467:	48 83 c7 f8          	add    $0xfffffffffffffff8,%rdi
 100446b:	48 8b 07             	mov    (%rdi),%rax
	
		// Figure out n = size of b.  Start by loading bits for b.
		off = (uintptr*)b - (uintptr*)arena_start;
 100446e:	48 89 c5             	mov    %rax,%rbp
 1004471:	4c 29 c0             	sub    %r8,%rax
 1004474:	48 c1 f8 03          	sar    $0x3,%rax
 1004478:	48 89 c2             	mov    %rax,%rdx
		bitp = (uintptr*)arena_start - off/wordsPerBitmapWord - 1;
 100447b:	48 c1 e8 04          	shr    $0x4,%rax
 100447f:	48 c1 e0 03          	shl    $0x3,%rax
 1004483:	4c 89 c1             	mov    %r8,%rcx
 1004486:	48 29 c1             	sub    %rax,%rcx
 1004489:	48 83 c1 f8          	add    $0xfffffffffffffff8,%rcx
		shift = off % wordsPerBitmapWord;
 100448d:	48 89 d3             	mov    %rdx,%rbx
 1004490:	48 83 e3 0f          	and    $0xf,%rbx
		xbits = *bitp;
 1004494:	48 8b 01             	mov    (%rcx),%rax
		bits = xbits >> shift;
 1004497:	48 63 cb             	movslq %ebx,%rcx
 100449a:	49 89 c3             	mov    %rax,%r11
 100449d:	48 d3 e8             	shr    %cl,%rax
 10044a0:	49 89 c1             	mov    %rax,%r9
		// we'll be bleeding other bit types like bitMarked into our test.)
		// Instead of inserting the conditional shift+j < bitShift into the loop,
		// we can let j range from 1 to bitShift as long as we first
		// apply a mask to keep only the bits corresponding
		// to shift+j < bitShift aka j < bitShift-shift.
		bits &= (boundary<<(bitShift-shift)) - boundary;
 10044a3:	48 c7 c1 10 00 00 00 	mov    $0x10,%rcx
 10044aa:	48 29 d9             	sub    %rbx,%rcx
 10044ad:	48 63 c9             	movslq %ecx,%rcx
 10044b0:	48 c7 c0 01 00 01 00 	mov    $0x10001,%rax
 10044b7:	48 d3 e0             	shl    %cl,%rax
 10044ba:	48 05 ff ff fe ff    	add    $0xfffffffffffeffff,%rax
 10044c0:	49 21 c1             	and    %rax,%r9
		//	xbits>>(shift-j) & boundary
		// (assuming shift >= j).  There is no cleverness here
		// avoid the test, because when j gets too large the shift
		// turns negative, which is undefined in C.		

		for(j=1; j<bitShift; j++) {
 10044c3:	48 c7 c2 01 00 00 00 	mov    $0x1,%rdx
 10044ca:	48 83 fa 10          	cmp    $0x10,%rdx
 10044ce:	73 4d                	jae    100451d <scanblock+0x284>
			if(((bits>>j)&boundary) != 0 || shift>=j && ((xbits>>(shift-j))&boundary) != 0) {
 10044d0:	48 63 ca             	movslq %edx,%rcx
 10044d3:	4c 89 c8             	mov    %r9,%rax
 10044d6:	48 d3 e8             	shr    %cl,%rax
 10044d9:	48 25 01 00 01 00    	and    $0x10001,%rax
 10044df:	48 83 f8 00          	cmp    $0x0,%rax
 10044e3:	75 20                	jne    1004505 <scanblock+0x26c>
 10044e5:	48 39 d3             	cmp    %rdx,%rbx
 10044e8:	72 2a                	jb     1004514 <scanblock+0x27b>
 10044ea:	48 89 d9             	mov    %rbx,%rcx
 10044ed:	48 29 d1             	sub    %rdx,%rcx
 10044f0:	48 63 c9             	movslq %ecx,%rcx
 10044f3:	4c 89 d8             	mov    %r11,%rax
 10044f6:	48 d3 e8             	shr    %cl,%rax
 10044f9:	48 25 01 00 01 00    	and    $0x10001,%rax
 10044ff:	48 83 f8 00          	cmp    $0x0,%rax
 1004503:	74 0f                	je     1004514 <scanblock+0x27b>
				n = j*PtrSize;
 1004505:	48 89 d0             	mov    %rdx,%rax
 1004508:	48 c1 e0 03          	shl    $0x3,%rax
 100450c:	48 89 c1             	mov    %rax,%rcx
		// Each iteration scans the block b of length n, queueing pointers in
		// the work buffer.
		if(Debug > 1)
			runtime·printf("scanblock %p %D\n", b, n);

		vp = (void**)b;
 100450f:	e9 0a fe ff ff       	jmpq   100431e <scanblock+0x85>
		//	xbits>>(shift-j) & boundary
		// (assuming shift >= j).  There is no cleverness here
		// avoid the test, because when j gets too large the shift
		// turns negative, which is undefined in C.		

		for(j=1; j<bitShift; j++) {
 1004514:	48 ff c2             	inc    %rdx
 1004517:	48 83 fa 10          	cmp    $0x10,%rdx
 100451b:	72 b3                	jb     10044d0 <scanblock+0x237>
			}
		}
		
		// Fall back to asking span about size class.
		// (Manually inlined copy of MHeap_Lookup.)
		nlookup++;
 100451d:	48 ff 04 25 b8 4e 02 	incq   0x1024eb8
 1004524:	01 
		nsizelookup++;
 1004525:	48 ff 04 25 c0 4e 02 	incq   0x1024ec0
 100452c:	01 
		x = (uintptr)b>>PageShift;
 100452d:	48 89 e8             	mov    %rbp,%rax
 1004530:	48 c1 e8 0c          	shr    $0xc,%rax
 1004534:	48 89 c2             	mov    %rax,%rdx
		if(sizeof(void*) == 8)
			x -= (uintptr)arena_start>>PageShift;
 1004537:	4c 89 c0             	mov    %r8,%rax
 100453a:	48 c1 e8 0c          	shr    $0xc,%rax
 100453e:	48 29 c2             	sub    %rax,%rdx
		s = runtime·mheap.map[x];
 1004541:	48 8b 14 d5 d8 e8 03 	mov    0x103e8d8(,%rdx,8),%rdx
 1004548:	01 
		if(s->sizeclass == 0)
 1004549:	8b 42 34             	mov    0x34(%rdx),%eax
 100454c:	83 f8 00             	cmp    $0x0,%eax
 100454f:	75 10                	jne    1004561 <scanblock+0x2c8>
			n = s->npages<<PageShift;
 1004551:	48 8b 42 20          	mov    0x20(%rdx),%rax
 1004555:	48 c1 e0 0c          	shl    $0xc,%rax
 1004559:	48 89 c1             	mov    %rax,%rcx
		// Each iteration scans the block b of length n, queueing pointers in
		// the work buffer.
		if(Debug > 1)
			runtime·printf("scanblock %p %D\n", b, n);

		vp = (void**)b;
 100455c:	e9 bd fd ff ff       	jmpq   100431e <scanblock+0x85>
			x -= (uintptr)arena_start>>PageShift;
		s = runtime·mheap.map[x];
		if(s->sizeclass == 0)
			n = s->npages<<PageShift;
		else
			n = runtime·class_to_size[s->sizeclass];
 1004561:	8b 4a 34             	mov    0x34(%rdx),%ecx
 1004564:	8b 0c 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%ecx
 100456b:	48 63 c9             	movslq %ecx,%rcx
		// Each iteration scans the block b of length n, queueing pointers in
		// the work buffer.
		if(Debug > 1)
			runtime·printf("scanblock %p %D\n", b, n);

		vp = (void**)b;
 100456e:	e9 ab fd ff ff       	jmpq   100431e <scanblock+0x85>
			// If object has no pointers, don't need to scan further.
			if((bits & bitNoPointers) != 0)
				continue;

			// If buffer is full, get a new one.
			if(w >= ew) {
 1004573:	4c 39 e7             	cmp    %r12,%rdi
 1004576:	72 38                	jb     10045b0 <scanblock+0x317>
				wbuf = getempty(wbuf);
 1004578:	48 89 34 24          	mov    %rsi,(%rsp)
 100457c:	e8 c2 01 00 00       	callq  1004743 <getempty>
 1004581:	4c 8b ac 24 88 00 00 	mov    0x88(%rsp),%r13
 1004588:	00 
 1004589:	4c 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%r8
 1004590:	00 
 1004591:	48 8b ac 24 c8 00 00 	mov    0xc8(%rsp),%rbp
 1004598:	00 
 1004599:	48 89 c6             	mov    %rax,%rsi
				bw = wbuf->w;
 100459c:	48 83 c0 10          	add    $0x10,%rax
 10045a0:	49 89 c2             	mov    %rax,%r10
				w = bw;
 10045a3:	48 89 c7             	mov    %rax,%rdi
				ew = bw + nelem(wbuf->w);
 10045a6:	49 89 c4             	mov    %rax,%r12
 10045a9:	49 81 c4 f0 3f 00 00 	add    $0x3ff0,%r12
			}
			*w++ = obj;
 10045b0:	48 89 f8             	mov    %rdi,%rax
 10045b3:	48 83 c7 08          	add    $0x8,%rdi
 10045b7:	48 89 28             	mov    %rbp,(%rax)
		if(Debug > 1)
			runtime·printf("scanblock %p %D\n", b, n);

		vp = (void**)b;
		n /= PtrSize;
		for(i=0; i<n; i++) {
 10045ba:	e9 54 fe ff ff       	jmpq   1004413 <scanblock+0x17a>
			if((bits & (bitAllocated|bitBlockBoundary)) != 0)
				goto found;

			// Pointing just past the beginning?
			// Scan backward a little to find a block boundary.
			for(j=shift; j-->0; ) {
 10045bf:	48 89 d3             	mov    %rdx,%rbx
 10045c2:	48 89 d8             	mov    %rbx,%rax
 10045c5:	48 ff cb             	dec    %rbx
 10045c8:	48 83 f8 00          	cmp    $0x0,%rax
 10045cc:	76 3e                	jbe    100460c <scanblock+0x373>
				if(((xbits>>j) & (bitAllocated|bitBlockBoundary)) != 0) {
 10045ce:	48 63 cb             	movslq %ebx,%rcx
 10045d1:	4c 89 d8             	mov    %r11,%rax
 10045d4:	48 d3 e8             	shr    %cl,%rax
 10045d7:	48 25 01 00 01 00    	and    $0x10001,%rax
 10045dd:	48 83 f8 00          	cmp    $0x0,%rax
 10045e1:	74 df                	je     10045c2 <scanblock+0x329>
					obj = (byte*)obj - (shift-j)*PtrSize;
 10045e3:	48 89 d0             	mov    %rdx,%rax
 10045e6:	48 29 d8             	sub    %rbx,%rax
 10045e9:	48 c1 e0 03          	shl    $0x3,%rax
 10045ed:	48 29 c5             	sub    %rax,%rbp
 10045f0:	48 89 ac 24 c8 00 00 	mov    %rbp,0xc8(%rsp)
 10045f7:	00 
					shift = j;
 10045f8:	48 89 da             	mov    %rbx,%rdx
					bits = xbits>>shift;
 10045fb:	48 63 cb             	movslq %ebx,%rcx
 10045fe:	4c 89 d8             	mov    %r11,%rax
 1004601:	48 d3 e8             	shr    %cl,%rax
 1004604:	48 89 c3             	mov    %rax,%rbx

		found:
			// Now we have bits, bitp, and shift correct for
			// obj pointing at the base of the object.
			// If not allocated or already marked, done.
			if((bits & bitAllocated) == 0 || (bits & bitMarked) != 0)
 1004607:	e9 be fd ff ff       	jmpq   10043ca <scanblock+0x131>
				}
			}

			// Otherwise consult span table to find beginning.
			// (Manually inlined copy of MHeap_LookupMaybe.)
			nlookup++;
 100460c:	48 ff 04 25 b8 4e 02 	incq   0x1024eb8
 1004613:	01 
			naddrlookup++;
 1004614:	48 ff 04 25 b0 4e 02 	incq   0x1024eb0
 100461b:	01 
			k = (uintptr)obj>>PageShift;
 100461c:	48 89 e8             	mov    %rbp,%rax
 100461f:	48 c1 e8 0c          	shr    $0xc,%rax
 1004623:	48 89 c3             	mov    %rax,%rbx
			x = k;
 1004626:	48 89 c2             	mov    %rax,%rdx
			if(sizeof(void*) == 8)
				x -= (uintptr)arena_start>>PageShift;
 1004629:	4c 89 c0             	mov    %r8,%rax
 100462c:	48 c1 e8 0c          	shr    $0xc,%rax
 1004630:	48 29 c2             	sub    %rax,%rdx
			s = runtime·mheap.map[x];
 1004633:	48 8b 14 d5 d8 e8 03 	mov    0x103e8d8(,%rdx,8),%rdx
 100463a:	01 
			if(s == nil || k < s->start || k - s->start >= s->npages || s->state != MSpanInUse)
 100463b:	48 83 fa 00          	cmp    $0x0,%rdx
 100463f:	0f 84 ce fd ff ff    	je     1004413 <scanblock+0x17a>
 1004645:	48 8b 42 18          	mov    0x18(%rdx),%rax
 1004649:	48 39 c3             	cmp    %rax,%rbx
 100464c:	0f 82 c1 fd ff ff    	jb     1004413 <scanblock+0x17a>
 1004652:	48 8b 42 18          	mov    0x18(%rdx),%rax
 1004656:	48 89 d9             	mov    %rbx,%rcx
 1004659:	48 29 c1             	sub    %rax,%rcx
 100465c:	48 89 c8             	mov    %rcx,%rax
 100465f:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 1004663:	48 39 c8             	cmp    %rcx,%rax
 1004666:	0f 83 a7 fd ff ff    	jae    1004413 <scanblock+0x17a>
 100466c:	8b 42 38             	mov    0x38(%rdx),%eax
 100466f:	83 f8 00             	cmp    $0x0,%eax
 1004672:	0f 85 9b fd ff ff    	jne    1004413 <scanblock+0x17a>
				continue;
			p =  (byte*)((uintptr)s->start<<PageShift);
 1004678:	48 8b 42 18          	mov    0x18(%rdx),%rax
 100467c:	48 c1 e0 0c          	shl    $0xc,%rax
 1004680:	48 89 c3             	mov    %rax,%rbx
			if(s->sizeclass == 0) {
 1004683:	8b 42 34             	mov    0x34(%rdx),%eax
 1004686:	83 f8 00             	cmp    $0x0,%eax
 1004689:	75 3f                	jne    10046ca <scanblock+0x431>
				obj = p;
 100468b:	48 89 dd             	mov    %rbx,%rbp
				int32 i = ((byte*)obj - p)/size;
				obj = p+i*size;
			}

			// Now that we know the object header, reload bits.
			off = (uintptr*)obj - (uintptr*)arena_start;
 100468e:	48 89 e8             	mov    %rbp,%rax
 1004691:	48 89 ac 24 c8 00 00 	mov    %rbp,0xc8(%rsp)
 1004698:	00 
 1004699:	4c 29 c0             	sub    %r8,%rax
 100469c:	48 c1 f8 03          	sar    $0x3,%rax
 10046a0:	48 89 c2             	mov    %rax,%rdx
			bitp = (uintptr*)arena_start - off/wordsPerBitmapWord - 1;
 10046a3:	48 c1 e8 04          	shr    $0x4,%rax
 10046a7:	48 c1 e0 03          	shl    $0x3,%rax
 10046ab:	4d 89 c1             	mov    %r8,%r9
 10046ae:	49 29 c1             	sub    %rax,%r9
 10046b1:	49 83 c1 f8          	add    $0xfffffffffffffff8,%r9
			shift = off % wordsPerBitmapWord;
 10046b5:	48 83 e2 0f          	and    $0xf,%rdx
			xbits = *bitp;
 10046b9:	49 8b 01             	mov    (%r9),%rax
			bits = xbits >> shift;
 10046bc:	48 63 ca             	movslq %edx,%rcx
 10046bf:	48 d3 e8             	shr    %cl,%rax
 10046c2:	48 89 c3             	mov    %rax,%rbx

		found:
			// Now we have bits, bitp, and shift correct for
			// obj pointing at the base of the object.
			// If not allocated or already marked, done.
			if((bits & bitAllocated) == 0 || (bits & bitMarked) != 0)
 10046c5:	e9 00 fd ff ff       	jmpq   10043ca <scanblock+0x131>
				continue;
			p =  (byte*)((uintptr)s->start<<PageShift);
			if(s->sizeclass == 0) {
				obj = p;
			} else {
				if((byte*)obj >= (byte*)s->limit)
 10046ca:	48 8b 42 40          	mov    0x40(%rdx),%rax
 10046ce:	48 39 c5             	cmp    %rax,%rbp
 10046d1:	0f 83 3c fd ff ff    	jae    1004413 <scanblock+0x17a>
					continue;
				size = runtime·class_to_size[s->sizeclass];
 10046d7:	8b 4a 34             	mov    0x34(%rdx),%ecx
 10046da:	8b 0c 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%ecx
 10046e1:	48 63 c9             	movslq %ecx,%rcx
				int32 i = ((byte*)obj - p)/size;
 10046e4:	48 89 e8             	mov    %rbp,%rax
 10046e7:	48 29 d8             	sub    %rbx,%rax
 10046ea:	31 d2                	xor    %edx,%edx
 10046ec:	48 f7 f1             	div    %rcx
 10046ef:	48 63 c0             	movslq %eax,%rax
				obj = p+i*size;
 10046f2:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 10046f7:	48 63 c0             	movslq %eax,%rax
 10046fa:	48 f7 e1             	mul    %rcx
 10046fd:	48 8b 6c 24 20       	mov    0x20(%rsp),%rbp
 1004702:	48 8d 2c 03          	lea    (%rbx,%rax,1),%rbp
			}

			// Now that we know the object header, reload bits.
			off = (uintptr*)obj - (uintptr*)arena_start;
 1004706:	eb 86                	jmp    100468e <scanblock+0x3f5>
	PageID k;
	void **bw, **w, **ew;
	Workbuf *wbuf;

	if((int64)(uintptr)n != n || n < 0) {
		runtime·printf("scanblock %p %D\n", b, n);
 1004708:	b8 b0 3e 02 01       	mov    $0x1023eb0,%eax
 100470d:	48 89 04 24          	mov    %rax,(%rsp)
 1004711:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
 1004716:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100471b:	e8 1e 2c 00 00       	callq  100733e <runtime.printf>
		runtime·throw("scanblock");
 1004720:	b8 c1 3e 02 01       	mov    $0x1023ec1,%eax
 1004725:	48 89 04 24          	mov    %rax,(%rsp)
 1004729:	e8 0b 56 00 00       	callq  1009d39 <runtime.throw>
 100472e:	48 8b ac 24 d8 00 00 	mov    0xd8(%rsp),%rbp
 1004735:	00 
 1004736:	48 8b 8c 24 e0 00 00 	mov    0xe0(%rsp),%rcx
 100473d:	00 
	}

	// Memory arena parameters.
	arena_start = runtime·mheap.arena_start;
 100473e:	e9 98 fb ff ff       	jmpq   10042db <scanblock+0x42>

0000000001004743 <getempty>:
} work;

// Get an empty work buffer off the work.empty list,
// allocating new buffers as needed.
static Workbuf*
getempty(Workbuf *b)
 1004743:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100474a:	ff ff 
 100474c:	48 3b 21             	cmp    (%rcx),%rsp
 100474f:	77 05                	ja     1004756 <getempty+0x13>
 1004751:	e8 f6 d1 ff ff       	callq  100194c <runtime.morestack8>
 1004756:	48 83 ec 10          	sub    $0x10,%rsp
 100475a:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
{
	if(b != nil) {
 100475f:	48 83 fa 00          	cmp    $0x0,%rdx
 1004763:	74 1b                	je     1004780 <getempty+0x3d>
		b->nw = nelem(b->w);
 1004765:	48 c7 42 08 fe 07 00 	movq   $0x7fe,0x8(%rdx)
 100476c:	00 
		b->next = work.full;
 100476d:	48 8b 0c 25 50 4f 02 	mov    0x1024f50,%rcx
 1004774:	01 
 1004775:	48 89 0a             	mov    %rcx,(%rdx)
		work.full = b;
 1004778:	48 89 14 25 50 4f 02 	mov    %rdx,0x1024f50
 100477f:	01 
	}
	b = work.empty;
 1004780:	48 8b 0c 25 58 4f 02 	mov    0x1024f58,%rcx
 1004787:	01 
	if(b != nil) {
 1004788:	48 83 f9 00          	cmp    $0x0,%rcx
 100478c:	74 13                	je     10047a1 <getempty+0x5e>
		work.empty = b->next;
 100478e:	48 8b 01             	mov    (%rcx),%rax
 1004791:	48 89 04 25 58 4f 02 	mov    %rax,0x1024f58
 1004798:	01 
		return b;
 1004799:	48 89 c8             	mov    %rcx,%rax
 100479c:	48 83 c4 10          	add    $0x10,%rsp
 10047a0:	c3                   	retq   
	}
	
	if(work.nchunk < sizeof *b) {
 10047a1:	48 81 3c 25 68 4f 02 	cmpq   $0x4000,0x1024f68
 10047a8:	01 00 40 00 00 
 10047ad:	73 25                	jae    10047d4 <getempty+0x91>
		work.nchunk = 1<<20;
 10047af:	48 c7 04 25 68 4f 02 	movq   $0x100000,0x1024f68
 10047b6:	01 00 00 10 00 
		work.chunk = runtime·SysAlloc(work.nchunk);
 10047bb:	48 8b 0c 25 68 4f 02 	mov    0x1024f68,%rcx
 10047c2:	01 
 10047c3:	48 89 0c 24          	mov    %rcx,(%rsp)
 10047c7:	e8 cd f4 ff ff       	callq  1003c99 <runtime.SysAlloc>
 10047cc:	48 89 04 25 60 4f 02 	mov    %rax,0x1024f60
 10047d3:	01 
	}
	b = (Workbuf*)work.chunk;
 10047d4:	48 8b 04 25 60 4f 02 	mov    0x1024f60,%rax
 10047db:	01 
	work.chunk += sizeof *b;
 10047dc:	48 81 04 25 60 4f 02 	addq   $0x4000,0x1024f60
 10047e3:	01 00 40 00 00 
	work.nchunk -= sizeof *b;
 10047e8:	48 81 2c 25 68 4f 02 	subq   $0x4000,0x1024f68
 10047ef:	01 00 40 00 00 
	return b;
 10047f4:	48 83 c4 10          	add    $0x10,%rsp
 10047f8:	c3                   	retq   

00000000010047f9 <getfull>:
}

// Get a full work buffer off the work.full list, or return nil.
static Workbuf*
getfull(Workbuf *b)
 10047f9:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004800:	ff ff 
 1004802:	48 3b 21             	cmp    (%rcx),%rsp
 1004805:	77 05                	ja     100480c <getfull+0x13>
 1004807:	e8 40 d1 ff ff       	callq  100194c <runtime.morestack8>
 100480c:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
{
	if(b != nil) {
 1004811:	48 83 fa 00          	cmp    $0x0,%rdx
 1004815:	74 1b                	je     1004832 <getfull+0x39>
		b->nw = 0;
 1004817:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
 100481e:	00 
		b->next = work.empty;
 100481f:	48 8b 0c 25 58 4f 02 	mov    0x1024f58,%rcx
 1004826:	01 
 1004827:	48 89 0a             	mov    %rcx,(%rdx)
		work.empty = b;
 100482a:	48 89 14 25 58 4f 02 	mov    %rdx,0x1024f58
 1004831:	01 
	}
	b = work.full;
 1004832:	48 8b 0c 25 50 4f 02 	mov    0x1024f50,%rcx
 1004839:	01 
	if(b != nil)
 100483a:	48 83 f9 00          	cmp    $0x0,%rcx
 100483e:	74 0b                	je     100484b <getfull+0x52>
		work.full = b->next;
 1004840:	48 8b 01             	mov    (%rcx),%rax
 1004843:	48 89 04 25 50 4f 02 	mov    %rax,0x1024f50
 100484a:	01 
	return b;
 100484b:	48 89 c8             	mov    %rcx,%rax
 100484e:	c3                   	retq   

000000000100484f <scanstack>:
}

// Scanstack calls scanblock on each of gp's stack segments.
static void
scanstack(G *gp)
 100484f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004856:	ff ff 
 1004858:	48 3b 21             	cmp    (%rcx),%rsp
 100485b:	77 05                	ja     1004862 <scanstack+0x13>
 100485d:	e8 ea d0 ff ff       	callq  100194c <runtime.morestack8>
 1004862:	48 83 ec 58          	sub    $0x58,%rsp
{
	int32 n;
	Stktop *stk;
	byte *sp, *guard;

	stk = (Stktop*)gp->stackbase;
 1004866:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 100486b:	48 8b 58 08          	mov    0x8(%rax),%rbx
	guard = gp->stackguard;
 100486f:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1004874:	48 8b 10             	mov    (%rax),%rdx

	if(gp == g) {
 1004877:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100487e:	ff ff 
 1004880:	48 39 44 24 60       	cmp    %rax,0x60(%rsp)
 1004885:	0f 85 c2 00 00 00    	jne    100494d <scanstack+0xfe>
		// Scanning our own stack: start at &gp.
		sp = (byte*)&gp;
 100488b:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
 1004890:	48 89 c1             	mov    %rax,%rcx
		}
	}

	if(Debug > 1)
		runtime·printf("scanstack %d %p\n", gp->goid, sp);
	n = 0;
 1004893:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%rsp)
 100489a:	00 
	while(stk) {
 100489b:	48 83 fb 00          	cmp    $0x0,%rbx
 100489f:	74 46                	je     10048e7 <scanstack+0x98>
		if(sp < guard-StackGuard || (byte*)stk < sp) {
 10048a1:	48 89 d0             	mov    %rdx,%rax
 10048a4:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 10048aa:	48 39 c1             	cmp    %rax,%rcx
 10048ad:	72 3d                	jb     10048ec <scanstack+0x9d>
 10048af:	48 39 cb             	cmp    %rcx,%rbx
 10048b2:	72 38                	jb     10048ec <scanstack+0x9d>
			runtime·printf("scanstack inconsistent: g%d#%d sp=%p not in [%p,%p]\n", gp->goid, n, sp, guard-StackGuard, stk);
			runtime·throw("scanstack");
		}
		scanblock(sp, (byte*)stk - sp);
 10048b4:	48 89 0c 24          	mov    %rcx,(%rsp)
 10048b8:	48 89 d8             	mov    %rbx,%rax
 10048bb:	48 89 5c 24 48       	mov    %rbx,0x48(%rsp)
 10048c0:	48 29 c8             	sub    %rcx,%rax
 10048c3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10048c8:	e8 cc f9 ff ff       	callq  1004299 <scanblock>
 10048cd:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
		sp = stk->gobuf.sp;
 10048d2:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
		guard = stk->stackguard;
 10048d6:	48 8b 13             	mov    (%rbx),%rdx
		stk = (Stktop*)stk->stackbase;
 10048d9:	48 8b 5b 08          	mov    0x8(%rbx),%rbx
		n++;
 10048dd:	ff 44 24 54          	incl   0x54(%rsp)
	}

	if(Debug > 1)
		runtime·printf("scanstack %d %p\n", gp->goid, sp);
	n = 0;
	while(stk) {
 10048e1:	48 83 fb 00          	cmp    $0x0,%rbx
 10048e5:	75 ba                	jne    10048a1 <scanstack+0x52>
		}
		scanblock(sp, (byte*)stk - sp);
		sp = stk->gobuf.sp;
		guard = stk->stackguard;
		stk = (Stktop*)stk->stackbase;
		n++;
 10048e7:	48 83 c4 58          	add    $0x58,%rsp
 10048eb:	c3                   	retq   
	if(Debug > 1)
		runtime·printf("scanstack %d %p\n", gp->goid, sp);
	n = 0;
	while(stk) {
		if(sp < guard-StackGuard || (byte*)stk < sp) {
			runtime·printf("scanstack inconsistent: g%d#%d sp=%p not in [%p,%p]\n", gp->goid, n, sp, guard-StackGuard, stk);
 10048ec:	b8 cb 3e 02 01       	mov    $0x1023ecb,%eax
 10048f1:	48 89 04 24          	mov    %rax,(%rsp)
 10048f5:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 10048fa:	8b 40 74             	mov    0x74(%rax),%eax
 10048fd:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1004901:	8b 44 24 54          	mov    0x54(%rsp),%eax
 1004905:	89 44 24 0c          	mov    %eax,0xc(%rsp)
 1004909:	48 89 4c 24 40       	mov    %rcx,0x40(%rsp)
 100490e:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 1004913:	48 89 d0             	mov    %rdx,%rax
 1004916:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 100491c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1004921:	48 89 5c 24 48       	mov    %rbx,0x48(%rsp)
 1004926:	48 89 5c 24 20       	mov    %rbx,0x20(%rsp)
 100492b:	e8 0e 2a 00 00       	callq  100733e <runtime.printf>
			runtime·throw("scanstack");
 1004930:	b8 00 3f 02 01       	mov    $0x1023f00,%eax
 1004935:	48 89 04 24          	mov    %rax,(%rsp)
 1004939:	e8 fb 53 00 00       	callq  1009d39 <runtime.throw>
 100493e:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
 1004943:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
		}
		scanblock(sp, (byte*)stk - sp);
 1004948:	e9 67 ff ff ff       	jmpq   10048b4 <scanstack+0x65>
		// Scanning our own stack: start at &gp.
		sp = (byte*)&gp;
	} else {
		// Scanning another goroutine's stack.
		// The goroutine is usually asleep (the world is stopped).
		sp = gp->sched.sp;
 100494d:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1004952:	48 8b 48 20          	mov    0x20(%rax),%rcx
		// The exception is that if the goroutine is about to enter or might
		// have just exited a system call, it may be executing code such
		// as schedlock and may have needed to start a new stack segment.
		// Use the stack segment and stack pointer at the time of
		// the system call instead, since that won't change underfoot.
		if(gp->gcstack != nil) {
 1004956:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 100495b:	48 8b 40 38          	mov    0x38(%rax),%rax
 100495f:	48 83 f8 00          	cmp    $0x0,%rax
 1004963:	0f 84 2a ff ff ff    	je     1004893 <scanstack+0x44>
			stk = (Stktop*)gp->gcstack;
 1004969:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 100496e:	48 8b 58 38          	mov    0x38(%rax),%rbx
			sp = gp->gcsp;
 1004972:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1004977:	48 8b 48 40          	mov    0x40(%rax),%rcx
			guard = gp->gcguard;
 100497b:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1004980:	48 8b 50 48          	mov    0x48(%rax),%rdx
		}
	}

	if(Debug > 1)
		runtime·printf("scanstack %d %p\n", gp->goid, sp);
	n = 0;
 1004984:	e9 0a ff ff ff       	jmpq   1004893 <scanstack+0x44>

0000000001004989 <markfin>:
}

// Markfin calls scanblock on the blocks that have finalizers:
// the things pointed at cannot be freed until the finalizers have run.
static void
markfin(void *v)
 1004989:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004990:	ff ff 
 1004992:	48 3b 21             	cmp    (%rcx),%rsp
 1004995:	77 05                	ja     100499c <markfin+0x13>
 1004997:	e8 b0 cf ff ff       	callq  100194c <runtime.morestack8>
 100499c:	48 83 ec 38          	sub    $0x38,%rsp
{
	uintptr size;

	size = 0;
 10049a0:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
 10049a7:	00 00 
	if(!runtime·mlookup(v, &v, &size, nil) || !runtime·blockspecial(v))
 10049a9:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 10049ae:	48 89 0c 24          	mov    %rcx,(%rsp)
 10049b2:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
 10049b7:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10049bc:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
 10049c1:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 10049c6:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
 10049cd:	00 00 
 10049cf:	e8 0c e3 ff ff       	callq  1002ce0 <runtime.mlookup>
 10049d4:	83 f8 00             	cmp    $0x0,%eax
 10049d7:	74 30                	je     1004a09 <markfin+0x80>
 10049d9:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 10049de:	48 89 0c 24          	mov    %rcx,(%rsp)
 10049e2:	e8 e0 10 00 00       	callq  1005ac7 <runtime.blockspecial>
 10049e7:	80 f8 00             	cmp    $0x0,%al
 10049ea:	74 1d                	je     1004a09 <markfin+0x80>
		runtime·throw("mark - finalizer inconsistency");

	// do not mark the finalizer block itself.  just mark the things it points at.
	scanblock(v, size);
 10049ec:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 10049f1:	48 89 04 24          	mov    %rax,(%rsp)
 10049f5:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 10049fa:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10049ff:	e8 95 f8 ff ff       	callq  1004299 <scanblock>
 1004a04:	48 83 c4 38          	add    $0x38,%rsp
 1004a08:	c3                   	retq   
{
	uintptr size;

	size = 0;
	if(!runtime·mlookup(v, &v, &size, nil) || !runtime·blockspecial(v))
		runtime·throw("mark - finalizer inconsistency");
 1004a09:	b8 0a 3f 02 01       	mov    $0x1023f0a,%eax
 1004a0e:	48 89 04 24          	mov    %rax,(%rsp)
 1004a12:	e8 22 53 00 00       	callq  1009d39 <runtime.throw>

	// do not mark the finalizer block itself.  just mark the things it points at.
	scanblock(v, size);
 1004a17:	eb d3                	jmp    10049ec <markfin+0x63>

0000000001004a19 <mark>:
}

// Mark 
static void
mark(void)
 1004a19:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004a20:	ff ff 
 1004a22:	48 3b 21             	cmp    (%rcx),%rsp
 1004a25:	77 05                	ja     1004a2c <mark+0x13>
 1004a27:	e8 c7 ce ff ff       	callq  10018f3 <runtime.morestack00>
 1004a2c:	48 83 ec 28          	sub    $0x28,%rsp
	G *gp;

	// mark data+bss.
	// skip runtime·mheap itself, which has no interesting pointers
	// and is mostly zeroed and would not otherwise be paged in.
	scanblock(data, (byte*)&runtime·mheap - data);
 1004a30:	b8 00 30 02 01       	mov    $0x1023000,%eax
 1004a35:	48 89 04 24          	mov    %rax,(%rsp)
 1004a39:	b8 80 a0 03 01       	mov    $0x103a080,%eax
 1004a3e:	48 2d 00 30 02 01    	sub    $0x1023000,%rax
 1004a44:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1004a49:	e8 4b f8 ff ff       	callq  1004299 <scanblock>
	scanblock((byte*)(&runtime·mheap+1), end - (byte*)(&runtime·mheap+1));
 1004a4e:	b8 98 11 04 03       	mov    $0x3041198,%eax
 1004a53:	48 89 04 24          	mov    %rax,(%rsp)
 1004a57:	b8 98 11 04 03       	mov    $0x3041198,%eax
 1004a5c:	48 05 e8 8e ff fd    	add    $0xfffffffffdff8ee8,%rax
 1004a62:	48 2d 80 a0 03 01    	sub    $0x103a080,%rax
 1004a68:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1004a6d:	e8 27 f8 ff ff       	callq  1004299 <scanblock>

	// mark stacks
	for(gp=runtime·allg; gp!=nil; gp=gp->alllink) {
 1004a72:	48 8b 0c 25 d8 4e 02 	mov    0x1024ed8,%rcx
 1004a79:	01 
 1004a7a:	48 83 f9 00          	cmp    $0x0,%rcx
 1004a7e:	74 59                	je     1004ad9 <mark+0xc0>
			break;
		case Grunnable:
		case Gsyscall:
		case Gwaiting:
			scanstack(gp);
			break;
 1004a80:	0f bf 41 70          	movswl 0x70(%rcx),%eax
 1004a84:	83 f8 03             	cmp    $0x3,%eax
 1004a87:	0f 8f aa 00 00 00    	jg     1004b37 <mark+0x11e>
 1004a8d:	0f 84 8f 00 00 00    	je     1004b22 <mark+0x109>
 1004a93:	83 f8 01             	cmp    $0x1,%eax
 1004a96:	0f 84 86 00 00 00    	je     1004b22 <mark+0x109>
 1004a9c:	83 f8 02             	cmp    $0x2,%eax
 1004a9f:	74 4b                	je     1004aec <mark+0xd3>

	// mark stacks
	for(gp=runtime·allg; gp!=nil; gp=gp->alllink) {
		switch(gp->status){
		default:
			runtime·printf("unexpected G.status %d\n", gp->status);
 1004aa1:	b8 29 3f 02 01       	mov    $0x1023f29,%eax
 1004aa6:	48 89 04 24          	mov    %rax,(%rsp)
 1004aaa:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 1004aaf:	0f bf 41 70          	movswl 0x70(%rcx),%eax
 1004ab3:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1004ab7:	e8 82 28 00 00       	callq  100733e <runtime.printf>
			runtime·throw("mark - bad status");
 1004abc:	b8 41 3f 02 01       	mov    $0x1023f41,%eax
 1004ac1:	48 89 04 24          	mov    %rax,(%rsp)
 1004ac5:	e8 6f 52 00 00       	callq  1009d39 <runtime.throw>
 1004aca:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
	// and is mostly zeroed and would not otherwise be paged in.
	scanblock(data, (byte*)&runtime·mheap - data);
	scanblock((byte*)(&runtime·mheap+1), end - (byte*)(&runtime·mheap+1));

	// mark stacks
	for(gp=runtime·allg; gp!=nil; gp=gp->alllink) {
 1004acf:	48 8b 49 60          	mov    0x60(%rcx),%rcx
 1004ad3:	48 83 f9 00          	cmp    $0x0,%rcx
 1004ad7:	75 a7                	jne    1004a80 <mark+0x67>
			break;
		}
	}

	// mark things pointed at by objects with finalizers
	runtime·walkfintab(markfin);
 1004ad9:	b8 89 49 00 01       	mov    $0x1004989,%eax
 1004ade:	48 89 04 24          	mov    %rax,(%rsp)
 1004ae2:	e8 b0 f5 ff ff       	callq  1004097 <runtime.walkfintab>
 1004ae7:	48 83 c4 28          	add    $0x28,%rsp
 1004aeb:	c3                   	retq   
			runtime·printf("unexpected G.status %d\n", gp->status);
			runtime·throw("mark - bad status");
		case Gdead:
			break;
		case Grunning:
			if(gp != g)
 1004aec:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1004af3:	ff ff 
 1004af5:	48 39 c1             	cmp    %rax,%rcx
 1004af8:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 1004afd:	74 13                	je     1004b12 <mark+0xf9>
				runtime·throw("mark - world not stopped");
 1004aff:	b8 53 3f 02 01       	mov    $0x1023f53,%eax
 1004b04:	48 89 04 24          	mov    %rax,(%rsp)
 1004b08:	e8 2c 52 00 00       	callq  1009d39 <runtime.throw>
 1004b0d:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
			scanstack(gp);
 1004b12:	48 89 0c 24          	mov    %rcx,(%rsp)
 1004b16:	e8 34 fd ff ff       	callq  100484f <scanstack>
 1004b1b:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
	// and is mostly zeroed and would not otherwise be paged in.
	scanblock(data, (byte*)&runtime·mheap - data);
	scanblock((byte*)(&runtime·mheap+1), end - (byte*)(&runtime·mheap+1));

	// mark stacks
	for(gp=runtime·allg; gp!=nil; gp=gp->alllink) {
 1004b20:	eb ad                	jmp    1004acf <mark+0xb6>
			scanstack(gp);
			break;
		case Grunnable:
		case Gsyscall:
		case Gwaiting:
			scanstack(gp);
 1004b22:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 1004b27:	48 89 0c 24          	mov    %rcx,(%rsp)
 1004b2b:	e8 1f fd ff ff       	callq  100484f <scanstack>
 1004b30:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
	// and is mostly zeroed and would not otherwise be paged in.
	scanblock(data, (byte*)&runtime·mheap - data);
	scanblock((byte*)(&runtime·mheap+1), end - (byte*)(&runtime·mheap+1));

	// mark stacks
	for(gp=runtime·allg; gp!=nil; gp=gp->alllink) {
 1004b35:	eb 98                	jmp    1004acf <mark+0xb6>
			break;
		case Grunnable:
		case Gsyscall:
		case Gwaiting:
			scanstack(gp);
			break;
 1004b37:	83 f8 04             	cmp    $0x4,%eax
 1004b3a:	74 e6                	je     1004b22 <mark+0x109>
 1004b3c:	83 f8 06             	cmp    $0x6,%eax
 1004b3f:	0f 85 5c ff ff ff    	jne    1004aa1 <mark+0x88>
	// and is mostly zeroed and would not otherwise be paged in.
	scanblock(data, (byte*)&runtime·mheap - data);
	scanblock((byte*)(&runtime·mheap+1), end - (byte*)(&runtime·mheap+1));

	// mark stacks
	for(gp=runtime·allg; gp!=nil; gp=gp->alllink) {
 1004b45:	eb 88                	jmp    1004acf <mark+0xb6>

0000000001004b47 <sweep>:
}

// Sweep frees or calls finalizers for blocks not marked in the mark phase.
// It clears the mark bits in preparation for the next GC round.
static void
sweep(void)
 1004b47:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004b4e:	ff ff 
 1004b50:	48 8d 44 24 f8       	lea    -0x8(%rsp),%rax
 1004b55:	48 3b 01             	cmp    (%rcx),%rax
 1004b58:	77 05                	ja     1004b5f <sweep+0x18>
 1004b5a:	e8 94 cd ff ff       	callq  10018f3 <runtime.morestack00>
 1004b5f:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
	uintptr size;
	byte *p;
	MCache *c;
	Finalizer *f;

	for(s = runtime·mheap.allspans; s != nil; s = s->allnext) {
 1004b66:	48 8b 34 25 d0 e8 03 	mov    0x103e8d0,%rsi
 1004b6d:	01 
 1004b6e:	48 83 fe 00          	cmp    $0x0,%rsi
 1004b72:	74 12                	je     1004b86 <sweep+0x3f>
		if(s->state != MSpanInUse)
 1004b74:	8b 46 38             	mov    0x38(%rsi),%eax
 1004b77:	83 f8 00             	cmp    $0x0,%eax
 1004b7a:	74 12                	je     1004b8e <sweep+0x47>
	uintptr size;
	byte *p;
	MCache *c;
	Finalizer *f;

	for(s = runtime·mheap.allspans; s != nil; s = s->allnext) {
 1004b7c:	48 8b 76 10          	mov    0x10(%rsi),%rsi
 1004b80:	48 83 fe 00          	cmp    $0x0,%rsi
 1004b84:	75 ee                	jne    1004b74 <sweep+0x2d>
					((uintptr*)p)[1] = 1;	// mark as "needs to be zeroed"
				c->local_by_size[s->sizeclass].nfree++;
				runtime·MCache_Free(c, p, s->sizeclass, size);
			}
			c->local_alloc -= size;
			c->local_nfree++;
 1004b86:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
 1004b8d:	c3                   	retq   

	for(s = runtime·mheap.allspans; s != nil; s = s->allnext) {
		if(s->state != MSpanInUse)
			continue;

		p = (byte*)(s->start << PageShift);
 1004b8e:	48 8b 46 18          	mov    0x18(%rsi),%rax
 1004b92:	48 c1 e0 0c          	shl    $0xc,%rax
 1004b96:	49 89 c0             	mov    %rax,%r8
		cl = s->sizeclass;
 1004b99:	48 89 b4 24 80 00 00 	mov    %rsi,0x80(%rsp)
 1004ba0:	00 
 1004ba1:	8b 56 34             	mov    0x34(%rsi),%edx
		if(cl == 0) {
 1004ba4:	83 fa 00             	cmp    $0x0,%edx
 1004ba7:	0f 85 4d 02 00 00    	jne    1004dfa <sweep+0x2b3>
			size = s->npages<<PageShift;
 1004bad:	48 8b 46 20          	mov    0x20(%rsi),%rax
 1004bb1:	48 c1 e0 0c          	shl    $0xc,%rax
 1004bb5:	48 89 c7             	mov    %rax,%rdi
 1004bb8:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
			n = 1;
 1004bbd:	c7 44 24 78 01 00 00 	movl   $0x1,0x78(%rsp)
 1004bc4:	00 
			npages = runtime·class_to_allocnpages[cl];
			n = (npages << PageShift) / size;
		}
	
		// sweep through n objects of given size starting at p.
		for(; n > 0; n--, p += size) {
 1004bc5:	83 7c 24 78 00       	cmpl   $0x0,0x78(%rsp)
 1004bca:	7e b0                	jle    1004b7c <sweep+0x35>
			uintptr off, *bitp, shift, bits;

			off = (uintptr*)p - (uintptr*)runtime·mheap.arena_start;
 1004bcc:	4c 89 c0             	mov    %r8,%rax
 1004bcf:	48 2b 04 25 e8 e8 03 	sub    0x303e8e8,%rax
 1004bd6:	03 
 1004bd7:	48 c1 f8 03          	sar    $0x3,%rax
 1004bdb:	48 89 c2             	mov    %rax,%rdx
			bitp = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
 1004bde:	48 c1 e8 04          	shr    $0x4,%rax
 1004be2:	48 c1 e0 03          	shl    $0x3,%rax
 1004be6:	48 8b 2c 25 e8 e8 03 	mov    0x303e8e8,%rbp
 1004bed:	03 
 1004bee:	48 29 c5             	sub    %rax,%rbp
 1004bf1:	48 83 c5 f8          	add    $0xfffffffffffffff8,%rbp
			shift = off % wordsPerBitmapWord;
 1004bf5:	48 89 d3             	mov    %rdx,%rbx
 1004bf8:	48 83 e3 0f          	and    $0xf,%rbx
			bits = *bitp>>shift;
 1004bfc:	48 89 5c 24 38       	mov    %rbx,0x38(%rsp)
 1004c01:	48 63 cb             	movslq %ebx,%rcx
 1004c04:	48 89 6c 24 40       	mov    %rbp,0x40(%rsp)
 1004c09:	48 8b 45 00          	mov    0x0(%rbp),%rax
 1004c0d:	48 d3 e8             	shr    %cl,%rax
 1004c10:	48 89 c2             	mov    %rax,%rdx

			if((bits & bitAllocated) == 0)
 1004c13:	48 83 e0 01          	and    $0x1,%rax
 1004c17:	48 83 f8 00          	cmp    $0x0,%rax
 1004c1b:	75 09                	jne    1004c26 <sweep+0xdf>
			npages = runtime·class_to_allocnpages[cl];
			n = (npages << PageShift) / size;
		}
	
		// sweep through n objects of given size starting at p.
		for(; n > 0; n--, p += size) {
 1004c1d:	ff 4c 24 78          	decl   0x78(%rsp)
 1004c21:	49 01 f8             	add    %rdi,%r8
 1004c24:	eb 9f                	jmp    1004bc5 <sweep+0x7e>
			bits = *bitp>>shift;

			if((bits & bitAllocated) == 0)
				continue;

			if((bits & bitMarked) != 0) {
 1004c26:	48 89 d0             	mov    %rdx,%rax
 1004c29:	48 b9 00 00 00 00 01 	movabs $0x100000000,%rcx
 1004c30:	00 00 00 
 1004c33:	48 21 c8             	and    %rcx,%rax
 1004c36:	48 83 f8 00          	cmp    $0x0,%rax
 1004c3a:	74 19                	je     1004c55 <sweep+0x10e>
				*bitp &= ~(bitMarked<<shift);
 1004c3c:	48 63 cb             	movslq %ebx,%rcx
 1004c3f:	48 b8 00 00 00 00 01 	movabs $0x100000000,%rax
 1004c46:	00 00 00 
 1004c49:	48 d3 e0             	shl    %cl,%rax
 1004c4c:	48 f7 d0             	not    %rax
 1004c4f:	48 21 45 00          	and    %rax,0x0(%rbp)
			npages = runtime·class_to_allocnpages[cl];
			n = (npages << PageShift) / size;
		}
	
		// sweep through n objects of given size starting at p.
		for(; n > 0; n--, p += size) {
 1004c53:	eb c8                	jmp    1004c1d <sweep+0xd6>
			if((bits & bitMarked) != 0) {
				*bitp &= ~(bitMarked<<shift);
				continue;
			}

			if((bits & bitSpecial) != 0) {
 1004c55:	48 89 d0             	mov    %rdx,%rax
 1004c58:	48 b9 00 00 00 00 00 	movabs $0x1000000000000,%rcx
 1004c5f:	00 01 00 
 1004c62:	48 21 c8             	and    %rcx,%rax
 1004c65:	48 83 f8 00          	cmp    $0x0,%rax
 1004c69:	74 75                	je     1004ce0 <sweep+0x199>
				// Special means it has a finalizer or is being profiled.
				f = runtime·getfinalizer(p, 1);
 1004c6b:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
 1004c70:	4c 89 04 24          	mov    %r8,(%rsp)
 1004c74:	b9 01 00 00 00       	mov    $0x1,%ecx
 1004c79:	88 4c 24 08          	mov    %cl,0x8(%rsp)
 1004c7d:	e8 b2 f3 ff ff       	callq  1004034 <runtime.getfinalizer>
 1004c82:	4c 8b 44 24 60       	mov    0x60(%rsp),%r8
 1004c87:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
 1004c8c:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
 1004c93:	00 
				if(f != nil) {
 1004c94:	48 83 f8 00          	cmp    $0x0,%rax
 1004c98:	74 1c                	je     1004cb6 <sweep+0x16f>
					f->arg = p;
 1004c9a:	4c 89 40 10          	mov    %r8,0x10(%rax)
					f->next = finq;
 1004c9e:	48 8b 0c 25 70 4e 02 	mov    0x1024e70,%rcx
 1004ca5:	01 
 1004ca6:	48 89 08             	mov    %rcx,(%rax)
					finq = f;
 1004ca9:	48 89 04 25 70 4e 02 	mov    %rax,0x1024e70
 1004cb0:	01 
			npages = runtime·class_to_allocnpages[cl];
			n = (npages << PageShift) / size;
		}
	
		// sweep through n objects of given size starting at p.
		for(; n > 0; n--, p += size) {
 1004cb1:	e9 67 ff ff ff       	jmpq   1004c1d <sweep+0xd6>
					f->arg = p;
					f->next = finq;
					finq = f;
					continue;
				}
				runtime·MProf_Free(p, size);
 1004cb6:	4c 89 04 24          	mov    %r8,(%rsp)
 1004cba:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
 1004cbf:	e8 65 22 00 00       	callq  1006f29 <runtime.MProf_Free>
 1004cc4:	4c 8b 44 24 60       	mov    0x60(%rsp),%r8
 1004cc9:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
 1004cce:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
 1004cd5:	00 
 1004cd6:	48 8b 6c 24 40       	mov    0x40(%rsp),%rbp
 1004cdb:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
			}

			// Mark freed; restore block boundary bit.
			*bitp = (*bitp & ~(bitMask<<shift)) | (bitBlockBoundary<<shift);
 1004ce0:	48 63 cb             	movslq %ebx,%rcx
 1004ce3:	48 b8 01 00 01 00 01 	movabs $0x1000100010001,%rax
 1004cea:	00 01 00 
 1004ced:	48 d3 e0             	shl    %cl,%rax
 1004cf0:	48 f7 d0             	not    %rax
 1004cf3:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 1004cf7:	48 21 c1             	and    %rax,%rcx
 1004cfa:	48 89 c8             	mov    %rcx,%rax
 1004cfd:	48 63 cb             	movslq %ebx,%rcx
 1004d00:	48 c7 c2 00 00 01 00 	mov    $0x10000,%rdx
 1004d07:	48 d3 e2             	shl    %cl,%rdx
 1004d0a:	48 09 d0             	or     %rdx,%rax
 1004d0d:	48 89 45 00          	mov    %rax,0x0(%rbp)

			c = m->mcache;
 1004d11:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1004d18:	ff ff 
 1004d1a:	48 8b 98 d8 00 00 00 	mov    0xd8(%rax),%rbx
 1004d21:	48 89 5c 24 58       	mov    %rbx,0x58(%rsp)
			if(s->sizeclass == 0) {
 1004d26:	8b 46 34             	mov    0x34(%rsi),%eax
 1004d29:	83 f8 00             	cmp    $0x0,%eax
 1004d2c:	75 79                	jne    1004da7 <sweep+0x260>
				// Free large span.
				runtime·unmarkspan(p, 1<<PageShift);
 1004d2e:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
 1004d33:	4c 89 04 24          	mov    %r8,(%rsp)
 1004d37:	48 c7 c0 00 10 00 00 	mov    $0x1000,%rax
 1004d3e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1004d43:	e8 6c 0c 00 00       	callq  10059b4 <runtime.unmarkspan>
				*(uintptr*)p = 1;	// needs zeroing
 1004d48:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 1004d4d:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
				runtime·MHeap_Free(&runtime·mheap, s, 1);
 1004d54:	b8 80 a0 03 01       	mov    $0x103a080,%eax
 1004d59:	48 89 04 24          	mov    %rax,(%rsp)
 1004d5d:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
 1004d64:	00 
 1004d65:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1004d6a:	b8 01 00 00 00       	mov    $0x1,%eax
 1004d6f:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1004d73:	e8 86 17 00 00       	callq  10064fe <runtime.MHeap_Free>
 1004d78:	4c 8b 44 24 60       	mov    0x60(%rsp),%r8
 1004d7d:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
 1004d82:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
 1004d89:	00 
				if(size > sizeof(uintptr))
					((uintptr*)p)[1] = 1;	// mark as "needs to be zeroed"
				c->local_by_size[s->sizeclass].nfree++;
				runtime·MCache_Free(c, p, s->sizeclass, size);
			}
			c->local_alloc -= size;
 1004d8a:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 1004d8f:	48 29 b8 e8 03 00 00 	sub    %rdi,0x3e8(%rax)
			c->local_nfree++;
 1004d96:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 1004d9b:	48 ff 80 00 04 00 00 	incq   0x400(%rax)
			npages = runtime·class_to_allocnpages[cl];
			n = (npages << PageShift) / size;
		}
	
		// sweep through n objects of given size starting at p.
		for(; n > 0; n--, p += size) {
 1004da2:	e9 76 fe ff ff       	jmpq   1004c1d <sweep+0xd6>
				runtime·unmarkspan(p, 1<<PageShift);
				*(uintptr*)p = 1;	// needs zeroing
				runtime·MHeap_Free(&runtime·mheap, s, 1);
			} else {
				// Free small object.
				if(size > sizeof(uintptr))
 1004da7:	48 83 ff 08          	cmp    $0x8,%rdi
 1004dab:	76 08                	jbe    1004db5 <sweep+0x26e>
					((uintptr*)p)[1] = 1;	// mark as "needs to be zeroed"
 1004dad:	49 c7 40 08 01 00 00 	movq   $0x1,0x8(%r8)
 1004db4:	00 
				c->local_by_size[s->sizeclass].nfree++;
 1004db5:	8b 4e 34             	mov    0x34(%rsi),%ecx
 1004db8:	48 c1 e1 04          	shl    $0x4,%rcx
 1004dbc:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
 1004dc0:	48 ff 80 20 04 00 00 	incq   0x420(%rax)
				runtime·MCache_Free(c, p, s->sizeclass, size);
 1004dc7:	48 89 1c 24          	mov    %rbx,(%rsp)
 1004dcb:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
 1004dd0:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
 1004dd5:	8b 46 34             	mov    0x34(%rsi),%eax
 1004dd8:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1004ddc:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
 1004de1:	e8 0e e7 ff ff       	callq  10034f4 <runtime.MCache_Free>
 1004de6:	4c 8b 44 24 60       	mov    0x60(%rsp),%r8
 1004deb:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
 1004df0:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
 1004df7:	00 
			}
			c->local_alloc -= size;
 1004df8:	eb 90                	jmp    1004d8a <sweep+0x243>
		if(cl == 0) {
			size = s->npages<<PageShift;
			n = 1;
		} else {
			// Chunk full of small blocks.
			size = runtime·class_to_size[cl];
 1004dfa:	48 63 ca             	movslq %edx,%rcx
 1004dfd:	8b 3c 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%edi
 1004e04:	48 63 ff             	movslq %edi,%rdi
			npages = runtime·class_to_allocnpages[cl];
 1004e07:	48 63 ca             	movslq %edx,%rcx
 1004e0a:	8b 04 8d e0 50 02 01 	mov    0x10250e0(,%rcx,4),%eax
			n = (npages << PageShift) / size;
 1004e11:	c1 e0 0c             	shl    $0xc,%eax
 1004e14:	48 63 c0             	movslq %eax,%rax
 1004e17:	31 d2                	xor    %edx,%edx
 1004e19:	48 f7 f7             	div    %rdi
 1004e1c:	48 89 7c 24 68       	mov    %rdi,0x68(%rsp)
 1004e21:	48 63 c0             	movslq %eax,%rax
 1004e24:	89 44 24 78          	mov    %eax,0x78(%rsp)
		}
	
		// sweep through n objects of given size starting at p.
		for(; n > 0; n--, p += size) {
 1004e28:	e9 98 fd ff ff       	jmpq   1004bc5 <sweep+0x7e>

0000000001004e2d <stealcache>:
// just changes the linear constant (and also the amount of
// extra memory used).
static int32 gcpercent = -2;

static void
stealcache(void)
 1004e2d:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004e34:	ff ff 
 1004e36:	48 3b 21             	cmp    (%rcx),%rsp
 1004e39:	77 05                	ja     1004e40 <stealcache+0x13>
 1004e3b:	e8 b3 ca ff ff       	callq  10018f3 <runtime.morestack00>
 1004e40:	48 83 ec 20          	sub    $0x20,%rsp
{
	M *m;
	
	for(m=runtime·allm; m; m=m->alllink)
 1004e44:	48 8b 0c 25 e0 4e 02 	mov    0x1024ee0,%rcx
 1004e4b:	01 
 1004e4c:	48 83 f9 00          	cmp    $0x0,%rcx
 1004e50:	74 27                	je     1004e79 <stealcache+0x4c>
		runtime·MCache_ReleaseAll(m->mcache);
 1004e52:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 1004e57:	48 8b 81 d8 00 00 00 	mov    0xd8(%rcx),%rax
 1004e5e:	48 89 04 24          	mov    %rax,(%rsp)
 1004e62:	e8 9a e7 ff ff       	callq  1003601 <runtime.MCache_ReleaseAll>
static void
stealcache(void)
{
	M *m;
	
	for(m=runtime·allm; m; m=m->alllink)
 1004e67:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 1004e6c:	48 8b 88 c0 00 00 00 	mov    0xc0(%rax),%rcx
 1004e73:	48 83 f9 00          	cmp    $0x0,%rcx
 1004e77:	75 d9                	jne    1004e52 <stealcache+0x25>
		runtime·MCache_ReleaseAll(m->mcache);
 1004e79:	48 83 c4 20          	add    $0x20,%rsp
 1004e7d:	c3                   	retq   

0000000001004e7e <cachestats>:
}

static void
cachestats(void)
 1004e7e:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004e85:	ff ff 
 1004e87:	48 3b 21             	cmp    (%rcx),%rsp
 1004e8a:	77 05                	ja     1004e91 <cachestats+0x13>
 1004e8c:	e8 62 ca ff ff       	callq  10018f3 <runtime.morestack00>
 1004e91:	48 83 ec 40          	sub    $0x40,%rsp
	MCache *c;
	int32 i;
	uint64 stacks_inuse;
	uint64 stacks_sys;

	stacks_inuse = 0;
 1004e95:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
 1004e9c:	00 00 
	stacks_sys = 0;
 1004e9e:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
 1004ea5:	00 00 
	for(m=runtime·allm; m; m=m->alllink) {
 1004ea7:	48 8b 0c 25 e0 4e 02 	mov    0x1024ee0,%rcx
 1004eae:	01 
 1004eaf:	48 83 f9 00          	cmp    $0x0,%rcx
 1004eb3:	0f 84 db 00 00 00    	je     1004f94 <cachestats+0x116>
		runtime·purgecachedstats(m);
 1004eb9:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
 1004ebe:	48 89 0c 24          	mov    %rcx,(%rsp)
 1004ec2:	e8 c7 df ff ff       	callq  1002e8e <runtime.purgecachedstats>
 1004ec7:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
		stacks_inuse += m->stackalloc->inuse;
 1004ecc:	48 8b 86 e0 00 00 00 	mov    0xe0(%rsi),%rax
 1004ed3:	48 8b 40 38          	mov    0x38(%rax),%rax
 1004ed7:	48 01 44 24 20       	add    %rax,0x20(%rsp)
		stacks_sys += m->stackalloc->sys;
 1004edc:	48 8b 86 e0 00 00 00 	mov    0xe0(%rsi),%rax
 1004ee3:	48 8b 40 40          	mov    0x40(%rax),%rax
 1004ee7:	48 01 44 24 18       	add    %rax,0x18(%rsp)
		c = m->mcache;
 1004eec:	48 8b ae d8 00 00 00 	mov    0xd8(%rsi),%rbp
		for(i=0; i<nelem(c->local_by_size); i++) {
 1004ef3:	31 db                	xor    %ebx,%ebx
 1004ef5:	83 fb 3d             	cmp    $0x3d,%ebx
 1004ef8:	0f 8d 85 00 00 00    	jge    1004f83 <cachestats+0x105>
			mstats.by_size[i].nmalloc += c->local_by_size[i].nmalloc;
 1004efe:	48 63 cb             	movslq %ebx,%rcx
 1004f01:	48 c1 e1 04          	shl    $0x4,%rcx
 1004f05:	48 89 ea             	mov    %rbp,%rdx
 1004f08:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1004f0c:	48 8b 80 18 04 00 00 	mov    0x418(%rax),%rax
 1004f13:	48 63 cb             	movslq %ebx,%rcx
 1004f16:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 1004f1a:	48 01 04 0d 08 6b 02 	add    %rax,0x1026b08(,%rcx,1)
 1004f21:	01 
			c->local_by_size[i].nmalloc = 0;
 1004f22:	48 63 cb             	movslq %ebx,%rcx
 1004f25:	48 c1 e1 04          	shl    $0x4,%rcx
 1004f29:	48 89 ea             	mov    %rbp,%rdx
 1004f2c:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1004f30:	48 c7 80 18 04 00 00 	movq   $0x0,0x418(%rax)
 1004f37:	00 00 00 00 
			mstats.by_size[i].nfree += c->local_by_size[i].nfree;
 1004f3b:	48 63 cb             	movslq %ebx,%rcx
 1004f3e:	48 c1 e1 04          	shl    $0x4,%rcx
 1004f42:	48 89 ea             	mov    %rbp,%rdx
 1004f45:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1004f49:	48 8b 80 20 04 00 00 	mov    0x420(%rax),%rax
 1004f50:	48 63 cb             	movslq %ebx,%rcx
 1004f53:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 1004f57:	48 01 04 0d 10 6b 02 	add    %rax,0x1026b10(,%rcx,1)
 1004f5e:	01 
			c->local_by_size[i].nfree = 0;
 1004f5f:	48 63 cb             	movslq %ebx,%rcx
 1004f62:	48 c1 e1 04          	shl    $0x4,%rcx
 1004f66:	48 89 ea             	mov    %rbp,%rdx
 1004f69:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1004f6d:	48 c7 80 20 04 00 00 	movq   $0x0,0x420(%rax)
 1004f74:	00 00 00 00 
	for(m=runtime·allm; m; m=m->alllink) {
		runtime·purgecachedstats(m);
		stacks_inuse += m->stackalloc->inuse;
		stacks_sys += m->stackalloc->sys;
		c = m->mcache;
		for(i=0; i<nelem(c->local_by_size); i++) {
 1004f78:	ff c3                	inc    %ebx
 1004f7a:	83 fb 3d             	cmp    $0x3d,%ebx
 1004f7d:	0f 8c 7b ff ff ff    	jl     1004efe <cachestats+0x80>
	uint64 stacks_inuse;
	uint64 stacks_sys;

	stacks_inuse = 0;
	stacks_sys = 0;
	for(m=runtime·allm; m; m=m->alllink) {
 1004f83:	48 8b 8e c0 00 00 00 	mov    0xc0(%rsi),%rcx
 1004f8a:	48 83 f9 00          	cmp    $0x0,%rcx
 1004f8e:	0f 85 25 ff ff ff    	jne    1004eb9 <cachestats+0x3b>
			c->local_by_size[i].nmalloc = 0;
			mstats.by_size[i].nfree += c->local_by_size[i].nfree;
			c->local_by_size[i].nfree = 0;
		}
	}
	mstats.stacks_inuse = stacks_inuse;
 1004f94:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1004f99:	48 89 04 25 b0 62 02 	mov    %rax,0x10262b0
 1004fa0:	01 
	mstats.stacks_sys = stacks_sys;
 1004fa1:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 1004fa6:	48 89 04 25 b8 62 02 	mov    %rax,0x10262b8
 1004fad:	01 
 1004fae:	48 83 c4 40          	add    $0x40,%rsp
 1004fb2:	c3                   	retq   

0000000001004fb3 <runtime.gc>:
}

void
runtime·gc(int32 force)
 1004fb3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1004fba:	ff ff 
 1004fbc:	48 8d 44 24 b0       	lea    -0x50(%rsp),%rax
 1004fc1:	48 3b 01             	cmp    (%rcx),%rax
 1004fc4:	77 05                	ja     1004fcb <runtime.gc+0x18>
 1004fc6:	e8 81 c9 ff ff       	callq  100194c <runtime.morestack8>
 1004fcb:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
	// of a number of libraries that might be
	// holding locks.  To avoid priority inversion
	// problems, don't bother trying to run gc
	// while holding a lock.  The next mallocgc
	// without a lock will do the gc instead.
	if(!mstats.enablegc || m->locks > 0 || runtime·panicking)
 1004fd2:	80 3c 25 fc 6a 02 01 	cmpb   $0x0,0x1026afc
 1004fd9:	00 
 1004fda:	74 14                	je     1004ff0 <runtime.gc+0x3d>
 1004fdc:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1004fe3:	ff ff 
 1004fe5:	8b 80 84 00 00 00    	mov    0x84(%rax),%eax
 1004feb:	83 f8 00             	cmp    $0x0,%eax
 1004fee:	7e 08                	jle    1004ff8 <runtime.gc+0x45>
		return;
 1004ff0:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
 1004ff7:	c3                   	retq   
	// of a number of libraries that might be
	// holding locks.  To avoid priority inversion
	// problems, don't bother trying to run gc
	// while holding a lock.  The next mallocgc
	// without a lock will do the gc instead.
	if(!mstats.enablegc || m->locks > 0 || runtime·panicking)
 1004ff8:	83 3c 25 20 4e 02 01 	cmpl   $0x0,0x1024e20
 1004fff:	00 
 1005000:	75 ee                	jne    1004ff0 <runtime.gc+0x3d>
		return;

	if(gcpercent == -2) {	// first time through
 1005002:	83 3c 25 00 30 02 01 	cmpl   $0xfffffffffffffffe,0x1023000
 1005009:	fe 
 100500a:	75 7a                	jne    1005086 <runtime.gc+0xd3>
		p = runtime·getenv("GOGC");
 100500c:	b9 6c 3f 02 01       	mov    $0x1023f6c,%ecx
 1005011:	48 89 0c 24          	mov    %rcx,(%rsp)
 1005015:	e8 b7 50 00 00       	callq  100a0d1 <runtime.getenv>
 100501a:	48 89 c2             	mov    %rax,%rdx
		if(p == nil || p[0] == '\0')
 100501d:	48 83 f8 00          	cmp    $0x0,%rax
 1005021:	0f 84 78 04 00 00    	je     100549f <runtime.gc+0x4ec>
 1005027:	0f b6 00             	movzbl (%rax),%eax
 100502a:	83 f8 00             	cmp    $0x0,%eax
 100502d:	0f 84 6c 04 00 00    	je     100549f <runtime.gc+0x4ec>
			gcpercent = 100;
		else if(runtime·strcmp(p, (byte*)"off") == 0)
 1005033:	48 89 94 24 88 00 00 	mov    %rdx,0x88(%rsp)
 100503a:	00 
 100503b:	48 89 14 24          	mov    %rdx,(%rsp)
 100503f:	b9 71 3f 02 01       	mov    $0x1023f71,%ecx
 1005044:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1005049:	e8 51 6a 00 00       	callq  100ba9f <runtime.strcmp>
 100504e:	83 f8 00             	cmp    $0x0,%eax
 1005051:	0f 85 2b 04 00 00    	jne    1005482 <runtime.gc+0x4cf>
			gcpercent = -1;
 1005057:	c7 04 25 00 30 02 01 	movl   $0xffffffff,0x1023000
 100505e:	ff ff ff ff 
		else
			gcpercent = runtime·atoi(p);
		
		p = runtime·getenv("GOGCTRACE");
 1005062:	b9 75 3f 02 01       	mov    $0x1023f75,%ecx
 1005067:	48 89 0c 24          	mov    %rcx,(%rsp)
 100506b:	e8 61 50 00 00       	callq  100a0d1 <runtime.getenv>
		if(p != nil)
 1005070:	48 83 f8 00          	cmp    $0x0,%rax
 1005074:	74 10                	je     1005086 <runtime.gc+0xd3>
			gctrace = runtime·atoi(p);
 1005076:	48 89 04 24          	mov    %rax,(%rsp)
 100507a:	e8 fd 50 00 00       	callq  100a17c <runtime.atoi>
 100507f:	89 04 25 f0 4d 02 01 	mov    %eax,0x1024df0
	}
	if(gcpercent < 0)
 1005086:	83 3c 25 00 30 02 01 	cmpl   $0x0,0x1023000
 100508d:	00 
 100508e:	7d 08                	jge    1005098 <runtime.gc+0xe5>
		return;
 1005090:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
 1005097:	c3                   	retq   

	runtime·semacquire(&gcsema);
 1005098:	b8 04 30 02 01       	mov    $0x1023004,%eax
 100509d:	48 89 04 24          	mov    %rax,(%rsp)
 10050a1:	e8 66 5b 00 00       	callq  100ac0c <runtime.semacquire>
	if(!force && mstats.heap_alloc < mstats.next_gc) {
 10050a6:	83 bc 24 d8 00 00 00 	cmpl   $0x0,0xd8(%rsp)
 10050ad:	00 
 10050ae:	75 16                	jne    10050c6 <runtime.gc+0x113>
 10050b0:	48 8b 04 25 88 62 02 	mov    0x1026288,%rax
 10050b7:	01 
 10050b8:	48 3b 04 25 e8 62 02 	cmp    0x10262e8,%rax
 10050bf:	01 
 10050c0:	0f 82 a6 03 00 00    	jb     100546c <runtime.gc+0x4b9>
		runtime·semrelease(&gcsema);
		return;
	}

	t0 = runtime·nanotime();
 10050c6:	e8 08 59 00 00       	callq  100a9d3 <runtime.nanotime>
 10050cb:	48 89 84 24 c8 00 00 	mov    %rax,0xc8(%rsp)
 10050d2:	00 
	nlookup = 0;
 10050d3:	48 c7 04 25 b8 4e 02 	movq   $0x0,0x1024eb8
 10050da:	01 00 00 00 00 
	nsizelookup = 0;
 10050df:	48 c7 04 25 c0 4e 02 	movq   $0x0,0x1024ec0
 10050e6:	01 00 00 00 00 
	naddrlookup = 0;
 10050eb:	48 c7 04 25 b0 4e 02 	movq   $0x0,0x1024eb0
 10050f2:	01 00 00 00 00 

	m->gcing = 1;
 10050f7:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10050fe:	ff ff 
 1005100:	c7 80 80 00 00 00 01 	movl   $0x1,0x80(%rax)
 1005107:	00 00 00 
	runtime·stoptheworld();
 100510a:	e8 15 37 00 00       	callq  1008824 <runtime.stoptheworld>
	if(runtime·mheap.Lock.key != 0)
 100510f:	83 3c 25 80 a0 03 01 	cmpl   $0x0,0x103a080
 1005116:	00 
 1005117:	74 0e                	je     1005127 <runtime.gc+0x174>
		runtime·throw("runtime·mheap locked during gc");
 1005119:	b8 7f 3f 02 01       	mov    $0x1023f7f,%eax
 100511e:	48 89 04 24          	mov    %rax,(%rsp)
 1005122:	e8 12 4c 00 00       	callq  1009d39 <runtime.throw>

	cachestats();
 1005127:	e8 52 fd ff ff       	callq  1004e7e <cachestats>
	heap0 = mstats.heap_alloc;
 100512c:	48 8b 04 25 88 62 02 	mov    0x1026288,%rax
 1005133:	01 
 1005134:	48 89 84 24 a8 00 00 	mov    %rax,0xa8(%rsp)
 100513b:	00 
	obj0 = mstats.nmalloc - mstats.nfree;
 100513c:	48 8b 04 25 78 62 02 	mov    0x1026278,%rax
 1005143:	01 
 1005144:	48 2b 04 25 80 62 02 	sub    0x1026280,%rax
 100514b:	01 
 100514c:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
 1005153:	00 

	mark();
 1005154:	e8 c0 f8 ff ff       	callq  1004a19 <mark>
	t1 = runtime·nanotime();
 1005159:	e8 75 58 00 00       	callq  100a9d3 <runtime.nanotime>
 100515e:	48 89 84 24 c0 00 00 	mov    %rax,0xc0(%rsp)
 1005165:	00 
	sweep();
 1005166:	e8 dc f9 ff ff       	callq  1004b47 <sweep>
	t2 = runtime·nanotime();
 100516b:	e8 63 58 00 00       	callq  100a9d3 <runtime.nanotime>
 1005170:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
 1005177:	00 
	stealcache();
 1005178:	e8 b0 fc ff ff       	callq  1004e2d <stealcache>
	cachestats();
 100517d:	e8 fc fc ff ff       	callq  1004e7e <cachestats>
 1005182:	48 8b 1c 25 60 4e 02 	mov    0x1024e60,%rbx
 1005189:	01 

	mstats.next_gc = mstats.heap_alloc+mstats.heap_alloc*gcpercent/100;
 100518a:	8b 04 25 00 30 02 01 	mov    0x1023000,%eax
 1005191:	48 63 c0             	movslq %eax,%rax
 1005194:	48 f7 24 25 88 62 02 	mulq   0x1026288
 100519b:	01 
 100519c:	31 d2                	xor    %edx,%edx
 100519e:	48 c7 44 24 70 64 00 	movq   $0x64,0x70(%rsp)
 10051a5:	00 00 
 10051a7:	48 f7 74 24 70       	divq   0x70(%rsp)
 10051ac:	48 8b 0c 25 88 62 02 	mov    0x1026288,%rcx
 10051b3:	01 
 10051b4:	48 01 c1             	add    %rax,%rcx
 10051b7:	48 89 0c 25 e8 62 02 	mov    %rcx,0x10262e8
 10051be:	01 
	m->gcing = 0;
 10051bf:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10051c6:	ff ff 
 10051c8:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
 10051cf:	00 00 00 

	m->locks++;	// disable gc during the mallocs in newproc
 10051d2:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10051d9:	ff ff 
 10051db:	ff 80 84 00 00 00    	incl   0x84(%rax)
	fp = finq;
 10051e1:	48 8b 04 25 70 4e 02 	mov    0x1024e70,%rax
 10051e8:	01 
	if(fp != nil) {
 10051e9:	48 83 f8 00          	cmp    $0x0,%rax
 10051ed:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
 10051f4:	00 
 10051f5:	74 43                	je     100523a <runtime.gc+0x287>
		// kick off or wake up goroutine to run queued finalizers
		if(fing == nil)
 10051f7:	48 83 fb 00          	cmp    $0x0,%rbx
 10051fb:	0f 85 44 02 00 00    	jne    1005445 <runtime.gc+0x492>
			fing = runtime·newproc1((byte*)runfinq, nil, 0, 0, runtime·gc);
 1005201:	b9 af 54 00 01       	mov    $0x10054af,%ecx
 1005206:	48 89 0c 24          	mov    %rcx,(%rsp)
 100520a:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
 1005211:	00 00 
 1005213:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
 100521a:	00 
 100521b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%rsp)
 1005222:	00 
 1005223:	b9 b3 4f 00 01       	mov    $0x1004fb3,%ecx
 1005228:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 100522d:	e8 ec 40 00 00       	callq  100931e <runtime.newproc1>
 1005232:	48 89 04 25 60 4e 02 	mov    %rax,0x1024e60
 1005239:	01 
		else if(fingwait) {
			fingwait = 0;
			runtime·ready(fing);
		}
	}
	m->locks--;
 100523a:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1005241:	ff ff 
 1005243:	ff 88 84 00 00 00    	decl   0x84(%rax)

	cachestats();
 1005249:	e8 30 fc ff ff       	callq  1004e7e <cachestats>
	heap1 = mstats.heap_alloc;
 100524e:	48 8b 04 25 88 62 02 	mov    0x1026288,%rax
 1005255:	01 
 1005256:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
 100525d:	00 
	obj1 = mstats.nmalloc - mstats.nfree;
 100525e:	48 8b 04 25 78 62 02 	mov    0x1026278,%rax
 1005265:	01 
 1005266:	48 2b 04 25 80 62 02 	sub    0x1026280,%rax
 100526d:	01 
 100526e:	48 89 84 24 90 00 00 	mov    %rax,0x90(%rsp)
 1005275:	00 

	t3 = runtime·nanotime();
 1005276:	e8 58 57 00 00       	callq  100a9d3 <runtime.nanotime>
 100527b:	48 8b ac 24 c8 00 00 	mov    0xc8(%rsp),%rbp
 1005282:	00 
 1005283:	48 89 c3             	mov    %rax,%rbx
	mstats.pause_ns[mstats.numgc%nelem(mstats.pause_ns)] = t3 - t0;
 1005286:	48 29 e8             	sub    %rbp,%rax
 1005289:	8b 0c 25 f8 6a 02 01 	mov    0x1026af8,%ecx
 1005290:	81 e1 ff 00 00 00    	and    $0xff,%ecx
 1005296:	48 89 04 cd f8 62 02 	mov    %rax,0x10262f8(,%rcx,8)
 100529d:	01 
	mstats.pause_total_ns += t3 - t0;
 100529e:	48 89 d8             	mov    %rbx,%rax
 10052a1:	48 29 e8             	sub    %rbp,%rax
 10052a4:	48 01 04 25 f0 62 02 	add    %rax,0x10262f0
 10052ab:	01 
	mstats.numgc++;
 10052ac:	ff 04 25 f8 6a 02 01 	incl   0x1026af8
	if(mstats.debuggc)
 10052b3:	80 3c 25 fd 6a 02 01 	cmpb   $0x0,0x1026afd
 10052ba:	00 
 10052bb:	74 31                	je     10052ee <runtime.gc+0x33b>
		runtime·printf("pause %D\n", t3-t0);
 10052bd:	b8 9f 3f 02 01       	mov    $0x1023f9f,%eax
 10052c2:	48 89 04 24          	mov    %rax,(%rsp)
 10052c6:	48 89 d8             	mov    %rbx,%rax
 10052c9:	48 89 9c 24 b0 00 00 	mov    %rbx,0xb0(%rsp)
 10052d0:	00 
 10052d1:	48 29 e8             	sub    %rbp,%rax
 10052d4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10052d9:	e8 60 20 00 00       	callq  100733e <runtime.printf>
 10052de:	48 8b ac 24 c8 00 00 	mov    0xc8(%rsp),%rbp
 10052e5:	00 
 10052e6:	48 8b 9c 24 b0 00 00 	mov    0xb0(%rsp),%rbx
 10052ed:	00 
	
	if(gctrace) {
 10052ee:	83 3c 25 f0 4d 02 01 	cmpl   $0x0,0x1024df0
 10052f5:	00 
 10052f6:	0f 84 fb 00 00 00    	je     10053f7 <runtime.gc+0x444>
		runtime·printf("gc%d: %D+%D+%D ms %D -> %D MB %D -> %D (%D-%D) objects %D pointer lookups (%D size, %D addr)\n",
 10052fc:	b8 a9 3f 02 01       	mov    $0x1023fa9,%eax
 1005301:	48 89 04 24          	mov    %rax,(%rsp)
 1005305:	8b 04 25 f8 6a 02 01 	mov    0x1026af8,%eax
 100530c:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1005310:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
 1005317:	00 
 1005318:	48 29 e8             	sub    %rbp,%rax
 100531b:	48 99                	cqto   
 100531d:	48 c7 44 24 70 40 42 	movq   $0xf4240,0x70(%rsp)
 1005324:	0f 00 
 1005326:	48 f7 7c 24 70       	idivq  0x70(%rsp)
 100532b:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1005330:	48 8b 84 24 b8 00 00 	mov    0xb8(%rsp),%rax
 1005337:	00 
 1005338:	48 2b 84 24 c0 00 00 	sub    0xc0(%rsp),%rax
 100533f:	00 
 1005340:	48 99                	cqto   
 1005342:	48 c7 44 24 70 40 42 	movq   $0xf4240,0x70(%rsp)
 1005349:	0f 00 
 100534b:	48 f7 7c 24 70       	idivq  0x70(%rsp)
 1005350:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1005355:	48 89 d8             	mov    %rbx,%rax
 1005358:	48 2b 84 24 b8 00 00 	sub    0xb8(%rsp),%rax
 100535f:	00 
 1005360:	48 99                	cqto   
 1005362:	48 c7 44 24 70 40 42 	movq   $0xf4240,0x70(%rsp)
 1005369:	0f 00 
 100536b:	48 f7 7c 24 70       	idivq  0x70(%rsp)
 1005370:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1005375:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
 100537c:	00 
 100537d:	48 c1 e8 14          	shr    $0x14,%rax
 1005381:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 1005386:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
 100538d:	00 
 100538e:	48 c1 e8 14          	shr    $0x14,%rax
 1005392:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
 1005397:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
 100539e:	00 
 100539f:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
 10053a4:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
 10053ab:	00 
 10053ac:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
 10053b1:	48 8b 04 25 78 62 02 	mov    0x1026278,%rax
 10053b8:	01 
 10053b9:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
 10053be:	48 8b 04 25 80 62 02 	mov    0x1026280,%rax
 10053c5:	01 
 10053c6:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
 10053cb:	48 8b 04 25 b8 4e 02 	mov    0x1024eb8,%rax
 10053d2:	01 
 10053d3:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
 10053d8:	48 8b 04 25 c0 4e 02 	mov    0x1024ec0,%rax
 10053df:	01 
 10053e0:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
 10053e5:	48 8b 04 25 b0 4e 02 	mov    0x1024eb0,%rax
 10053ec:	01 
 10053ed:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
 10053f2:	e8 47 1f 00 00       	callq  100733e <runtime.printf>
			heap0>>20, heap1>>20, obj0, obj1,
			mstats.nmalloc, mstats.nfree,
			nlookup, nsizelookup, naddrlookup);
	}

	runtime·semrelease(&gcsema);
 10053f7:	b8 04 30 02 01       	mov    $0x1023004,%eax
 10053fc:	48 89 04 24          	mov    %rax,(%rsp)
 1005400:	e8 11 59 00 00       	callq  100ad16 <runtime.semrelease>
	runtime·starttheworld();
 1005405:	e8 fc 34 00 00       	callq  1008906 <runtime.starttheworld>
	
	// give the queued finalizers, if any, a chance to run
	if(fp != nil)
 100540a:	48 83 bc 24 80 00 00 	cmpq   $0x0,0x80(%rsp)
 1005411:	00 00 
 1005413:	74 05                	je     100541a <runtime.gc+0x467>
		runtime·gosched();
 1005415:	e8 96 39 00 00       	callq  1008db0 <runtime.gosched>
	
	if(gctrace > 1 && !force)
 100541a:	83 3c 25 f0 4d 02 01 	cmpl   $0x1,0x1024df0
 1005421:	01 
 1005422:	7e 0a                	jle    100542e <runtime.gc+0x47b>
 1005424:	83 bc 24 d8 00 00 00 	cmpl   $0x0,0xd8(%rsp)
 100542b:	00 
 100542c:	74 08                	je     1005436 <runtime.gc+0x483>
		runtime·gc(1);
 100542e:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
 1005435:	c3                   	retq   
 1005436:	b8 01 00 00 00       	mov    $0x1,%eax
 100543b:	89 04 24             	mov    %eax,(%rsp)
 100543e:	e8 70 fb ff ff       	callq  1004fb3 <runtime.gc>
 1005443:	eb e9                	jmp    100542e <runtime.gc+0x47b>
	fp = finq;
	if(fp != nil) {
		// kick off or wake up goroutine to run queued finalizers
		if(fing == nil)
			fing = runtime·newproc1((byte*)runfinq, nil, 0, 0, runtime·gc);
		else if(fingwait) {
 1005445:	83 3c 25 e8 4d 02 01 	cmpl   $0x0,0x1024de8
 100544c:	00 
 100544d:	0f 84 e7 fd ff ff    	je     100523a <runtime.gc+0x287>
			fingwait = 0;
 1005453:	c7 04 25 e8 4d 02 01 	movl   $0x0,0x1024de8
 100545a:	00 00 00 00 
			runtime·ready(fing);
 100545e:	48 89 1c 24          	mov    %rbx,(%rsp)
 1005462:	e8 90 2f 00 00       	callq  10083f7 <runtime.ready>
		}
	}
	m->locks--;
 1005467:	e9 ce fd ff ff       	jmpq   100523a <runtime.gc+0x287>
	if(gcpercent < 0)
		return;

	runtime·semacquire(&gcsema);
	if(!force && mstats.heap_alloc < mstats.next_gc) {
		runtime·semrelease(&gcsema);
 100546c:	b8 04 30 02 01       	mov    $0x1023004,%eax
 1005471:	48 89 04 24          	mov    %rax,(%rsp)
 1005475:	e8 9c 58 00 00       	callq  100ad16 <runtime.semrelease>
		return;
 100547a:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
 1005481:	c3                   	retq   
		if(p == nil || p[0] == '\0')
			gcpercent = 100;
		else if(runtime·strcmp(p, (byte*)"off") == 0)
			gcpercent = -1;
		else
			gcpercent = runtime·atoi(p);
 1005482:	48 8b 8c 24 88 00 00 	mov    0x88(%rsp),%rcx
 1005489:	00 
 100548a:	48 89 0c 24          	mov    %rcx,(%rsp)
 100548e:	e8 e9 4c 00 00       	callq  100a17c <runtime.atoi>
 1005493:	89 04 25 00 30 02 01 	mov    %eax,0x1023000
		
		p = runtime·getenv("GOGCTRACE");
 100549a:	e9 c3 fb ff ff       	jmpq   1005062 <runtime.gc+0xaf>
		return;

	if(gcpercent == -2) {	// first time through
		p = runtime·getenv("GOGC");
		if(p == nil || p[0] == '\0')
			gcpercent = 100;
 100549f:	c7 04 25 00 30 02 01 	movl   $0x64,0x1023000
 10054a6:	64 00 00 00 
		else if(runtime·strcmp(p, (byte*)"off") == 0)
			gcpercent = -1;
		else
			gcpercent = runtime·atoi(p);
		
		p = runtime·getenv("GOGCTRACE");
 10054aa:	e9 b3 fb ff ff       	jmpq   1005062 <runtime.gc+0xaf>

00000000010054af <runfinq>:
	runtime·semrelease(&gcsema);
	runtime·starttheworld();
}

static void
runfinq(void)
 10054af:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10054b6:	ff ff 
 10054b8:	48 3b 21             	cmp    (%rcx),%rsp
 10054bb:	77 05                	ja     10054c2 <runfinq+0x13>
 10054bd:	e8 31 c4 ff ff       	callq  10018f3 <runtime.morestack00>
 10054c2:	48 83 ec 40          	sub    $0x40,%rsp
		// because it only conflicts with the garbage
		// collector, and the garbage collector only
		// runs when everyone else is stopped, and
		// runfinq only stops at the gosched() or
		// during the calls in the for loop.
		f = finq;
 10054c6:	48 8b 14 25 70 4e 02 	mov    0x1024e70,%rdx
 10054cd:	01 
		finq = nil;
 10054ce:	48 c7 04 25 70 4e 02 	movq   $0x0,0x1024e70
 10054d5:	01 00 00 00 00 
		if(f == nil) {
 10054da:	48 83 fa 00          	cmp    $0x0,%rdx
 10054de:	75 39                	jne    1005519 <runfinq+0x6a>
			fingwait = 1;
 10054e0:	c7 04 25 e8 4d 02 01 	movl   $0x1,0x1024de8
 10054e7:	01 00 00 00 
			g->status = Gwaiting;
 10054eb:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10054f2:	ff ff 
 10054f4:	66 c7 40 70 04 00    	movw   $0x4,0x70(%rax)
			runtime·gosched();
 10054fa:	e8 b1 38 00 00       	callq  1008db0 <runtime.gosched>
		// because it only conflicts with the garbage
		// collector, and the garbage collector only
		// runs when everyone else is stopped, and
		// runfinq only stops at the gosched() or
		// during the calls in the for loop.
		f = finq;
 10054ff:	48 8b 14 25 70 4e 02 	mov    0x1024e70,%rdx
 1005506:	01 
		finq = nil;
 1005507:	48 c7 04 25 70 4e 02 	movq   $0x0,0x1024e70
 100550e:	01 00 00 00 00 
		if(f == nil) {
 1005513:	48 83 fa 00          	cmp    $0x0,%rdx
 1005517:	74 c7                	je     10054e0 <runfinq+0x31>
			fingwait = 1;
			g->status = Gwaiting;
			runtime·gosched();
			continue;
		}
		for(; f; f=next) {
 1005519:	48 83 fa 00          	cmp    $0x0,%rdx
 100551d:	0f 84 91 00 00 00    	je     10055b4 <runfinq+0x105>
			next = f->next;
 1005523:	48 8b 02             	mov    (%rdx),%rax
 1005526:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
			frame = runtime·mal(sizeof(uintptr) + f->nret);
 100552b:	48 89 54 24 38       	mov    %rdx,0x38(%rsp)
 1005530:	8b 4a 18             	mov    0x18(%rdx),%ecx
 1005533:	83 c1 08             	add    $0x8,%ecx
 1005536:	48 63 c9             	movslq %ecx,%rcx
 1005539:	48 89 0c 24          	mov    %rcx,(%rsp)
 100553d:	e8 ee db ff ff       	callq  1003130 <runtime.mal>
 1005542:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
 1005547:	48 89 c2             	mov    %rax,%rdx
			*(void**)frame = f->arg;
 100554a:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
 100554e:	48 89 08             	mov    %rcx,(%rax)
			reflect·call((byte*)f->fn, frame, sizeof(uintptr) + f->nret);
 1005551:	48 8b 43 08          	mov    0x8(%rbx),%rax
 1005555:	48 89 04 24          	mov    %rax,(%rsp)
 1005559:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
 100555e:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 1005563:	8b 43 18             	mov    0x18(%rbx),%eax
 1005566:	83 c0 08             	add    $0x8,%eax
 1005569:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100556d:	e8 e9 c2 ff ff       	callq  100185b <reflect.call>
			runtime·free(frame);
 1005572:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1005577:	48 89 04 24          	mov    %rax,(%rsp)
 100557b:	e8 4e d5 ff ff       	callq  1002ace <runtime.free>
 1005580:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
			f->fn = nil;
 1005585:	48 c7 41 08 00 00 00 	movq   $0x0,0x8(%rcx)
 100558c:	00 
			f->arg = nil;
 100558d:	48 c7 41 10 00 00 00 	movq   $0x0,0x10(%rcx)
 1005594:	00 
			f->next = nil;
 1005595:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
			runtime·free(f);
 100559c:	48 89 0c 24          	mov    %rcx,(%rsp)
 10055a0:	e8 29 d5 ff ff       	callq  1002ace <runtime.free>
			fingwait = 1;
			g->status = Gwaiting;
			runtime·gosched();
			continue;
		}
		for(; f; f=next) {
 10055a5:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
 10055aa:	48 83 fa 00          	cmp    $0x0,%rdx
 10055ae:	0f 85 6f ff ff ff    	jne    1005523 <runfinq+0x74>
			f->fn = nil;
			f->arg = nil;
			f->next = nil;
			runtime·free(f);
		}
		runtime·gc(1);	// trigger another gc to clean up the finalized objects, if possible
 10055b4:	b8 01 00 00 00       	mov    $0x1,%eax
 10055b9:	89 04 24             	mov    %eax,(%rsp)
 10055bc:	e8 f2 f9 ff ff       	callq  1004fb3 <runtime.gc>
		// because it only conflicts with the garbage
		// collector, and the garbage collector only
		// runs when everyone else is stopped, and
		// runfinq only stops at the gosched() or
		// during the calls in the for loop.
		f = finq;
 10055c1:	e9 00 ff ff ff       	jmpq   10054c6 <runfinq+0x17>

00000000010055c6 <runtime.markallocated>:
}

// mark the block at v of size n as allocated.
// If noptr is true, mark it as having no pointers.
void
runtime·markallocated(void *v, uintptr n, bool noptr)
 10055c6:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10055cd:	ff ff 
 10055cf:	48 3b 21             	cmp    (%rcx),%rsp
 10055d2:	77 05                	ja     10055d9 <runtime.markallocated+0x13>
 10055d4:	e8 85 c3 ff ff       	callq  100195e <runtime.morestack24>
 10055d9:	48 83 ec 50          	sub    $0x50,%rsp
 10055dd:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
	uintptr *b, obits, bits, off, shift;

	if(0)
		runtime·printf("markallocated %p+%p\n", v, n);

	if((byte*)v+n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
 10055e2:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
 10055e7:	48 8d 04 1a          	lea    (%rdx,%rbx,1),%rax
 10055eb:	48 3b 04 25 f0 e8 03 	cmp    0x303e8f0,%rax
 10055f2:	03 
 10055f3:	0f 87 c9 00 00 00    	ja     10056c2 <runtime.markallocated+0xfc>
 10055f9:	48 3b 1c 25 e8 e8 03 	cmp    0x303e8e8,%rbx
 1005600:	03 
 1005601:	0f 82 bb 00 00 00    	jb     10056c2 <runtime.markallocated+0xfc>
		runtime·throw("markallocated: bad pointer");

	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;  // word offset
 1005607:	48 89 d8             	mov    %rbx,%rax
 100560a:	48 2b 04 25 e8 e8 03 	sub    0x303e8e8,%rax
 1005611:	03 
 1005612:	48 c1 f8 03          	sar    $0x3,%rax
 1005616:	48 89 c2             	mov    %rax,%rdx
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
 1005619:	48 c1 e8 04          	shr    $0x4,%rax
 100561d:	48 c1 e0 03          	shl    $0x3,%rax
 1005621:	48 8b 34 25 e8 e8 03 	mov    0x303e8e8,%rsi
 1005628:	03 
 1005629:	48 29 c6             	sub    %rax,%rsi
 100562c:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
	shift = off % wordsPerBitmapWord;
 1005630:	48 89 d5             	mov    %rdx,%rbp
 1005633:	48 83 e5 0f          	and    $0xf,%rbp

	for(;;) {
		obits = *b;
 1005637:	48 8b 1e             	mov    (%rsi),%rbx
		bits = (obits & ~(bitMask<<shift)) | (bitAllocated<<shift);
 100563a:	48 63 cd             	movslq %ebp,%rcx
 100563d:	48 b8 01 00 01 00 01 	movabs $0x1000100010001,%rax
 1005644:	00 01 00 
 1005647:	48 d3 e0             	shl    %cl,%rax
 100564a:	48 f7 d0             	not    %rax
 100564d:	48 89 d9             	mov    %rbx,%rcx
 1005650:	48 21 c1             	and    %rax,%rcx
 1005653:	48 89 c8             	mov    %rcx,%rax
 1005656:	48 89 6c 24 28       	mov    %rbp,0x28(%rsp)
 100565b:	48 63 cd             	movslq %ebp,%rcx
 100565e:	48 c7 c2 01 00 00 00 	mov    $0x1,%rdx
 1005665:	48 d3 e2             	shl    %cl,%rdx
 1005668:	48 09 d0             	or     %rdx,%rax
 100566b:	48 89 c2             	mov    %rax,%rdx
		if(noptr)
 100566e:	80 7c 24 68 00       	cmpb   $0x0,0x68(%rsp)
 1005673:	74 10                	je     1005685 <runtime.markallocated+0xbf>
			bits |= bitNoPointers<<shift;
 1005675:	48 63 cd             	movslq %ebp,%rcx
 1005678:	48 c7 c0 00 00 01 00 	mov    $0x10000,%rax
 100567f:	48 d3 e0             	shl    %cl,%rax
 1005682:	48 09 c2             	or     %rax,%rdx
		if(runtime·singleproc) {
 1005685:	80 3c 25 e3 4d 02 01 	cmpb   $0x0,0x1024de3
 100568c:	00 
 100568d:	74 08                	je     1005697 <runtime.markallocated+0xd1>
			*b = bits;
 100568f:	48 89 16             	mov    %rdx,(%rsi)
			break;
		} else {
			// more than one goroutine is potentially running: use atomic op
			if(runtime·casp((void**)b, (void*)obits, (void*)bits))
				break;
 1005692:	48 83 c4 50          	add    $0x50,%rsp
 1005696:	c3                   	retq   
		if(runtime·singleproc) {
			*b = bits;
			break;
		} else {
			// more than one goroutine is potentially running: use atomic op
			if(runtime·casp((void**)b, (void*)obits, (void*)bits))
 1005697:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
 100569c:	48 89 34 24          	mov    %rsi,(%rsp)
 10056a0:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 10056a5:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
 10056aa:	e8 08 c3 ff ff       	callq  10019b7 <runtime.casp>
 10056af:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
 10056b4:	48 8b 6c 24 28       	mov    0x28(%rsp),%rbp
 10056b9:	3c 00                	cmp    $0x0,%al
 10056bb:	75 d5                	jne    1005692 <runtime.markallocated+0xcc>
	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;  // word offset
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
	shift = off % wordsPerBitmapWord;

	for(;;) {
		obits = *b;
 10056bd:	e9 75 ff ff ff       	jmpq   1005637 <runtime.markallocated+0x71>

	if(0)
		runtime·printf("markallocated %p+%p\n", v, n);

	if((byte*)v+n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
		runtime·throw("markallocated: bad pointer");
 10056c2:	b8 07 40 02 01       	mov    $0x1024007,%eax
 10056c7:	48 89 04 24          	mov    %rax,(%rsp)
 10056cb:	e8 69 46 00 00       	callq  1009d39 <runtime.throw>
 10056d0:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx

	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;  // word offset
 10056d5:	e9 2d ff ff ff       	jmpq   1005607 <runtime.markallocated+0x41>

00000000010056da <runtime.markfreed>:
	}
}

// mark the block at v of size n as freed.
void
runtime·markfreed(void *v, uintptr n)
 10056da:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10056e1:	ff ff 
 10056e3:	48 3b 21             	cmp    (%rcx),%rsp
 10056e6:	77 05                	ja     10056ed <runtime.markfreed+0x13>
 10056e8:	e8 68 c2 ff ff       	callq  1001955 <runtime.morestack16>
 10056ed:	48 83 ec 50          	sub    $0x50,%rsp
 10056f1:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
	uintptr *b, obits, bits, off, shift;

	if(0)
		runtime·printf("markallocated %p+%p\n", v, n);

	if((byte*)v+n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
 10056f6:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
 10056fb:	48 8d 04 1a          	lea    (%rdx,%rbx,1),%rax
 10056ff:	48 3b 04 25 f0 e8 03 	cmp    0x303e8f0,%rax
 1005706:	03 
 1005707:	0f 87 ab 00 00 00    	ja     10057b8 <runtime.markfreed+0xde>
 100570d:	48 3b 1c 25 e8 e8 03 	cmp    0x303e8e8,%rbx
 1005714:	03 
 1005715:	0f 82 9d 00 00 00    	jb     10057b8 <runtime.markfreed+0xde>
		runtime·throw("markallocated: bad pointer");

	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;  // word offset
 100571b:	48 89 d8             	mov    %rbx,%rax
 100571e:	48 2b 04 25 e8 e8 03 	sub    0x303e8e8,%rax
 1005725:	03 
 1005726:	48 c1 f8 03          	sar    $0x3,%rax
 100572a:	48 89 c2             	mov    %rax,%rdx
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
 100572d:	48 c1 e8 04          	shr    $0x4,%rax
 1005731:	48 c1 e0 03          	shl    $0x3,%rax
 1005735:	48 8b 2c 25 e8 e8 03 	mov    0x303e8e8,%rbp
 100573c:	03 
 100573d:	48 29 c5             	sub    %rax,%rbp
 1005740:	48 83 c5 f8          	add    $0xfffffffffffffff8,%rbp
	shift = off % wordsPerBitmapWord;
 1005744:	48 83 e2 0f          	and    $0xf,%rdx

	for(;;) {
		obits = *b;
 1005748:	48 8b 5d 00          	mov    0x0(%rbp),%rbx
		bits = (obits & ~(bitMask<<shift)) | (bitBlockBoundary<<shift);
 100574c:	48 63 ca             	movslq %edx,%rcx
 100574f:	48 b8 01 00 01 00 01 	movabs $0x1000100010001,%rax
 1005756:	00 01 00 
 1005759:	48 d3 e0             	shl    %cl,%rax
 100575c:	48 f7 d0             	not    %rax
 100575f:	48 89 d9             	mov    %rbx,%rcx
 1005762:	48 21 c1             	and    %rax,%rcx
 1005765:	48 89 c8             	mov    %rcx,%rax
 1005768:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
 100576d:	48 63 ca             	movslq %edx,%rcx
 1005770:	48 c7 c2 00 00 01 00 	mov    $0x10000,%rdx
 1005777:	48 d3 e2             	shl    %cl,%rdx
 100577a:	48 09 d0             	or     %rdx,%rax
		if(runtime·singleproc) {
 100577d:	80 3c 25 e3 4d 02 01 	cmpb   $0x0,0x1024de3
 1005784:	00 
 1005785:	74 09                	je     1005790 <runtime.markfreed+0xb6>
			*b = bits;
 1005787:	48 89 45 00          	mov    %rax,0x0(%rbp)
			break;
		} else {
			// more than one goroutine is potentially running: use atomic op
			if(runtime·casp((void**)b, (void*)obits, (void*)bits))
				break;
 100578b:	48 83 c4 50          	add    $0x50,%rsp
 100578f:	c3                   	retq   
		if(runtime·singleproc) {
			*b = bits;
			break;
		} else {
			// more than one goroutine is potentially running: use atomic op
			if(runtime·casp((void**)b, (void*)obits, (void*)bits))
 1005790:	48 89 6c 24 48       	mov    %rbp,0x48(%rsp)
 1005795:	48 89 2c 24          	mov    %rbp,(%rsp)
 1005799:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 100579e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 10057a3:	e8 0f c2 ff ff       	callq  10019b7 <runtime.casp>
 10057a8:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 10057ad:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
 10057b2:	3c 00                	cmp    $0x0,%al
 10057b4:	75 d5                	jne    100578b <runtime.markfreed+0xb1>
	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;  // word offset
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
	shift = off % wordsPerBitmapWord;

	for(;;) {
		obits = *b;
 10057b6:	eb 90                	jmp    1005748 <runtime.markfreed+0x6e>

	if(0)
		runtime·printf("markallocated %p+%p\n", v, n);

	if((byte*)v+n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
		runtime·throw("markallocated: bad pointer");
 10057b8:	b8 22 40 02 01       	mov    $0x1024022,%eax
 10057bd:	48 89 04 24          	mov    %rax,(%rsp)
 10057c1:	e8 73 45 00 00       	callq  1009d39 <runtime.throw>
 10057c6:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx

	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;  // word offset
 10057cb:	e9 4b ff ff ff       	jmpq   100571b <runtime.markfreed+0x41>

00000000010057d0 <runtime.checkfreed>:
	}
}

// check that the block at v of size n is marked freed.
void
runtime·checkfreed(void *v, uintptr n)
 10057d0:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10057d7:	ff ff 
 10057d9:	48 3b 21             	cmp    (%rcx),%rsp
 10057dc:	77 05                	ja     10057e3 <runtime.checkfreed+0x13>
 10057de:	e8 72 c1 ff ff       	callq  1001955 <runtime.morestack16>
 10057e3:	48 83 ec 58          	sub    $0x58,%rsp
 10057e7:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
 10057ec:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
{
	uintptr *b, bits, off, shift;

	if(!runtime·checking)
 10057f1:	83 3c 25 10 4e 02 01 	cmpl   $0x0,0x1024e10
 10057f8:	00 
 10057f9:	75 05                	jne    1005800 <runtime.checkfreed+0x30>
		return;
 10057fb:	48 83 c4 58          	add    $0x58,%rsp
 10057ff:	c3                   	retq   

	if((byte*)v+n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
 1005800:	48 8d 04 1f          	lea    (%rdi,%rbx,1),%rax
 1005804:	48 3b 04 25 f0 e8 03 	cmp    0x303e8f0,%rax
 100580b:	03 
 100580c:	0f 87 99 00 00 00    	ja     10058ab <runtime.checkfreed+0xdb>
 1005812:	48 3b 1c 25 e8 e8 03 	cmp    0x303e8e8,%rbx
 1005819:	03 
 100581a:	0f 82 8b 00 00 00    	jb     10058ab <runtime.checkfreed+0xdb>
		return;	// not allocated, so okay

	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;  // word offset
 1005820:	48 89 d8             	mov    %rbx,%rax
 1005823:	48 2b 04 25 e8 e8 03 	sub    0x303e8e8,%rax
 100582a:	03 
 100582b:	48 c1 f8 03          	sar    $0x3,%rax
 100582f:	48 89 c2             	mov    %rax,%rdx
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
 1005832:	48 c1 e8 04          	shr    $0x4,%rax
 1005836:	48 c1 e0 03          	shl    $0x3,%rax
 100583a:	48 8b 34 25 e8 e8 03 	mov    0x303e8e8,%rsi
 1005841:	03 
 1005842:	48 29 c6             	sub    %rax,%rsi
 1005845:	48 83 c6 f8          	add    $0xfffffffffffffff8,%rsi
	shift = off % wordsPerBitmapWord;
 1005849:	48 89 d0             	mov    %rdx,%rax
 100584c:	48 83 e0 0f          	and    $0xf,%rax

	bits = *b>>shift;
 1005850:	48 63 c8             	movslq %eax,%rcx
 1005853:	48 8b 06             	mov    (%rsi),%rax
 1005856:	48 d3 e8             	shr    %cl,%rax
 1005859:	48 89 c1             	mov    %rax,%rcx
	if((bits & bitAllocated) != 0) {
 100585c:	48 83 e0 01          	and    $0x1,%rax
 1005860:	48 83 f8 00          	cmp    $0x0,%rax
 1005864:	74 40                	je     10058a6 <runtime.checkfreed+0xd6>
		runtime·printf("checkfreed %p+%p: off=%p have=%p\n",
 1005866:	b8 3d 40 02 01       	mov    $0x102403d,%eax
 100586b:	48 89 04 24          	mov    %rax,(%rsp)
 100586f:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 1005874:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
 1005879:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
 100587e:	48 89 c8             	mov    %rcx,%rax
 1005881:	48 b9 01 00 01 00 01 	movabs $0x1000100010001,%rcx
 1005888:	00 01 00 
 100588b:	48 21 c8             	and    %rcx,%rax
 100588e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1005893:	e8 a6 1a 00 00       	callq  100733e <runtime.printf>
			v, n, off, bits & bitMask);
		runtime·throw("checkfreed: not freed");
 1005898:	b8 5f 40 02 01       	mov    $0x102405f,%eax
 100589d:	48 89 04 24          	mov    %rax,(%rsp)
 10058a1:	e8 93 44 00 00       	callq  1009d39 <runtime.throw>
 10058a6:	48 83 c4 58          	add    $0x58,%rsp
 10058aa:	c3                   	retq   

	if(!runtime·checking)
		return;

	if((byte*)v+n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
		return;	// not allocated, so okay
 10058ab:	48 83 c4 58          	add    $0x58,%rsp
 10058af:	c3                   	retq   

00000000010058b0 <runtime.markspan>:
}

// mark the span of memory at v as having n blocks of the given size.
// if leftover is true, there is left over space at the end of the span.
void
runtime·markspan(void *v, uintptr size, uintptr n, bool leftover)
 10058b0:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10058b7:	ff ff 
 10058b9:	48 3b 21             	cmp    (%rcx),%rsp
 10058bc:	77 05                	ja     10058c3 <runtime.markspan+0x13>
 10058be:	e8 a4 c0 ff ff       	callq  1001967 <runtime.morestack32>
 10058c3:	48 83 ec 38          	sub    $0x38,%rsp
 10058c7:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
 10058cc:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
 10058d1:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
{
	uintptr *b, off, shift;
	byte *p;

	if((byte*)v+size*n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
 10058d6:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10058db:	48 89 f8             	mov    %rdi,%rax
 10058de:	48 f7 e6             	mul    %rsi
 10058e1:	48 89 c1             	mov    %rax,%rcx
 10058e4:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
 10058e9:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
 10058ed:	48 3b 04 25 f0 e8 03 	cmp    0x303e8f0,%rax
 10058f4:	03 
 10058f5:	0f 87 97 00 00 00    	ja     1005992 <runtime.markspan+0xe2>
 10058fb:	48 3b 1c 25 e8 e8 03 	cmp    0x303e8e8,%rbx
 1005902:	03 
 1005903:	0f 82 89 00 00 00    	jb     1005992 <runtime.markspan+0xe2>
		runtime·throw("markspan: bad pointer");

	p = v;
 1005909:	48 89 dd             	mov    %rbx,%rbp
	if(leftover)	// mark a boundary just past end of last block too
 100590c:	80 7c 24 58 00       	cmpb   $0x0,0x58(%rsp)
 1005911:	74 03                	je     1005916 <runtime.markspan+0x66>
		n++;
 1005913:	48 ff c6             	inc    %rsi
	for(; n-- > 0; p += size) {
 1005916:	48 89 f0             	mov    %rsi,%rax
 1005919:	48 ff ce             	dec    %rsi
 100591c:	48 83 f8 00          	cmp    $0x0,%rax
 1005920:	76 6b                	jbe    100598d <runtime.markspan+0xdd>
		// Okay to use non-atomic ops here, because we control
		// the entire span, and each bitmap word has bits for only
		// one span, so no other goroutines are changing these
		// bitmap words.
		off = (uintptr*)p - (uintptr*)runtime·mheap.arena_start;  // word offset
 1005922:	48 89 e8             	mov    %rbp,%rax
 1005925:	48 2b 04 25 e8 e8 03 	sub    0x303e8e8,%rax
 100592c:	03 
 100592d:	48 c1 f8 03          	sar    $0x3,%rax
 1005931:	48 89 c2             	mov    %rax,%rdx
		b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
 1005934:	48 c1 e8 04          	shr    $0x4,%rax
 1005938:	48 c1 e0 03          	shl    $0x3,%rax
 100593c:	48 8b 1c 25 e8 e8 03 	mov    0x303e8e8,%rbx
 1005943:	03 
 1005944:	48 29 c3             	sub    %rax,%rbx
 1005947:	48 83 c3 f8          	add    $0xfffffffffffffff8,%rbx
		shift = off % wordsPerBitmapWord;
 100594b:	48 83 e2 0f          	and    $0xf,%rdx
		*b = (*b & ~(bitMask<<shift)) | (bitBlockBoundary<<shift);
 100594f:	48 63 ca             	movslq %edx,%rcx
 1005952:	48 b8 01 00 01 00 01 	movabs $0x1000100010001,%rax
 1005959:	00 01 00 
 100595c:	48 d3 e0             	shl    %cl,%rax
 100595f:	48 f7 d0             	not    %rax
 1005962:	48 8b 0b             	mov    (%rbx),%rcx
 1005965:	48 21 c1             	and    %rax,%rcx
 1005968:	48 89 c8             	mov    %rcx,%rax
 100596b:	48 63 ca             	movslq %edx,%rcx
 100596e:	48 c7 c2 00 00 01 00 	mov    $0x10000,%rdx
 1005975:	48 d3 e2             	shl    %cl,%rdx
 1005978:	48 09 d0             	or     %rdx,%rax
 100597b:	48 89 03             	mov    %rax,(%rbx)
		runtime·throw("markspan: bad pointer");

	p = v;
	if(leftover)	// mark a boundary just past end of last block too
		n++;
	for(; n-- > 0; p += size) {
 100597e:	48 01 fd             	add    %rdi,%rbp
 1005981:	48 89 f0             	mov    %rsi,%rax
 1005984:	48 ff ce             	dec    %rsi
 1005987:	48 83 f8 00          	cmp    $0x0,%rax
 100598b:	77 95                	ja     1005922 <runtime.markspan+0x72>
		// one span, so no other goroutines are changing these
		// bitmap words.
		off = (uintptr*)p - (uintptr*)runtime·mheap.arena_start;  // word offset
		b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
		shift = off % wordsPerBitmapWord;
		*b = (*b & ~(bitMask<<shift)) | (bitBlockBoundary<<shift);
 100598d:	48 83 c4 38          	add    $0x38,%rsp
 1005991:	c3                   	retq   
{
	uintptr *b, off, shift;
	byte *p;

	if((byte*)v+size*n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
		runtime·throw("markspan: bad pointer");
 1005992:	b8 75 40 02 01       	mov    $0x1024075,%eax
 1005997:	48 89 04 24          	mov    %rax,(%rsp)
 100599b:	e8 99 43 00 00       	callq  1009d39 <runtime.throw>
 10059a0:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
 10059a5:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
 10059aa:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi

	p = v;
 10059af:	e9 55 ff ff ff       	jmpq   1005909 <runtime.markspan+0x59>

00000000010059b4 <runtime.unmarkspan>:
	}
}

// unmark the span of memory at v of length n bytes.
void
runtime·unmarkspan(void *v, uintptr n)
 10059b4:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10059bb:	ff ff 
 10059bd:	48 3b 21             	cmp    (%rcx),%rsp
 10059c0:	77 05                	ja     10059c7 <runtime.unmarkspan+0x13>
 10059c2:	e8 8e bf ff ff       	callq  1001955 <runtime.morestack16>
 10059c7:	48 83 ec 30          	sub    $0x30,%rsp
 10059cb:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
 10059d0:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
{
	uintptr *p, *b, off;

	if((byte*)v+n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
 10059d5:	48 8d 04 2b          	lea    (%rbx,%rbp,1),%rax
 10059d9:	48 3b 04 25 f0 e8 03 	cmp    0x303e8f0,%rax
 10059e0:	03 
 10059e1:	0f 87 c3 00 00 00    	ja     1005aaa <runtime.unmarkspan+0xf6>
 10059e7:	48 3b 2c 25 e8 e8 03 	cmp    0x303e8e8,%rbp
 10059ee:	03 
 10059ef:	0f 82 b5 00 00 00    	jb     1005aaa <runtime.unmarkspan+0xf6>
		runtime·throw("markspan: bad pointer");

	p = v;
	off = p - (uintptr*)runtime·mheap.arena_start;  // word offset
 10059f5:	48 89 e8             	mov    %rbp,%rax
 10059f8:	48 2b 04 25 e8 e8 03 	sub    0x303e8e8,%rax
 10059ff:	03 
 1005a00:	48 c1 f8 03          	sar    $0x3,%rax
 1005a04:	48 89 c1             	mov    %rax,%rcx
	if(off % wordsPerBitmapWord != 0)
 1005a07:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1005a0c:	48 83 e0 0f          	and    $0xf,%rax
 1005a10:	48 83 f8 00          	cmp    $0x0,%rax
 1005a14:	74 18                	je     1005a2e <runtime.unmarkspan+0x7a>
		runtime·throw("markspan: unaligned pointer");
 1005a16:	b8 a1 40 02 01       	mov    $0x10240a1,%eax
 1005a1b:	48 89 04 24          	mov    %rax,(%rsp)
 1005a1f:	e8 15 43 00 00       	callq  1009d39 <runtime.throw>
 1005a24:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
 1005a29:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
 1005a2e:	48 89 c8             	mov    %rcx,%rax
 1005a31:	48 c1 e8 04          	shr    $0x4,%rax
 1005a35:	48 c1 e0 03          	shl    $0x3,%rax
 1005a39:	48 8b 0c 25 e8 e8 03 	mov    0x303e8e8,%rcx
 1005a40:	03 
 1005a41:	48 29 c1             	sub    %rax,%rcx
 1005a44:	48 83 c1 f8          	add    $0xfffffffffffffff8,%rcx
 1005a48:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
	n /= PtrSize;
 1005a4d:	48 c1 eb 03          	shr    $0x3,%rbx
	if(n%wordsPerBitmapWord != 0)
 1005a51:	48 89 d8             	mov    %rbx,%rax
 1005a54:	48 89 5c 24 40       	mov    %rbx,0x40(%rsp)
 1005a59:	48 83 e0 0f          	and    $0xf,%rax
 1005a5d:	48 83 f8 00          	cmp    $0x0,%rax
 1005a61:	74 18                	je     1005a7b <runtime.unmarkspan+0xc7>
		runtime·throw("unmarkspan: unaligned length");
 1005a63:	b8 bd 40 02 01       	mov    $0x10240bd,%eax
 1005a68:	48 89 04 24          	mov    %rax,(%rsp)
 1005a6c:	e8 c8 42 00 00       	callq  1009d39 <runtime.throw>
 1005a71:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
 1005a76:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
	// Okay to use non-atomic ops here, because we control
	// the entire span, and each bitmap word has bits for only
	// one span, so no other goroutines are changing these
	// bitmap words.
	n /= wordsPerBitmapWord;
 1005a7b:	48 c1 eb 04          	shr    $0x4,%rbx
	while(n-- > 0)
 1005a7f:	48 89 d8             	mov    %rbx,%rax
 1005a82:	48 ff cb             	dec    %rbx
 1005a85:	48 83 f8 00          	cmp    $0x0,%rax
 1005a89:	76 1a                	jbe    1005aa5 <runtime.unmarkspan+0xf1>
		*b-- = 0;
 1005a8b:	48 89 c8             	mov    %rcx,%rax
 1005a8e:	48 83 c1 f8          	add    $0xfffffffffffffff8,%rcx
 1005a92:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	// Okay to use non-atomic ops here, because we control
	// the entire span, and each bitmap word has bits for only
	// one span, so no other goroutines are changing these
	// bitmap words.
	n /= wordsPerBitmapWord;
	while(n-- > 0)
 1005a99:	48 89 d8             	mov    %rbx,%rax
 1005a9c:	48 ff cb             	dec    %rbx
 1005a9f:	48 83 f8 00          	cmp    $0x0,%rax
 1005aa3:	77 e6                	ja     1005a8b <runtime.unmarkspan+0xd7>
		*b-- = 0;
 1005aa5:	48 83 c4 30          	add    $0x30,%rsp
 1005aa9:	c3                   	retq   
runtime·unmarkspan(void *v, uintptr n)
{
	uintptr *p, *b, off;

	if((byte*)v+n > (byte*)runtime·mheap.arena_used || (byte*)v < runtime·mheap.arena_start)
		runtime·throw("markspan: bad pointer");
 1005aaa:	b8 8b 40 02 01       	mov    $0x102408b,%eax
 1005aaf:	48 89 04 24          	mov    %rax,(%rsp)
 1005ab3:	e8 81 42 00 00       	callq  1009d39 <runtime.throw>
 1005ab8:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
 1005abd:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx

	p = v;
	off = p - (uintptr*)runtime·mheap.arena_start;  // word offset
 1005ac2:	e9 2e ff ff ff       	jmpq   10059f5 <runtime.unmarkspan+0x41>

0000000001005ac7 <runtime.blockspecial>:
	while(n-- > 0)
		*b-- = 0;
}

bool
runtime·blockspecial(void *v)
 1005ac7:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1005ace:	ff ff 
 1005ad0:	48 3b 21             	cmp    (%rcx),%rsp
 1005ad3:	77 05                	ja     1005ada <runtime.blockspecial+0x13>
 1005ad5:	e8 72 be ff ff       	callq  100194c <runtime.morestack8>
 1005ada:	48 83 ec 20          	sub    $0x20,%rsp
{
	uintptr *b, off, shift;

	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;
 1005ade:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1005ae3:	48 2b 04 25 e8 e8 03 	sub    0x303e8e8,%rax
 1005aea:	03 
 1005aeb:	48 c1 f8 03          	sar    $0x3,%rax
 1005aef:	48 89 c2             	mov    %rax,%rdx
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
 1005af2:	48 c1 e8 04          	shr    $0x4,%rax
 1005af6:	48 c1 e0 03          	shl    $0x3,%rax
 1005afa:	48 8b 1c 25 e8 e8 03 	mov    0x303e8e8,%rbx
 1005b01:	03 
 1005b02:	48 29 c3             	sub    %rax,%rbx
 1005b05:	48 83 c3 f8          	add    $0xfffffffffffffff8,%rbx
	shift = off % wordsPerBitmapWord;
 1005b09:	48 89 d0             	mov    %rdx,%rax
 1005b0c:	48 83 e0 0f          	and    $0xf,%rax

	return (*b & (bitSpecial<<shift)) != 0;
 1005b10:	48 63 c8             	movslq %eax,%rcx
 1005b13:	48 b8 00 00 00 00 00 	movabs $0x1000000000000,%rax
 1005b1a:	00 01 00 
 1005b1d:	48 d3 e0             	shl    %cl,%rax
 1005b20:	48 8b 0b             	mov    (%rbx),%rcx
 1005b23:	48 21 c1             	and    %rax,%rcx
 1005b26:	48 83 f9 00          	cmp    $0x0,%rcx
 1005b2a:	74 0a                	je     1005b36 <runtime.blockspecial+0x6f>
 1005b2c:	b8 01 00 00 00       	mov    $0x1,%eax
 1005b31:	48 83 c4 20          	add    $0x20,%rsp
 1005b35:	c3                   	retq   
 1005b36:	31 c0                	xor    %eax,%eax
 1005b38:	eb f7                	jmp    1005b31 <runtime.blockspecial+0x6a>

0000000001005b3a <runtime.setblockspecial>:
}

void
runtime·setblockspecial(void *v)
 1005b3a:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1005b41:	ff ff 
 1005b43:	48 3b 21             	cmp    (%rcx),%rsp
 1005b46:	77 05                	ja     1005b4d <runtime.setblockspecial+0x13>
 1005b48:	e8 ff bd ff ff       	callq  100194c <runtime.morestack8>
 1005b4d:	48 83 ec 50          	sub    $0x50,%rsp
{
	uintptr *b, off, shift, bits, obits;

	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;
 1005b51:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 1005b56:	48 2b 04 25 e8 e8 03 	sub    0x303e8e8,%rax
 1005b5d:	03 
 1005b5e:	48 c1 f8 03          	sar    $0x3,%rax
 1005b62:	48 89 c2             	mov    %rax,%rdx
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
 1005b65:	48 c1 e8 04          	shr    $0x4,%rax
 1005b69:	48 c1 e0 03          	shl    $0x3,%rax
 1005b6d:	48 8b 2c 25 e8 e8 03 	mov    0x303e8e8,%rbp
 1005b74:	03 
 1005b75:	48 29 c5             	sub    %rax,%rbp
 1005b78:	48 83 c5 f8          	add    $0xfffffffffffffff8,%rbp
	shift = off % wordsPerBitmapWord;
 1005b7c:	48 89 d0             	mov    %rdx,%rax
 1005b7f:	48 83 e0 0f          	and    $0xf,%rax
 1005b83:	48 89 44 24 38       	mov    %rax,0x38(%rsp)

	for(;;) {
		obits = *b;
 1005b88:	48 8b 5d 00          	mov    0x0(%rbp),%rbx
		bits = obits | (bitSpecial<<shift);
 1005b8c:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 1005b91:	48 63 c9             	movslq %ecx,%rcx
 1005b94:	48 b8 00 00 00 00 00 	movabs $0x1000000000000,%rax
 1005b9b:	00 01 00 
 1005b9e:	48 d3 e0             	shl    %cl,%rax
 1005ba1:	48 89 da             	mov    %rbx,%rdx
 1005ba4:	48 09 c2             	or     %rax,%rdx
		if(runtime·singleproc) {
 1005ba7:	80 3c 25 e3 4d 02 01 	cmpb   $0x0,0x1024de3
 1005bae:	00 
 1005baf:	74 09                	je     1005bba <runtime.setblockspecial+0x80>
			*b = bits;
 1005bb1:	48 89 55 00          	mov    %rdx,0x0(%rbp)
			break;
		} else {
			// more than one goroutine is potentially running: use atomic op
			if(runtime·casp((void**)b, (void*)obits, (void*)bits))
				break;
 1005bb5:	48 83 c4 50          	add    $0x50,%rsp
 1005bb9:	c3                   	retq   
		if(runtime·singleproc) {
			*b = bits;
			break;
		} else {
			// more than one goroutine is potentially running: use atomic op
			if(runtime·casp((void**)b, (void*)obits, (void*)bits))
 1005bba:	48 89 6c 24 48       	mov    %rbp,0x48(%rsp)
 1005bbf:	48 89 2c 24          	mov    %rbp,(%rsp)
 1005bc3:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 1005bc8:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
 1005bcd:	e8 e5 bd ff ff       	callq  10019b7 <runtime.casp>
 1005bd2:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
 1005bd7:	80 f8 00             	cmp    $0x0,%al
 1005bda:	75 d9                	jne    1005bb5 <runtime.setblockspecial+0x7b>
	off = (uintptr*)v - (uintptr*)runtime·mheap.arena_start;
	b = (uintptr*)runtime·mheap.arena_start - off/wordsPerBitmapWord - 1;
	shift = off % wordsPerBitmapWord;

	for(;;) {
		obits = *b;
 1005bdc:	eb aa                	jmp    1005b88 <runtime.setblockspecial+0x4e>

0000000001005bde <runtime.MHeap_MapBits>:
		}
	}
}
 
void
runtime·MHeap_MapBits(MHeap *h)
 1005bde:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1005be5:	ff ff 
 1005be7:	48 3b 21             	cmp    (%rcx),%rsp
 1005bea:	77 05                	ja     1005bf1 <runtime.MHeap_MapBits+0x13>
 1005bec:	e8 5b bd ff ff       	callq  100194c <runtime.morestack8>
 1005bf1:	48 83 ec 28          	sub    $0x28,%rsp
 1005bf5:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
	enum {
		bitmapChunk = 8192
	};
	uintptr n;
	
	n = (h->arena_used - h->arena_start) / wordsPerBitmapWord;
 1005bfa:	48 89 d8             	mov    %rbx,%rax
 1005bfd:	48 05 70 48 00 02    	add    $0x2004870,%rax
 1005c03:	48 8b 00             	mov    (%rax),%rax
 1005c06:	48 89 d9             	mov    %rbx,%rcx
 1005c09:	48 81 c1 68 48 00 02 	add    $0x2004868,%rcx
 1005c10:	48 8b 09             	mov    (%rcx),%rcx
 1005c13:	48 29 c8             	sub    %rcx,%rax
 1005c16:	48 99                	cqto   
 1005c18:	48 c7 44 24 10 10 00 	movq   $0x10,0x10(%rsp)
 1005c1f:	00 00 
 1005c21:	48 f7 7c 24 10       	idivq  0x10(%rsp)
	n = (n+bitmapChunk-1) & ~(bitmapChunk-1);
 1005c26:	48 05 ff 1f 00 00    	add    $0x1fff,%rax
 1005c2c:	48 25 00 e0 ff ff    	and    $0xffffffffffffe000,%rax
 1005c32:	48 89 c2             	mov    %rax,%rdx
	if(h->bitmap_mapped >= n)
 1005c35:	48 89 d8             	mov    %rbx,%rax
 1005c38:	48 05 60 48 00 02    	add    $0x2004860,%rax
 1005c3e:	48 8b 00             	mov    (%rax),%rax
 1005c41:	48 39 d0             	cmp    %rdx,%rax
 1005c44:	72 05                	jb     1005c4b <runtime.MHeap_MapBits+0x6d>
		return;
 1005c46:	48 83 c4 28          	add    $0x28,%rsp
 1005c4a:	c3                   	retq   

	runtime·SysMap(h->arena_start - n, n - h->bitmap_mapped);
 1005c4b:	48 89 d8             	mov    %rbx,%rax
 1005c4e:	48 05 68 48 00 02    	add    $0x2004868,%rax
 1005c54:	48 8b 00             	mov    (%rax),%rax
 1005c57:	48 29 d0             	sub    %rdx,%rax
 1005c5a:	48 89 04 24          	mov    %rax,(%rsp)
 1005c5e:	48 89 d8             	mov    %rbx,%rax
 1005c61:	48 05 60 48 00 02    	add    $0x2004860,%rax
 1005c67:	48 8b 00             	mov    (%rax),%rax
 1005c6a:	48 89 d1             	mov    %rdx,%rcx
 1005c6d:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
 1005c72:	48 29 c1             	sub    %rax,%rcx
 1005c75:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1005c7a:	e8 14 e1 ff ff       	callq  1003d93 <runtime.SysMap>
 1005c7f:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1005c84:	48 05 60 48 00 02    	add    $0x2004860,%rax
 1005c8a:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 1005c8f:	48 89 08             	mov    %rcx,(%rax)
 1005c92:	48 83 c4 28          	add    $0x28,%rsp
 1005c96:	c3                   	retq   

0000000001005c97 <RecordSpan>:
static void MHeap_FreeLocked(MHeap*, MSpan*);
static MSpan *MHeap_AllocLarge(MHeap*, uintptr);
static MSpan *BestFit(MSpan*, uintptr, MSpan*);

static void
RecordSpan(void *vh, byte *p)
 1005c97:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1005c9e:	ff ff 
 1005ca0:	48 3b 21             	cmp    (%rcx),%rsp
 1005ca3:	77 05                	ja     1005caa <RecordSpan+0x13>
 1005ca5:	e8 ab bc ff ff       	callq  1001955 <runtime.morestack16>
 1005caa:	48 83 ec 18          	sub    $0x18,%rsp
{
	MHeap *h;
	MSpan *s;

	h = vh;
 1005cae:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
	s = (MSpan*)p;
 1005cb3:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
	s->allnext = h->allspans;
 1005cb8:	48 8b 8b 50 48 00 00 	mov    0x4850(%rbx),%rcx
 1005cbf:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
	h->allspans = s;
 1005cc3:	48 89 93 50 48 00 00 	mov    %rdx,0x4850(%rbx)
 1005cca:	48 83 c4 18          	add    $0x18,%rsp
 1005cce:	c3                   	retq   

0000000001005ccf <runtime.MHeap_Init>:
}

// Initialize the heap; fetch memory using alloc.
void
runtime·MHeap_Init(MHeap *h, void *(*alloc)(uintptr))
 1005ccf:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1005cd6:	ff ff 
 1005cd8:	48 3b 21             	cmp    (%rcx),%rsp
 1005cdb:	77 05                	ja     1005ce2 <runtime.MHeap_Init+0x13>
 1005cdd:	e8 73 bc ff ff       	callq  1001955 <runtime.morestack16>
 1005ce2:	48 83 ec 40          	sub    $0x40,%rsp
 1005ce6:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
{
	uint32 i;

	runtime·FixAlloc_Init(&h->spanalloc, sizeof(MSpan), alloc, RecordSpan, h);
 1005ceb:	48 89 c8             	mov    %rcx,%rax
 1005cee:	48 05 88 70 00 02    	add    $0x2007088,%rax
 1005cf4:	48 89 04 24          	mov    %rax,(%rsp)
 1005cf8:	48 c7 c0 48 00 00 00 	mov    $0x48,%rax
 1005cff:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1005d04:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1005d09:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1005d0e:	b8 97 5c 00 01       	mov    $0x1005c97,%eax
 1005d13:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1005d18:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 1005d1d:	e8 06 e4 ff ff       	callq  1004128 <runtime.FixAlloc_Init>
	runtime·FixAlloc_Init(&h->cachealloc, sizeof(MCache), alloc, nil, nil);
 1005d22:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1005d27:	48 05 d0 70 00 02    	add    $0x20070d0,%rax
 1005d2d:	48 89 04 24          	mov    %rax,(%rsp)
 1005d31:	48 c7 c0 e8 07 00 00 	mov    $0x7e8,%rax
 1005d38:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1005d3d:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1005d42:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1005d47:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
 1005d4e:	00 00 
 1005d50:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
 1005d57:	00 00 
 1005d59:	e8 ca e3 ff ff       	callq  1004128 <runtime.FixAlloc_Init>
	// h->mapcache needs no init
	for(i=0; i<nelem(h->free); i++)
 1005d5e:	31 d2                	xor    %edx,%edx
 1005d60:	81 fa 00 01 00 00    	cmp    $0x100,%edx
 1005d66:	73 2e                	jae    1005d96 <runtime.MHeap_Init+0xc7>
		runtime·MSpanList_Init(&h->free[i]);
 1005d68:	89 54 24 3c          	mov    %edx,0x3c(%rsp)
 1005d6c:	89 d1                	mov    %edx,%ecx
 1005d6e:	48 6b c9 48          	imul   $0x48,%rcx,%rcx
 1005d72:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
 1005d77:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1005d7b:	48 83 c0 08          	add    $0x8,%rax
 1005d7f:	48 89 04 24          	mov    %rax,(%rsp)
 1005d83:	e8 07 0b 00 00       	callq  100688f <runtime.MSpanList_Init>
 1005d88:	8b 54 24 3c          	mov    0x3c(%rsp),%edx
	uint32 i;

	runtime·FixAlloc_Init(&h->spanalloc, sizeof(MSpan), alloc, RecordSpan, h);
	runtime·FixAlloc_Init(&h->cachealloc, sizeof(MCache), alloc, nil, nil);
	// h->mapcache needs no init
	for(i=0; i<nelem(h->free); i++)
 1005d8c:	ff c2                	inc    %edx
 1005d8e:	81 fa 00 01 00 00    	cmp    $0x100,%edx
 1005d94:	72 d2                	jb     1005d68 <runtime.MHeap_Init+0x99>
		runtime·MSpanList_Init(&h->free[i]);
	runtime·MSpanList_Init(&h->large);
 1005d96:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1005d9b:	48 05 08 48 00 00    	add    $0x4808,%rax
 1005da1:	48 89 04 24          	mov    %rax,(%rsp)
 1005da5:	e8 e5 0a 00 00       	callq  100688f <runtime.MSpanList_Init>
	for(i=0; i<nelem(h->central); i++)
 1005daa:	31 db                	xor    %ebx,%ebx
 1005dac:	83 fb 3d             	cmp    $0x3d,%ebx
 1005daf:	73 34                	jae    1005de5 <runtime.MHeap_Init+0x116>
		runtime·MCentral_Init(&h->central[i], i);
 1005db1:	89 d9                	mov    %ebx,%ecx
 1005db3:	48 69 c9 a8 00 00 00 	imul   $0xa8,%rcx,%rcx
 1005dba:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
 1005dbf:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1005dc3:	48 05 80 48 00 02    	add    $0x2004880,%rax
 1005dc9:	48 89 04 24          	mov    %rax,(%rsp)
 1005dcd:	89 5c 24 3c          	mov    %ebx,0x3c(%rsp)
 1005dd1:	89 5c 24 08          	mov    %ebx,0x8(%rsp)
 1005dd5:	e8 9b d8 ff ff       	callq  1003675 <runtime.MCentral_Init>
 1005dda:	8b 5c 24 3c          	mov    0x3c(%rsp),%ebx
	runtime·FixAlloc_Init(&h->cachealloc, sizeof(MCache), alloc, nil, nil);
	// h->mapcache needs no init
	for(i=0; i<nelem(h->free); i++)
		runtime·MSpanList_Init(&h->free[i]);
	runtime·MSpanList_Init(&h->large);
	for(i=0; i<nelem(h->central); i++)
 1005dde:	ff c3                	inc    %ebx
 1005de0:	83 fb 3d             	cmp    $0x3d,%ebx
 1005de3:	72 cc                	jb     1005db1 <runtime.MHeap_Init+0xe2>
		runtime·MCentral_Init(&h->central[i], i);
 1005de5:	48 83 c4 40          	add    $0x40,%rsp
 1005de9:	c3                   	retq   

0000000001005dea <runtime.MHeap_Alloc>:
}

// Allocate a new span of npage pages from the heap
// and record its size class in the HeapMap and HeapMapCache.
MSpan*
runtime·MHeap_Alloc(MHeap *h, uintptr npage, int32 sizeclass, int32 acct)
 1005dea:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1005df1:	ff ff 
 1005df3:	48 3b 21             	cmp    (%rcx),%rsp
 1005df6:	77 05                	ja     1005dfd <runtime.MHeap_Alloc+0x13>
 1005df8:	e8 61 bb ff ff       	callq  100195e <runtime.morestack24>
 1005dfd:	48 83 ec 30          	sub    $0x30,%rsp
{
	MSpan *s;

	runtime·lock(h);
 1005e01:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 1005e06:	48 89 04 24          	mov    %rax,(%rsp)
 1005e0a:	e8 21 70 00 00       	callq  100ce30 <runtime.lock>
	runtime·purgecachedstats(m);
 1005e0f:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1005e16:	ff ff 
 1005e18:	48 89 04 24          	mov    %rax,(%rsp)
 1005e1c:	e8 6d d0 ff ff       	callq  1002e8e <runtime.purgecachedstats>
	s = MHeap_AllocLocked(h, npage, sizeclass);
 1005e21:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 1005e26:	48 89 0c 24          	mov    %rcx,(%rsp)
 1005e2a:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 1005e2f:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1005e34:	8b 4c 24 48          	mov    0x48(%rsp),%ecx
 1005e38:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1005e3c:	e8 55 00 00 00       	callq  1005e96 <MHeap_AllocLocked>
 1005e41:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
	if(s != nil) {
 1005e46:	48 83 f8 00          	cmp    $0x0,%rax
 1005e4a:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 1005e4f:	74 2d                	je     1005e7e <runtime.MHeap_Alloc+0x94>
		mstats.heap_inuse += npage<<PageShift;
 1005e51:	48 89 d0             	mov    %rdx,%rax
 1005e54:	48 c1 e0 0c          	shl    $0xc,%rax
 1005e58:	48 01 04 25 a0 62 02 	add    %rax,0x10262a0
 1005e5f:	01 
		if(acct) {
 1005e60:	83 7c 24 4c 00       	cmpl   $0x0,0x4c(%rsp)
 1005e65:	74 17                	je     1005e7e <runtime.MHeap_Alloc+0x94>
			mstats.heap_objects++;
 1005e67:	48 ff 04 25 a8 62 02 	incq   0x10262a8
 1005e6e:	01 
			mstats.heap_alloc += npage<<PageShift;
 1005e6f:	48 89 d0             	mov    %rdx,%rax
 1005e72:	48 c1 e0 0c          	shl    $0xc,%rax
 1005e76:	48 01 04 25 88 62 02 	add    %rax,0x1026288
 1005e7d:	01 
		}
	}
	runtime·unlock(h);
 1005e7e:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 1005e83:	48 89 04 24          	mov    %rax,(%rsp)
 1005e87:	e8 f6 6f 00 00       	callq  100ce82 <runtime.unlock>
	return s;
 1005e8c:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1005e91:	48 83 c4 30          	add    $0x30,%rsp
 1005e95:	c3                   	retq   

0000000001005e96 <MHeap_AllocLocked>:
}

static MSpan*
MHeap_AllocLocked(MHeap *h, uintptr npage, int32 sizeclass)
 1005e96:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1005e9d:	ff ff 
 1005e9f:	48 3b 21             	cmp    (%rcx),%rsp
 1005ea2:	77 05                	ja     1005ea9 <MHeap_AllocLocked+0x13>
 1005ea4:	e8 b5 ba ff ff       	callq  100195e <runtime.morestack24>
 1005ea9:	48 83 ec 48          	sub    $0x48,%rsp
 1005ead:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
	uintptr n;
	MSpan *s, *t;
	PageID p;

	// Try in fixed-size lists up to max.
	for(n=npage; n < nelem(h->free); n++) {
 1005eb2:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
 1005eb7:	48 81 fb 00 01 00 00 	cmp    $0x100,%rbx
 1005ebe:	0f 83 54 02 00 00    	jae    1006118 <MHeap_AllocLocked+0x282>
		if(!runtime·MSpanList_IsEmpty(&h->free[n])) {
 1005ec4:	48 c7 c2 48 00 00 00 	mov    $0x48,%rdx
 1005ecb:	48 0f af d3          	imul   %rbx,%rdx
 1005ecf:	48 89 5c 24 40       	mov    %rbx,0x40(%rsp)
 1005ed4:	48 89 eb             	mov    %rbp,%rbx
 1005ed7:	48 8d 0c 13          	lea    (%rbx,%rdx,1),%rcx
 1005edb:	48 83 c1 08          	add    $0x8,%rcx
 1005edf:	48 89 0c 24          	mov    %rcx,(%rsp)
 1005ee3:	e8 1f 0a 00 00       	callq  1006907 <runtime.MSpanList_IsEmpty>
 1005ee8:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
 1005eed:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
 1005ef2:	3c 00                	cmp    $0x0,%al
 1005ef4:	0f 85 0e 02 00 00    	jne    1006108 <MHeap_AllocLocked+0x272>
			s = h->free[n].next;
 1005efa:	48 c7 c1 48 00 00 00 	mov    $0x48,%rcx
 1005f01:	48 0f af cb          	imul   %rbx,%rcx
 1005f05:	48 89 ea             	mov    %rbp,%rdx
 1005f08:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1005f0c:	48 8b 48 08          	mov    0x8(%rax),%rcx
			return nil;
	}

HaveSpan:
	// Mark span in use.
	if(s->state != MSpanFree)
 1005f10:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
 1005f15:	8b 41 38             	mov    0x38(%rcx),%eax
 1005f18:	83 f8 01             	cmp    $0x1,%eax
 1005f1b:	74 13                	je     1005f30 <MHeap_AllocLocked+0x9a>
		runtime·throw("MHeap_AllocLocked - MSpan not free");
 1005f1d:	b8 a0 34 02 01       	mov    $0x10234a0,%eax
 1005f22:	48 89 04 24          	mov    %rax,(%rsp)
 1005f26:	e8 0e 3e 00 00       	callq  1009d39 <runtime.throw>
 1005f2b:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
	if(s->npages < npage)
 1005f30:	48 8b 41 20          	mov    0x20(%rcx),%rax
 1005f34:	48 3b 44 24 58       	cmp    0x58(%rsp),%rax
 1005f39:	73 13                	jae    1005f4e <MHeap_AllocLocked+0xb8>
		runtime·throw("MHeap_AllocLocked - bad npages");
 1005f3b:	b8 c3 34 02 01       	mov    $0x10234c3,%eax
 1005f40:	48 89 04 24          	mov    %rax,(%rsp)
 1005f44:	e8 f0 3d 00 00       	callq  1009d39 <runtime.throw>
 1005f49:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
	runtime·MSpanList_Remove(s);
 1005f4e:	48 89 0c 24          	mov    %rcx,(%rsp)
 1005f52:	e8 5f 09 00 00       	callq  10068b6 <runtime.MSpanList_Remove>
 1005f57:	4c 8b 44 24 58       	mov    0x58(%rsp),%r8
 1005f5c:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
 1005f61:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
	s->state = MSpanInUse;
 1005f66:	c7 45 38 00 00 00 00 	movl   $0x0,0x38(%rbp)

	if(s->npages > npage) {
 1005f6d:	48 8b 45 20          	mov    0x20(%rbp),%rax
 1005f71:	4c 39 c0             	cmp    %r8,%rax
 1005f74:	0f 86 0b 01 00 00    	jbe    1006085 <MHeap_AllocLocked+0x1ef>
		// Trim extra and put it back in the heap.
		t = runtime·FixAlloc_Alloc(&h->spanalloc);
 1005f7a:	48 89 f9             	mov    %rdi,%rcx
 1005f7d:	48 81 c1 88 70 00 02 	add    $0x2007088,%rcx
 1005f84:	48 89 0c 24          	mov    %rcx,(%rsp)
 1005f88:	e8 fe e1 ff ff       	callq  100418b <runtime.FixAlloc_Alloc>
 1005f8d:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 1005f92:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
 1005f97:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 1005f9c:	48 89 c1             	mov    %rax,%rcx
		mstats.mspan_inuse = h->spanalloc.inuse;
 1005f9f:	48 89 d8             	mov    %rbx,%rax
 1005fa2:	48 05 c0 70 00 02    	add    $0x20070c0,%rax
 1005fa8:	48 8b 00             	mov    (%rax),%rax
 1005fab:	48 89 04 25 c0 62 02 	mov    %rax,0x10262c0
 1005fb2:	01 
		mstats.mspan_sys = h->spanalloc.sys;
 1005fb3:	48 89 d8             	mov    %rbx,%rax
 1005fb6:	48 05 c8 70 00 02    	add    $0x20070c8,%rax
 1005fbc:	48 8b 00             	mov    (%rax),%rax
 1005fbf:	48 89 04 25 c8 62 02 	mov    %rax,0x10262c8
 1005fc6:	01 
		runtime·MSpan_Init(t, s->start + npage, s->npages - npage);
 1005fc7:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
 1005fcc:	48 89 0c 24          	mov    %rcx,(%rsp)
 1005fd0:	48 8b 42 18          	mov    0x18(%rdx),%rax
 1005fd4:	48 01 e8             	add    %rbp,%rax
 1005fd7:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1005fdc:	48 8b 42 20          	mov    0x20(%rdx),%rax
 1005fe0:	48 29 e8             	sub    %rbp,%rax
 1005fe3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1005fe8:	e8 4b 08 00 00       	callq  1006838 <runtime.MSpan_Init>
 1005fed:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
 1005ff2:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
 1005ff7:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
		s->npages = npage;
 1005ffc:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 1006001:	48 89 4f 20          	mov    %rcx,0x20(%rdi)
		p = t->start;
 1006005:	48 8b 5d 18          	mov    0x18(%rbp),%rbx
		if(sizeof(void*) == 8)
			p -= ((uintptr)h->arena_start>>PageShift);
 1006009:	48 89 f0             	mov    %rsi,%rax
 100600c:	48 05 68 48 00 02    	add    $0x2004868,%rax
 1006012:	48 8b 00             	mov    (%rax),%rax
 1006015:	48 c1 e8 0c          	shr    $0xc,%rax
 1006019:	48 29 c3             	sub    %rax,%rbx
		if(p > 0)
 100601c:	48 83 fb 00          	cmp    $0x0,%rbx
 1006020:	76 0b                	jbe    100602d <MHeap_AllocLocked+0x197>
			h->map[p-1] = s;
 1006022:	48 8d 04 de          	lea    (%rsi,%rbx,8),%rax
 1006026:	48 89 b8 50 48 00 00 	mov    %rdi,0x4850(%rax)
		h->map[p] = t;
 100602d:	48 8d 04 de          	lea    (%rsi,%rbx,8),%rax
 1006031:	48 89 a8 58 48 00 00 	mov    %rbp,0x4858(%rax)
		h->map[p+t->npages-1] = t;
 1006038:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
 100603c:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
 1006040:	48 8d 04 c6          	lea    (%rsi,%rax,8),%rax
 1006044:	48 89 a8 50 48 00 00 	mov    %rbp,0x4850(%rax)
		*(uintptr*)(t->start<<PageShift) = *(uintptr*)(s->start<<PageShift);  // copy "needs zeroing" mark
 100604b:	48 8b 45 18          	mov    0x18(%rbp),%rax
 100604f:	48 c1 e0 0c          	shl    $0xc,%rax
 1006053:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
 1006057:	48 c1 e1 0c          	shl    $0xc,%rcx
 100605b:	48 8b 09             	mov    (%rcx),%rcx
 100605e:	48 89 08             	mov    %rcx,(%rax)
		t->state = MSpanInUse;
 1006061:	c7 45 38 00 00 00 00 	movl   $0x0,0x38(%rbp)
		MHeap_FreeLocked(h, t);
 1006068:	48 89 34 24          	mov    %rsi,(%rsp)
 100606c:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
 1006071:	e8 19 05 00 00       	callq  100658f <MHeap_FreeLocked>
 1006076:	4c 8b 44 24 58       	mov    0x58(%rsp),%r8
 100607b:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
 1006080:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
	}

	if(*(uintptr*)(s->start<<PageShift) != 0)
 1006085:	48 8b 45 18          	mov    0x18(%rbp),%rax
 1006089:	48 c1 e0 0c          	shl    $0xc,%rax
 100608d:	48 8b 00             	mov    (%rax),%rax
 1006090:	48 83 f8 00          	cmp    $0x0,%rax
 1006094:	74 2d                	je     10060c3 <MHeap_AllocLocked+0x22d>
		runtime·memclr((byte*)(s->start<<PageShift), s->npages<<PageShift);
 1006096:	48 8b 45 18          	mov    0x18(%rbp),%rax
 100609a:	48 c1 e0 0c          	shl    $0xc,%rax
 100609e:	48 89 04 24          	mov    %rax,(%rsp)
 10060a2:	48 8b 45 20          	mov    0x20(%rbp),%rax
 10060a6:	48 c1 e0 0c          	shl    $0xc,%rax
 10060aa:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10060af:	e8 f3 b9 ff ff       	callq  1001aa7 <runtime.memclr>
 10060b4:	4c 8b 44 24 58       	mov    0x58(%rsp),%r8
 10060b9:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
 10060be:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp

	// Record span info, because gc needs to be
	// able to map interior pointer to containing span.
	s->sizeclass = sizeclass;
 10060c3:	8b 4c 24 60          	mov    0x60(%rsp),%ecx
 10060c7:	89 4d 34             	mov    %ecx,0x34(%rbp)
	p = s->start;
 10060ca:	48 8b 75 18          	mov    0x18(%rbp),%rsi
	if(sizeof(void*) == 8)
		p -= ((uintptr)h->arena_start>>PageShift);
 10060ce:	48 89 f8             	mov    %rdi,%rax
 10060d1:	48 05 68 48 00 02    	add    $0x2004868,%rax
 10060d7:	48 8b 00             	mov    (%rax),%rax
 10060da:	48 c1 e8 0c          	shr    $0xc,%rax
 10060de:	48 29 c6             	sub    %rax,%rsi
	for(n=0; n<npage; n++)
 10060e1:	48 31 db             	xor    %rbx,%rbx
 10060e4:	4c 39 c3             	cmp    %r8,%rbx
 10060e7:	73 17                	jae    1006100 <MHeap_AllocLocked+0x26a>
		h->map[p+n] = s;
 10060e9:	48 8d 04 1e          	lea    (%rsi,%rbx,1),%rax
 10060ed:	48 8d 04 c7          	lea    (%rdi,%rax,8),%rax
 10060f1:	48 89 a8 58 48 00 00 	mov    %rbp,0x4858(%rax)
	// able to map interior pointer to containing span.
	s->sizeclass = sizeclass;
	p = s->start;
	if(sizeof(void*) == 8)
		p -= ((uintptr)h->arena_start>>PageShift);
	for(n=0; n<npage; n++)
 10060f8:	48 ff c3             	inc    %rbx
 10060fb:	4c 39 c3             	cmp    %r8,%rbx
 10060fe:	72 e9                	jb     10060e9 <MHeap_AllocLocked+0x253>
		h->map[p+n] = s;
	return s;
 1006100:	48 89 e8             	mov    %rbp,%rax
 1006103:	48 83 c4 48          	add    $0x48,%rsp
 1006107:	c3                   	retq   
	uintptr n;
	MSpan *s, *t;
	PageID p;

	// Try in fixed-size lists up to max.
	for(n=npage; n < nelem(h->free); n++) {
 1006108:	48 ff c3             	inc    %rbx
 100610b:	48 81 fb 00 01 00 00 	cmp    $0x100,%rbx
 1006112:	0f 82 ac fd ff ff    	jb     1005ec4 <MHeap_AllocLocked+0x2e>
			goto HaveSpan;
		}
	}

	// Best fit in list of large spans.
	if((s = MHeap_AllocLarge(h, npage)) == nil) {
 1006118:	48 89 2c 24          	mov    %rbp,(%rsp)
 100611c:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 1006121:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1006126:	e8 5e 00 00 00       	callq  1006189 <MHeap_AllocLarge>
 100612b:	48 89 c1             	mov    %rax,%rcx
 100612e:	48 83 f8 00          	cmp    $0x0,%rax
 1006132:	0f 85 d8 fd ff ff    	jne    1005f10 <MHeap_AllocLocked+0x7a>
		if(!MHeap_Grow(h, npage))
 1006138:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 100613d:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006141:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 1006146:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100614b:	e8 f9 00 00 00       	callq  1006249 <MHeap_Grow>
 1006150:	3c 00                	cmp    $0x0,%al
 1006152:	75 08                	jne    100615c <MHeap_AllocLocked+0x2c6>
			return nil;
 1006154:	48 31 c0             	xor    %rax,%rax
 1006157:	48 83 c4 48          	add    $0x48,%rsp
 100615b:	c3                   	retq   
		if((s = MHeap_AllocLarge(h, npage)) == nil)
 100615c:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 1006161:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006165:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 100616a:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100616f:	e8 15 00 00 00       	callq  1006189 <MHeap_AllocLarge>
 1006174:	48 89 c1             	mov    %rax,%rcx
 1006177:	48 83 f8 00          	cmp    $0x0,%rax
 100617b:	0f 85 8f fd ff ff    	jne    1005f10 <MHeap_AllocLocked+0x7a>
			return nil;
 1006181:	48 31 c0             	xor    %rax,%rax
 1006184:	48 83 c4 48          	add    $0x48,%rsp
 1006188:	c3                   	retq   

0000000001006189 <MHeap_AllocLarge>:
	return s;
}

// Allocate a span of exactly npage pages from the list of large spans.
static MSpan*
MHeap_AllocLarge(MHeap *h, uintptr npage)
 1006189:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006190:	ff ff 
 1006192:	48 3b 21             	cmp    (%rcx),%rsp
 1006195:	77 05                	ja     100619c <MHeap_AllocLarge+0x13>
 1006197:	e8 b9 b7 ff ff       	callq  1001955 <runtime.morestack16>
 100619c:	48 83 ec 20          	sub    $0x20,%rsp
{
	return BestFit(&h->large, npage, nil);
 10061a0:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 10061a5:	48 81 c1 08 48 00 00 	add    $0x4808,%rcx
 10061ac:	48 89 0c 24          	mov    %rcx,(%rsp)
 10061b0:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 10061b5:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10061ba:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 10061c1:	00 00 
 10061c3:	e8 05 00 00 00       	callq  10061cd <BestFit>
 10061c8:	48 83 c4 20          	add    $0x20,%rsp
 10061cc:	c3                   	retq   

00000000010061cd <BestFit>:

// Search list for smallest span with >= npage pages.
// If there are multiple smallest spans, take the one
// with the earliest starting address.
static MSpan*
BestFit(MSpan *list, uintptr npage, MSpan *best)
 10061cd:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10061d4:	ff ff 
 10061d6:	48 3b 21             	cmp    (%rcx),%rsp
 10061d9:	77 05                	ja     10061e0 <BestFit+0x13>
 10061db:	e8 7e b7 ff ff       	callq  100195e <runtime.morestack24>
 10061e0:	48 83 ec 10          	sub    $0x10,%rsp
 10061e4:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
 10061e9:	48 8b 6c 24 18       	mov    0x18(%rsp),%rbp
 10061ee:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
{
	MSpan *s;

	for(s=list->next; s != list; s=s->next) {
 10061f3:	48 8b 55 00          	mov    0x0(%rbp),%rdx
 10061f7:	48 39 ea             	cmp    %rbp,%rdx
 10061fa:	74 11                	je     100620d <BestFit+0x40>
		if(s->npages < npage)
 10061fc:	48 8b 42 20          	mov    0x20(%rdx),%rax
 1006200:	48 39 f0             	cmp    %rsi,%rax
 1006203:	73 10                	jae    1006215 <BestFit+0x48>
static MSpan*
BestFit(MSpan *list, uintptr npage, MSpan *best)
{
	MSpan *s;

	for(s=list->next; s != list; s=s->next) {
 1006205:	48 8b 12             	mov    (%rdx),%rdx
 1006208:	48 39 ea             	cmp    %rbp,%rdx
 100620b:	75 ef                	jne    10061fc <BestFit+0x2f>
		if(best == nil
		|| s->npages < best->npages
		|| (s->npages == best->npages && s->start < best->start))
			best = s;
	}
	return best;
 100620d:	48 89 d8             	mov    %rbx,%rax
 1006210:	48 83 c4 10          	add    $0x10,%rsp
 1006214:	c3                   	retq   
	MSpan *s;

	for(s=list->next; s != list; s=s->next) {
		if(s->npages < npage)
			continue;
		if(best == nil
 1006215:	48 83 fb 00          	cmp    $0x0,%rbx
 1006219:	74 0d                	je     1006228 <BestFit+0x5b>
 100621b:	48 8b 42 20          	mov    0x20(%rdx),%rax
 100621f:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
 1006223:	48 39 c8             	cmp    %rcx,%rax
 1006226:	73 05                	jae    100622d <BestFit+0x60>
		|| s->npages < best->npages
		|| (s->npages == best->npages && s->start < best->start))
			best = s;
 1006228:	48 89 d3             	mov    %rdx,%rbx
static MSpan*
BestFit(MSpan *list, uintptr npage, MSpan *best)
{
	MSpan *s;

	for(s=list->next; s != list; s=s->next) {
 100622b:	eb d8                	jmp    1006205 <BestFit+0x38>
		if(s->npages < npage)
			continue;
		if(best == nil
 100622d:	48 8b 42 20          	mov    0x20(%rdx),%rax
 1006231:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
 1006235:	48 39 c8             	cmp    %rcx,%rax
 1006238:	75 cb                	jne    1006205 <BestFit+0x38>
 100623a:	48 8b 42 18          	mov    0x18(%rdx),%rax
 100623e:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
 1006242:	48 39 c8             	cmp    %rcx,%rax
 1006245:	72 e1                	jb     1006228 <BestFit+0x5b>
static MSpan*
BestFit(MSpan *list, uintptr npage, MSpan *best)
{
	MSpan *s;

	for(s=list->next; s != list; s=s->next) {
 1006247:	eb bc                	jmp    1006205 <BestFit+0x38>

0000000001006249 <MHeap_Grow>:
}

// Try to add at least npage pages of memory to the heap,
// returning whether it worked.
static bool
MHeap_Grow(MHeap *h, uintptr npage)
 1006249:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006250:	ff ff 
 1006252:	48 3b 21             	cmp    (%rcx),%rsp
 1006255:	77 05                	ja     100625c <MHeap_Grow+0x13>
 1006257:	e8 f9 b6 ff ff       	callq  1001955 <runtime.morestack16>
 100625c:	48 83 ec 48          	sub    $0x48,%rsp

	// Ask for a big chunk, to reduce the number of mappings
	// the operating system needs to track; also amortizes
	// the overhead of an operating system mapping.
	// Allocate a multiple of 64kB (16 pages).
	npage = (npage+15)&~15;
 1006260:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 1006265:	48 83 c0 0f          	add    $0xf,%rax
 1006269:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
	ask = npage<<PageShift;
 100626d:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
 1006272:	48 c1 e0 0c          	shl    $0xc,%rax
 1006276:	48 89 c2             	mov    %rax,%rdx
	if(ask < HeapAllocChunk)
 1006279:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
 100627f:	73 07                	jae    1006288 <MHeap_Grow+0x3f>
		ask = HeapAllocChunk;
 1006281:	48 c7 c2 00 00 10 00 	mov    $0x100000,%rdx

	v = runtime·MHeap_SysAlloc(h, ask);
 1006288:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 100628d:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006291:	48 89 54 24 40       	mov    %rdx,0x40(%rsp)
 1006296:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 100629b:	e8 fe cd ff ff       	callq  100309e <runtime.MHeap_SysAlloc>
 10062a0:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
 10062a5:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
 10062aa:	48 89 c1             	mov    %rax,%rcx
	if(v == nil) {
 10062ad:	48 83 f8 00          	cmp    $0x0,%rax
 10062b1:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
 10062b6:	75 65                	jne    100631d <MHeap_Grow+0xd4>
		if(ask > (npage<<PageShift)) {
 10062b8:	48 89 d8             	mov    %rbx,%rax
 10062bb:	48 c1 e0 0c          	shl    $0xc,%rax
 10062bf:	48 39 c2             	cmp    %rax,%rdx
 10062c2:	76 27                	jbe    10062eb <MHeap_Grow+0xa2>
			ask = npage<<PageShift;
 10062c4:	48 89 d8             	mov    %rbx,%rax
 10062c7:	48 c1 e0 0c          	shl    $0xc,%rax
			v = runtime·MHeap_SysAlloc(h, ask);
 10062cb:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 10062d0:	48 89 0c 24          	mov    %rcx,(%rsp)
 10062d4:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
 10062d9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10062de:	e8 bb cd ff ff       	callq  100309e <runtime.MHeap_SysAlloc>
 10062e3:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
 10062e8:	48 89 c1             	mov    %rax,%rcx
		}
		if(v == nil) {
 10062eb:	48 83 f9 00          	cmp    $0x0,%rcx
 10062ef:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
 10062f4:	75 27                	jne    100631d <MHeap_Grow+0xd4>
			runtime·printf("runtime: out of memory: cannot allocate %D-byte block (%D in use)\n", (uint64)ask, mstats.heap_sys);
 10062f6:	b8 e2 34 02 01       	mov    $0x10234e2,%eax
 10062fb:	48 89 04 24          	mov    %rax,(%rsp)
 10062ff:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 1006304:	48 8b 04 25 90 62 02 	mov    0x1026290,%rax
 100630b:	01 
 100630c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1006311:	e8 28 10 00 00       	callq  100733e <runtime.printf>
			return false;
 1006316:	31 c0                	xor    %eax,%eax
 1006318:	48 83 c4 48          	add    $0x48,%rsp
 100631c:	c3                   	retq   
		}
	}
	mstats.heap_sys += ask;
 100631d:	48 01 14 25 90 62 02 	add    %rdx,0x1026290
 1006324:	01 

	// Create a fake "in use" span and free it, so that the
	// right coalescing happens.
	s = runtime·FixAlloc_Alloc(&h->spanalloc);
 1006325:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 100632a:	48 81 c1 88 70 00 02 	add    $0x2007088,%rcx
 1006331:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006335:	e8 51 de ff ff       	callq  100418b <runtime.FixAlloc_Alloc>
 100633a:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
 100633f:	48 89 c1             	mov    %rax,%rcx
	mstats.mspan_inuse = h->spanalloc.inuse;
 1006342:	48 89 d0             	mov    %rdx,%rax
 1006345:	48 05 c0 70 00 02    	add    $0x20070c0,%rax
 100634b:	48 8b 00             	mov    (%rax),%rax
 100634e:	48 89 04 25 c0 62 02 	mov    %rax,0x10262c0
 1006355:	01 
	mstats.mspan_sys = h->spanalloc.sys;
 1006356:	48 89 d0             	mov    %rdx,%rax
 1006359:	48 05 c8 70 00 02    	add    $0x20070c8,%rax
 100635f:	48 8b 00             	mov    (%rax),%rax
 1006362:	48 89 04 25 c8 62 02 	mov    %rax,0x10262c8
 1006369:	01 
	runtime·MSpan_Init(s, (uintptr)v>>PageShift, ask>>PageShift);
 100636a:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
 100636f:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006373:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 1006378:	48 c1 e8 0c          	shr    $0xc,%rax
 100637c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1006381:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 1006386:	48 c1 e8 0c          	shr    $0xc,%rax
 100638a:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100638f:	e8 a4 04 00 00       	callq  1006838 <runtime.MSpan_Init>
 1006394:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
 1006399:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
	p = s->start;
 100639e:	48 8b 6b 18          	mov    0x18(%rbx),%rbp
	if(sizeof(void*) == 8)
		p -= ((uintptr)h->arena_start>>PageShift);
 10063a2:	48 89 f0             	mov    %rsi,%rax
 10063a5:	48 05 68 48 00 02    	add    $0x2004868,%rax
 10063ab:	48 8b 00             	mov    (%rax),%rax
 10063ae:	48 c1 e8 0c          	shr    $0xc,%rax
 10063b2:	48 29 c5             	sub    %rax,%rbp
	h->map[p] = s;
 10063b5:	48 8d 04 ee          	lea    (%rsi,%rbp,8),%rax
 10063b9:	48 89 98 58 48 00 00 	mov    %rbx,0x4858(%rax)
	h->map[p + s->npages - 1] = s;
 10063c0:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
 10063c4:	48 89 ea             	mov    %rbp,%rdx
 10063c7:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 10063cb:	48 8d 04 c6          	lea    (%rsi,%rax,8),%rax
 10063cf:	48 89 98 50 48 00 00 	mov    %rbx,0x4850(%rax)
	s->state = MSpanInUse;
 10063d6:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%rbx)
	MHeap_FreeLocked(h, s);
 10063dd:	48 89 34 24          	mov    %rsi,(%rsp)
 10063e1:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 10063e6:	e8 a4 01 00 00       	callq  100658f <MHeap_FreeLocked>
	return true;
 10063eb:	b8 01 00 00 00       	mov    $0x1,%eax
 10063f0:	48 83 c4 48          	add    $0x48,%rsp
 10063f4:	c3                   	retq   

00000000010063f5 <runtime.MHeap_Lookup>:

// Look up the span at the given address.
// Address is guaranteed to be in map
// and is guaranteed to be start or end of span.
MSpan*
runtime·MHeap_Lookup(MHeap *h, void *v)
 10063f5:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10063fc:	ff ff 
 10063fe:	48 3b 21             	cmp    (%rcx),%rsp
 1006401:	77 05                	ja     1006408 <runtime.MHeap_Lookup+0x13>
 1006403:	e8 4d b5 ff ff       	callq  1001955 <runtime.morestack16>
 1006408:	48 83 ec 10          	sub    $0x10,%rsp
 100640c:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
{
	uintptr p;
	
	p = (uintptr)v;
 1006411:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
	if(sizeof(void*) == 8)
		p -= (uintptr)h->arena_start;
 1006416:	48 89 d8             	mov    %rbx,%rax
 1006419:	48 05 68 48 00 02    	add    $0x2004868,%rax
 100641f:	48 8b 00             	mov    (%rax),%rax
 1006422:	48 29 c1             	sub    %rax,%rcx
	return h->map[p >> PageShift];
 1006425:	48 c1 e9 0c          	shr    $0xc,%rcx
 1006429:	48 8d 04 cb          	lea    (%rbx,%rcx,8),%rax
 100642d:	48 8b 80 58 48 00 00 	mov    0x4858(%rax),%rax
 1006434:	48 83 c4 10          	add    $0x10,%rsp
 1006438:	c3                   	retq   

0000000001006439 <runtime.MHeap_LookupMaybe>:
// Map entries for the middle of a span are only
// valid for allocated spans.  Free spans may have
// other garbage in their middles, so we have to
// check for that.
MSpan*
runtime·MHeap_LookupMaybe(MHeap *h, void *v)
 1006439:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006440:	ff ff 
 1006442:	48 3b 21             	cmp    (%rcx),%rsp
 1006445:	77 05                	ja     100644c <runtime.MHeap_LookupMaybe+0x13>
 1006447:	e8 09 b5 ff ff       	callq  1001955 <runtime.morestack16>
 100644c:	48 83 ec 20          	sub    $0x20,%rsp
 1006450:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1006455:	48 8b 6c 24 28       	mov    0x28(%rsp),%rbp
{
	MSpan *s;
	PageID p, q;

	if((byte*)v < h->arena_start || (byte*)v >= h->arena_used)
 100645a:	48 89 e8             	mov    %rbp,%rax
 100645d:	48 05 68 48 00 02    	add    $0x2004868,%rax
 1006463:	48 8b 00             	mov    (%rax),%rax
 1006466:	48 39 c1             	cmp    %rax,%rcx
 1006469:	0f 82 87 00 00 00    	jb     10064f6 <runtime.MHeap_LookupMaybe+0xbd>
 100646f:	48 89 e8             	mov    %rbp,%rax
 1006472:	48 05 70 48 00 02    	add    $0x2004870,%rax
 1006478:	48 8b 00             	mov    (%rax),%rax
 100647b:	48 39 c1             	cmp    %rax,%rcx
 100647e:	73 76                	jae    10064f6 <runtime.MHeap_LookupMaybe+0xbd>
		return nil;
	p = (uintptr)v>>PageShift;
 1006480:	48 89 c8             	mov    %rcx,%rax
 1006483:	48 c1 e8 0c          	shr    $0xc,%rax
 1006487:	48 89 c3             	mov    %rax,%rbx
	q = p;
 100648a:	48 89 c2             	mov    %rax,%rdx
	if(sizeof(void*) == 8)
		q -= (uintptr)h->arena_start >> PageShift;
 100648d:	48 89 e8             	mov    %rbp,%rax
 1006490:	48 05 68 48 00 02    	add    $0x2004868,%rax
 1006496:	48 8b 00             	mov    (%rax),%rax
 1006499:	48 c1 e8 0c          	shr    $0xc,%rax
 100649d:	48 29 c2             	sub    %rax,%rdx
	s = h->map[q];
 10064a0:	48 89 d1             	mov    %rdx,%rcx
 10064a3:	48 89 ea             	mov    %rbp,%rdx
 10064a6:	48 8d 04 ca          	lea    (%rdx,%rcx,8),%rax
 10064aa:	48 8b 90 58 48 00 00 	mov    0x4858(%rax),%rdx
	if(s == nil || p < s->start || p - s->start >= s->npages)
 10064b1:	48 83 fa 00          	cmp    $0x0,%rdx
 10064b5:	74 09                	je     10064c0 <runtime.MHeap_LookupMaybe+0x87>
 10064b7:	48 8b 42 18          	mov    0x18(%rdx),%rax
 10064bb:	48 39 c3             	cmp    %rax,%rbx
 10064be:	73 08                	jae    10064c8 <runtime.MHeap_LookupMaybe+0x8f>
		return nil;
 10064c0:	48 31 c0             	xor    %rax,%rax
 10064c3:	48 83 c4 20          	add    $0x20,%rsp
 10064c7:	c3                   	retq   
	p = (uintptr)v>>PageShift;
	q = p;
	if(sizeof(void*) == 8)
		q -= (uintptr)h->arena_start >> PageShift;
	s = h->map[q];
	if(s == nil || p < s->start || p - s->start >= s->npages)
 10064c8:	48 8b 42 18          	mov    0x18(%rdx),%rax
 10064cc:	48 89 d9             	mov    %rbx,%rcx
 10064cf:	48 29 c1             	sub    %rax,%rcx
 10064d2:	48 89 c8             	mov    %rcx,%rax
 10064d5:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 10064d9:	48 39 c8             	cmp    %rcx,%rax
 10064dc:	73 e2                	jae    10064c0 <runtime.MHeap_LookupMaybe+0x87>
		return nil;
	if(s->state != MSpanInUse)
 10064de:	8b 42 38             	mov    0x38(%rdx),%eax
 10064e1:	83 f8 00             	cmp    $0x0,%eax
 10064e4:	74 08                	je     10064ee <runtime.MHeap_LookupMaybe+0xb5>
		return nil;
 10064e6:	48 31 c0             	xor    %rax,%rax
 10064e9:	48 83 c4 20          	add    $0x20,%rsp
 10064ed:	c3                   	retq   
	return s;
 10064ee:	48 89 d0             	mov    %rdx,%rax
 10064f1:	48 83 c4 20          	add    $0x20,%rsp
 10064f5:	c3                   	retq   
{
	MSpan *s;
	PageID p, q;

	if((byte*)v < h->arena_start || (byte*)v >= h->arena_used)
		return nil;
 10064f6:	48 31 c0             	xor    %rax,%rax
 10064f9:	48 83 c4 20          	add    $0x20,%rsp
 10064fd:	c3                   	retq   

00000000010064fe <runtime.MHeap_Free>:
	return s;
}

// Free the span back into the heap.
void
runtime·MHeap_Free(MHeap *h, MSpan *s, int32 acct)
 10064fe:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006505:	ff ff 
 1006507:	48 3b 21             	cmp    (%rcx),%rsp
 100650a:	77 05                	ja     1006511 <runtime.MHeap_Free+0x13>
 100650c:	e8 4d b4 ff ff       	callq  100195e <runtime.morestack24>
 1006511:	48 83 ec 18          	sub    $0x18,%rsp
{
	runtime·lock(h);
 1006515:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100651a:	48 89 04 24          	mov    %rax,(%rsp)
 100651e:	e8 0d 69 00 00       	callq  100ce30 <runtime.lock>
	runtime·purgecachedstats(m);
 1006523:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100652a:	ff ff 
 100652c:	48 89 04 24          	mov    %rax,(%rsp)
 1006530:	e8 59 c9 ff ff       	callq  1002e8e <runtime.purgecachedstats>
 1006535:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
	mstats.heap_inuse -= s->npages<<PageShift;
 100653a:	48 8b 41 20          	mov    0x20(%rcx),%rax
 100653e:	48 c1 e0 0c          	shl    $0xc,%rax
 1006542:	48 29 04 25 a0 62 02 	sub    %rax,0x10262a0
 1006549:	01 
	if(acct) {
 100654a:	83 7c 24 30 00       	cmpl   $0x0,0x30(%rsp)
 100654f:	74 18                	je     1006569 <runtime.MHeap_Free+0x6b>
		mstats.heap_alloc -= s->npages<<PageShift;
 1006551:	48 8b 41 20          	mov    0x20(%rcx),%rax
 1006555:	48 c1 e0 0c          	shl    $0xc,%rax
 1006559:	48 29 04 25 88 62 02 	sub    %rax,0x1026288
 1006560:	01 
		mstats.heap_objects--;
 1006561:	48 ff 0c 25 a8 62 02 	decq   0x10262a8
 1006568:	01 
	}
	MHeap_FreeLocked(h, s);
 1006569:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100656e:	48 89 04 24          	mov    %rax,(%rsp)
 1006572:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1006577:	e8 13 00 00 00       	callq  100658f <MHeap_FreeLocked>
	runtime·unlock(h);
 100657c:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1006581:	48 89 04 24          	mov    %rax,(%rsp)
 1006585:	e8 f8 68 00 00       	callq  100ce82 <runtime.unlock>
 100658a:	48 83 c4 18          	add    $0x18,%rsp
 100658e:	c3                   	retq   

000000000100658f <MHeap_FreeLocked>:
}

static void
MHeap_FreeLocked(MHeap *h, MSpan *s)
 100658f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006596:	ff ff 
 1006598:	48 3b 21             	cmp    (%rcx),%rsp
 100659b:	77 05                	ja     10065a2 <MHeap_FreeLocked+0x13>
 100659d:	e8 b3 b3 ff ff       	callq  1001955 <runtime.morestack16>
 10065a2:	48 83 ec 50          	sub    $0x50,%rsp
 10065a6:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
{
	uintptr *sp, *tp;
	MSpan *t;
	PageID p;

	if(s->state != MSpanInUse || s->ref != 0) {
 10065ab:	8b 41 38             	mov    0x38(%rcx),%eax
 10065ae:	83 f8 00             	cmp    $0x0,%eax
 10065b1:	0f 85 3b 02 00 00    	jne    10067f2 <MHeap_FreeLocked+0x263>
 10065b7:	8b 41 30             	mov    0x30(%rcx),%eax
 10065ba:	83 f8 00             	cmp    $0x0,%eax
 10065bd:	0f 85 2f 02 00 00    	jne    10067f2 <MHeap_FreeLocked+0x263>
		runtime·printf("MHeap_FreeLocked - span %p ptr %p state %d ref %d\n", s, s->start<<PageShift, s->state, s->ref);
		runtime·throw("MHeap_FreeLocked - invalid free");
	}
	s->state = MSpanFree;
 10065c3:	c7 41 38 01 00 00 00 	movl   $0x1,0x38(%rcx)
	runtime·MSpanList_Remove(s);
 10065ca:	48 89 0c 24          	mov    %rcx,(%rsp)
 10065ce:	e8 e3 02 00 00       	callq  10068b6 <runtime.MSpanList_Remove>
 10065d3:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 10065d8:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
	sp = (uintptr*)(s->start<<PageShift);
 10065dd:	48 8b 43 18          	mov    0x18(%rbx),%rax
 10065e1:	48 c1 e0 0c          	shl    $0xc,%rax
 10065e5:	49 89 c0             	mov    %rax,%r8

	// Coalesce with earlier, later spans.
	p = s->start;
 10065e8:	48 8b 73 18          	mov    0x18(%rbx),%rsi
	if(sizeof(void*) == 8)
		p -= (uintptr)h->arena_start >> PageShift;
 10065ec:	48 89 e8             	mov    %rbp,%rax
 10065ef:	48 05 68 48 00 02    	add    $0x2004868,%rax
 10065f5:	48 8b 00             	mov    (%rax),%rax
 10065f8:	48 c1 e8 0c          	shr    $0xc,%rax
 10065fc:	48 29 c6             	sub    %rax,%rsi
	if(p > 0 && (t = h->map[p-1]) != nil && t->state != MSpanInUse) {
 10065ff:	48 83 fe 00          	cmp    $0x0,%rsi
 1006603:	76 18                	jbe    100661d <MHeap_FreeLocked+0x8e>
 1006605:	48 89 ea             	mov    %rbp,%rdx
 1006608:	48 8d 04 f2          	lea    (%rdx,%rsi,8),%rax
 100660c:	48 8b b8 50 48 00 00 	mov    0x4850(%rax),%rdi
 1006613:	48 83 ff 00          	cmp    $0x0,%rdi
 1006617:	0f 85 18 01 00 00    	jne    1006735 <MHeap_FreeLocked+0x1a6>
		t->state = MSpanDead;
		runtime·FixAlloc_Free(&h->spanalloc, t);
		mstats.mspan_inuse = h->spanalloc.inuse;
		mstats.mspan_sys = h->spanalloc.sys;
	}
	if(p+s->npages < nelem(h->map) && (t = h->map[p+s->npages]) != nil && t->state != MSpanInUse) {
 100661d:	48 8b 43 20          	mov    0x20(%rbx),%rax
 1006621:	48 89 f1             	mov    %rsi,%rcx
 1006624:	48 01 c1             	add    %rax,%rcx
 1006627:	48 81 f9 00 00 40 00 	cmp    $0x400000,%rcx
 100662e:	73 1c                	jae    100664c <MHeap_FreeLocked+0xbd>
 1006630:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
 1006634:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
 1006638:	48 89 ea             	mov    %rbp,%rdx
 100663b:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
 100663f:	48 8b b8 58 48 00 00 	mov    0x4858(%rax),%rdi
 1006646:	48 83 ff 00          	cmp    $0x0,%rdi
 100664a:	75 4b                	jne    1006697 <MHeap_FreeLocked+0x108>
		mstats.mspan_inuse = h->spanalloc.inuse;
		mstats.mspan_sys = h->spanalloc.sys;
	}

	// Insert s into appropriate list.
	if(s->npages < nelem(h->free))
 100664c:	48 8b 43 20          	mov    0x20(%rbx),%rax
 1006650:	48 3d 00 01 00 00    	cmp    $0x100,%rax
 1006656:	73 26                	jae    100667e <MHeap_FreeLocked+0xef>
		runtime·MSpanList_Insert(&h->free[s->npages], s);
 1006658:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
 100665c:	48 6b c9 48          	imul   $0x48,%rcx,%rcx
 1006660:	48 89 ea             	mov    %rbp,%rdx
 1006663:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1006667:	48 83 c0 08          	add    $0x8,%rax
 100666b:	48 89 04 24          	mov    %rax,(%rsp)
 100666f:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 1006674:	e8 b8 02 00 00       	callq  1006931 <runtime.MSpanList_Insert>
	else
		runtime·MSpanList_Insert(&h->large, s);
 1006679:	48 83 c4 50          	add    $0x50,%rsp
 100667d:	c3                   	retq   
 100667e:	48 89 e8             	mov    %rbp,%rax
 1006681:	48 05 08 48 00 00    	add    $0x4808,%rax
 1006687:	48 89 04 24          	mov    %rax,(%rsp)
 100668b:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 1006690:	e8 9c 02 00 00       	callq  1006931 <runtime.MSpanList_Insert>
 1006695:	eb e2                	jmp    1006679 <MHeap_FreeLocked+0xea>
		t->state = MSpanDead;
		runtime·FixAlloc_Free(&h->spanalloc, t);
		mstats.mspan_inuse = h->spanalloc.inuse;
		mstats.mspan_sys = h->spanalloc.sys;
	}
	if(p+s->npages < nelem(h->map) && (t = h->map[p+s->npages]) != nil && t->state != MSpanInUse) {
 1006697:	8b 47 38             	mov    0x38(%rdi),%eax
 100669a:	83 f8 00             	cmp    $0x0,%eax
 100669d:	74 ad                	je     100664c <MHeap_FreeLocked+0xbd>
		tp = (uintptr*)(t->start<<PageShift);
 100669f:	48 8b 47 18          	mov    0x18(%rdi),%rax
 10066a3:	48 c1 e0 0c          	shl    $0xc,%rax
		*sp |= *tp;	// propagate "needs zeroing" mark
 10066a7:	48 8b 08             	mov    (%rax),%rcx
 10066aa:	49 09 08             	or     %rcx,(%r8)
		s->npages += t->npages;
 10066ad:	48 8b 4f 20          	mov    0x20(%rdi),%rcx
 10066b1:	48 01 4b 20          	add    %rcx,0x20(%rbx)
		h->map[p + s->npages - 1] = s;
 10066b5:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
 10066b9:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
 10066bd:	48 89 ea             	mov    %rbp,%rdx
 10066c0:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
 10066c4:	48 89 98 50 48 00 00 	mov    %rbx,0x4850(%rax)
		runtime·MSpanList_Remove(t);
 10066cb:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
 10066d0:	48 89 3c 24          	mov    %rdi,(%rsp)
 10066d4:	e8 dd 01 00 00       	callq  10068b6 <runtime.MSpanList_Remove>
 10066d9:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
		t->state = MSpanDead;
 10066de:	c7 41 38 03 00 00 00 	movl   $0x3,0x38(%rcx)
		runtime·FixAlloc_Free(&h->spanalloc, t);
 10066e5:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 10066ea:	48 05 88 70 00 02    	add    $0x2007088,%rax
 10066f0:	48 89 04 24          	mov    %rax,(%rsp)
 10066f4:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10066f9:	e8 6b db ff ff       	callq  1004269 <runtime.FixAlloc_Free>
 10066fe:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 1006703:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
		mstats.mspan_inuse = h->spanalloc.inuse;
 1006708:	48 89 c5             	mov    %rax,%rbp
 100670b:	48 05 c0 70 00 02    	add    $0x20070c0,%rax
 1006711:	48 8b 00             	mov    (%rax),%rax
 1006714:	48 89 04 25 c0 62 02 	mov    %rax,0x10262c0
 100671b:	01 
		mstats.mspan_sys = h->spanalloc.sys;
 100671c:	48 89 e8             	mov    %rbp,%rax
 100671f:	48 05 c8 70 00 02    	add    $0x20070c8,%rax
 1006725:	48 8b 00             	mov    (%rax),%rax
 1006728:	48 89 04 25 c8 62 02 	mov    %rax,0x10262c8
 100672f:	01 
	}

	// Insert s into appropriate list.
	if(s->npages < nelem(h->free))
 1006730:	e9 17 ff ff ff       	jmpq   100664c <MHeap_FreeLocked+0xbd>

	// Coalesce with earlier, later spans.
	p = s->start;
	if(sizeof(void*) == 8)
		p -= (uintptr)h->arena_start >> PageShift;
	if(p > 0 && (t = h->map[p-1]) != nil && t->state != MSpanInUse) {
 1006735:	8b 47 38             	mov    0x38(%rdi),%eax
 1006738:	83 f8 00             	cmp    $0x0,%eax
 100673b:	0f 84 dc fe ff ff    	je     100661d <MHeap_FreeLocked+0x8e>
		tp = (uintptr*)(t->start<<PageShift);
 1006741:	48 8b 47 18          	mov    0x18(%rdi),%rax
 1006745:	48 c1 e0 0c          	shl    $0xc,%rax
		*tp |= *sp;	// propagate "needs zeroing" mark
 1006749:	4c 89 44 24 48       	mov    %r8,0x48(%rsp)
 100674e:	49 8b 08             	mov    (%r8),%rcx
 1006751:	48 09 08             	or     %rcx,(%rax)
		s->start = t->start;
 1006754:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
 1006758:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
		s->npages += t->npages;
 100675c:	48 8b 4f 20          	mov    0x20(%rdi),%rcx
 1006760:	48 01 4b 20          	add    %rcx,0x20(%rbx)
		p -= t->npages;
 1006764:	48 8b 47 20          	mov    0x20(%rdi),%rax
 1006768:	48 29 c6             	sub    %rax,%rsi
		h->map[p] = s;
 100676b:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
 1006770:	48 89 ea             	mov    %rbp,%rdx
 1006773:	48 8d 04 f2          	lea    (%rdx,%rsi,8),%rax
 1006777:	48 89 98 58 48 00 00 	mov    %rbx,0x4858(%rax)
		runtime·MSpanList_Remove(t);
 100677e:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
 1006783:	48 89 3c 24          	mov    %rdi,(%rsp)
 1006787:	e8 2a 01 00 00       	callq  10068b6 <runtime.MSpanList_Remove>
 100678c:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
		t->state = MSpanDead;
 1006791:	c7 41 38 03 00 00 00 	movl   $0x3,0x38(%rcx)
		runtime·FixAlloc_Free(&h->spanalloc, t);
 1006798:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 100679d:	48 05 88 70 00 02    	add    $0x2007088,%rax
 10067a3:	48 89 04 24          	mov    %rax,(%rsp)
 10067a7:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10067ac:	e8 b8 da ff ff       	callq  1004269 <runtime.FixAlloc_Free>
 10067b1:	4c 8b 44 24 48       	mov    0x48(%rsp),%r8
 10067b6:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
 10067bb:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 10067c0:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
		mstats.mspan_inuse = h->spanalloc.inuse;
 10067c5:	48 89 c5             	mov    %rax,%rbp
 10067c8:	48 05 c0 70 00 02    	add    $0x20070c0,%rax
 10067ce:	48 8b 00             	mov    (%rax),%rax
 10067d1:	48 89 04 25 c0 62 02 	mov    %rax,0x10262c0
 10067d8:	01 
		mstats.mspan_sys = h->spanalloc.sys;
 10067d9:	48 89 e8             	mov    %rbp,%rax
 10067dc:	48 05 c8 70 00 02    	add    $0x20070c8,%rax
 10067e2:	48 8b 00             	mov    (%rax),%rax
 10067e5:	48 89 04 25 c8 62 02 	mov    %rax,0x10262c8
 10067ec:	01 
	}
	if(p+s->npages < nelem(h->map) && (t = h->map[p+s->npages]) != nil && t->state != MSpanInUse) {
 10067ed:	e9 2b fe ff ff       	jmpq   100661d <MHeap_FreeLocked+0x8e>
	uintptr *sp, *tp;
	MSpan *t;
	PageID p;

	if(s->state != MSpanInUse || s->ref != 0) {
		runtime·printf("MHeap_FreeLocked - span %p ptr %p state %d ref %d\n", s, s->start<<PageShift, s->state, s->ref);
 10067f2:	b8 25 35 02 01       	mov    $0x1023525,%eax
 10067f7:	48 89 04 24          	mov    %rax,(%rsp)
 10067fb:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1006800:	48 8b 41 18          	mov    0x18(%rcx),%rax
 1006804:	48 c1 e0 0c          	shl    $0xc,%rax
 1006808:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100680d:	8b 41 38             	mov    0x38(%rcx),%eax
 1006810:	89 44 24 18          	mov    %eax,0x18(%rsp)
 1006814:	8b 41 30             	mov    0x30(%rcx),%eax
 1006817:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
 100681b:	e8 1e 0b 00 00       	callq  100733e <runtime.printf>
		runtime·throw("MHeap_FreeLocked - invalid free");
 1006820:	b8 58 35 02 01       	mov    $0x1023558,%eax
 1006825:	48 89 04 24          	mov    %rax,(%rsp)
 1006829:	e8 0b 35 00 00       	callq  1009d39 <runtime.throw>
 100682e:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
	}
	s->state = MSpanFree;
 1006833:	e9 8b fd ff ff       	jmpq   10065c3 <MHeap_FreeLocked+0x34>

0000000001006838 <runtime.MSpan_Init>:
	// TODO(rsc): IncrementalScavenge() to return memory to OS.
}

// Initialize a new span with the given start and npages.
void
runtime·MSpan_Init(MSpan *span, PageID start, uintptr npages)
 1006838:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100683f:	ff ff 
 1006841:	48 3b 21             	cmp    (%rcx),%rsp
 1006844:	77 05                	ja     100684b <runtime.MSpan_Init+0x13>
 1006846:	e8 13 b1 ff ff       	callq  100195e <runtime.morestack24>
 100684b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
{
	span->next = nil;
 1006850:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
	span->prev = nil;
 1006857:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
 100685e:	00 
	span->start = start;
 100685f:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
 1006864:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
	span->npages = npages;
 1006868:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
 100686d:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
	span->freelist = nil;
 1006871:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
 1006878:	00 
	span->ref = 0;
 1006879:	c7 42 30 00 00 00 00 	movl   $0x0,0x30(%rdx)
	span->sizeclass = 0;
 1006880:	c7 42 34 00 00 00 00 	movl   $0x0,0x34(%rdx)
	span->state = 0;
 1006887:	c7 42 38 00 00 00 00 	movl   $0x0,0x38(%rdx)
 100688e:	c3                   	retq   

000000000100688f <runtime.MSpanList_Init>:
}

// Initialize an empty doubly-linked list.
void
runtime·MSpanList_Init(MSpan *list)
 100688f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006896:	ff ff 
 1006898:	48 3b 21             	cmp    (%rcx),%rsp
 100689b:	77 05                	ja     10068a2 <runtime.MSpanList_Init+0x13>
 100689d:	e8 aa b0 ff ff       	callq  100194c <runtime.morestack8>
 10068a2:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
{
	list->state = MSpanListHead;
 10068a7:	c7 42 38 02 00 00 00 	movl   $0x2,0x38(%rdx)
	list->next = list;
 10068ae:	48 89 12             	mov    %rdx,(%rdx)
	list->prev = list;
 10068b1:	48 89 52 08          	mov    %rdx,0x8(%rdx)
 10068b5:	c3                   	retq   

00000000010068b6 <runtime.MSpanList_Remove>:
}

void
runtime·MSpanList_Remove(MSpan *span)
 10068b6:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10068bd:	ff ff 
 10068bf:	48 3b 21             	cmp    (%rcx),%rsp
 10068c2:	77 05                	ja     10068c9 <runtime.MSpanList_Remove+0x13>
 10068c4:	e8 83 b0 ff ff       	callq  100194c <runtime.morestack8>
 10068c9:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
{
	if(span->prev == nil && span->next == nil)
 10068ce:	48 8b 42 08          	mov    0x8(%rdx),%rax
 10068d2:	48 83 f8 00          	cmp    $0x0,%rax
 10068d6:	75 09                	jne    10068e1 <runtime.MSpanList_Remove+0x2b>
 10068d8:	48 8b 02             	mov    (%rdx),%rax
 10068db:	48 83 f8 00          	cmp    $0x0,%rax
 10068df:	74 25                	je     1006906 <runtime.MSpanList_Remove+0x50>
		return;
	span->prev->next = span->next;
 10068e1:	48 8b 42 08          	mov    0x8(%rdx),%rax
 10068e5:	48 8b 0a             	mov    (%rdx),%rcx
 10068e8:	48 89 08             	mov    %rcx,(%rax)
	span->next->prev = span->prev;
 10068eb:	48 8b 02             	mov    (%rdx),%rax
 10068ee:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 10068f2:	48 89 48 08          	mov    %rcx,0x8(%rax)
	span->prev = nil;
 10068f6:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
 10068fd:	00 
	span->next = nil;
 10068fe:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
 1006905:	c3                   	retq   

void
runtime·MSpanList_Remove(MSpan *span)
{
	if(span->prev == nil && span->next == nil)
		return;
 1006906:	c3                   	retq   

0000000001006907 <runtime.MSpanList_IsEmpty>:
	span->prev = nil;
	span->next = nil;
}

bool
runtime·MSpanList_IsEmpty(MSpan *list)
 1006907:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100690e:	ff ff 
 1006910:	48 3b 21             	cmp    (%rcx),%rsp
 1006913:	77 05                	ja     100691a <runtime.MSpanList_IsEmpty+0x13>
 1006915:	e8 32 b0 ff ff       	callq  100194c <runtime.morestack8>
 100691a:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
{
	return list->next == list;
 100691f:	48 8b 01             	mov    (%rcx),%rax
 1006922:	48 39 c8             	cmp    %rcx,%rax
 1006925:	75 06                	jne    100692d <runtime.MSpanList_IsEmpty+0x26>
 1006927:	b8 01 00 00 00       	mov    $0x1,%eax
 100692c:	c3                   	retq   
 100692d:	31 c0                	xor    %eax,%eax
 100692f:	eb fb                	jmp    100692c <runtime.MSpanList_IsEmpty+0x25>

0000000001006931 <runtime.MSpanList_Insert>:
}

void
runtime·MSpanList_Insert(MSpan *list, MSpan *span)
 1006931:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006938:	ff ff 
 100693a:	48 3b 21             	cmp    (%rcx),%rsp
 100693d:	77 05                	ja     1006944 <runtime.MSpanList_Insert+0x13>
 100693f:	e8 11 b0 ff ff       	callq  1001955 <runtime.morestack16>
 1006944:	48 83 ec 28          	sub    $0x28,%rsp
 1006948:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
{
	if(span->next != nil || span->prev != nil) {
 100694d:	48 8b 02             	mov    (%rdx),%rax
 1006950:	48 83 f8 00          	cmp    $0x0,%rax
 1006954:	75 31                	jne    1006987 <runtime.MSpanList_Insert+0x56>
 1006956:	48 8b 42 08          	mov    0x8(%rdx),%rax
 100695a:	48 83 f8 00          	cmp    $0x0,%rax
 100695e:	75 27                	jne    1006987 <runtime.MSpanList_Insert+0x56>
		runtime·printf("failed MSpanList_Insert %p %p %p\n", span, span->next, span->prev);
		runtime·throw("MSpanList_Insert");
	}
	span->next = list->next;
 1006960:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1006965:	48 8b 09             	mov    (%rcx),%rcx
 1006968:	48 89 0a             	mov    %rcx,(%rdx)
	span->prev = list;
 100696b:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1006970:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	span->next->prev = span;
 1006974:	48 8b 02             	mov    (%rdx),%rax
 1006977:	48 89 50 08          	mov    %rdx,0x8(%rax)
	span->prev->next = span;
 100697b:	48 8b 42 08          	mov    0x8(%rdx),%rax
 100697f:	48 89 10             	mov    %rdx,(%rax)
 1006982:	48 83 c4 28          	add    $0x28,%rsp
 1006986:	c3                   	retq   

void
runtime·MSpanList_Insert(MSpan *list, MSpan *span)
{
	if(span->next != nil || span->prev != nil) {
		runtime·printf("failed MSpanList_Insert %p %p %p\n", span, span->next, span->prev);
 1006987:	b8 78 35 02 01       	mov    $0x1023578,%eax
 100698c:	48 89 04 24          	mov    %rax,(%rsp)
 1006990:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 1006995:	48 8b 02             	mov    (%rdx),%rax
 1006998:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100699d:	48 8b 42 08          	mov    0x8(%rdx),%rax
 10069a1:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 10069a6:	e8 93 09 00 00       	callq  100733e <runtime.printf>
		runtime·throw("MSpanList_Insert");
 10069ab:	b8 9a 35 02 01       	mov    $0x102359a,%eax
 10069b0:	48 89 04 24          	mov    %rax,(%rsp)
 10069b4:	e8 80 33 00 00       	callq  1009d39 <runtime.throw>
 10069b9:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 10069be:	eb a0                	jmp    1006960 <runtime.MSpanList_Insert+0x2f>

00000000010069c0 <stkbucket>:
static Bucket *buckets;
static uintptr bucketmem;

// Return the bucket for stk[0:nstk], allocating new bucket if needed.
static Bucket*
stkbucket(uintptr *stk, int32 nstk)
 10069c0:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10069c7:	ff ff 
 10069c9:	48 3b 21             	cmp    (%rcx),%rsp
 10069cc:	77 05                	ja     10069d3 <stkbucket+0x13>
 10069ce:	e8 82 af ff ff       	callq  1001955 <runtime.morestack16>
 10069d3:	48 83 ec 40          	sub    $0x40,%rsp
 10069d7:	4c 8b 04 25 50 4e 02 	mov    0x1024e50,%r8
 10069de:	01 
 10069df:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
 10069e4:	8b 74 24 50          	mov    0x50(%rsp),%esi
{
	int32 i;
	uintptr h;
	Bucket *b;

	if(buckhash == nil) {
 10069e8:	49 83 f8 00          	cmp    $0x0,%r8
 10069ec:	75 28                	jne    1006a16 <stkbucket+0x56>
		buckhash = runtime·SysAlloc(BuckHashSize*sizeof buckhash[0]);
 10069ee:	48 c7 c1 f8 f8 15 00 	mov    $0x15f8f8,%rcx
 10069f5:	48 89 0c 24          	mov    %rcx,(%rsp)
 10069f9:	e8 9b d2 ff ff       	callq  1003c99 <runtime.SysAlloc>
 10069fe:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
 1006a03:	8b 74 24 50          	mov    0x50(%rsp),%esi
 1006a07:	49 89 c0             	mov    %rax,%r8
		mstats.buckhash_sys += BuckHashSize*sizeof buckhash[0];
 1006a0a:	48 81 04 25 e0 62 02 	addq   $0x15f8f8,0x10262e0
 1006a11:	01 f8 f8 15 00 
	}

	// Hash stack.
	h = 0;
 1006a16:	48 31 db             	xor    %rbx,%rbx
	for(i=0; i<nstk; i++) {
 1006a19:	31 ed                	xor    %ebp,%ebp
 1006a1b:	39 f5                	cmp    %esi,%ebp
 1006a1d:	7d 24                	jge    1006a43 <stkbucket+0x83>
		h += stk[i];
 1006a1f:	48 63 cd             	movslq %ebp,%rcx
 1006a22:	48 8b 04 cf          	mov    (%rdi,%rcx,8),%rax
 1006a26:	48 01 c3             	add    %rax,%rbx
		h += h<<10;
 1006a29:	48 89 d8             	mov    %rbx,%rax
 1006a2c:	48 c1 e0 0a          	shl    $0xa,%rax
 1006a30:	48 01 c3             	add    %rax,%rbx
		h ^= h>>6;
 1006a33:	48 89 d8             	mov    %rbx,%rax
 1006a36:	48 c1 e8 06          	shr    $0x6,%rax
 1006a3a:	48 31 c3             	xor    %rax,%rbx
		mstats.buckhash_sys += BuckHashSize*sizeof buckhash[0];
	}

	// Hash stack.
	h = 0;
	for(i=0; i<nstk; i++) {
 1006a3d:	ff c5                	inc    %ebp
 1006a3f:	39 f5                	cmp    %esi,%ebp
 1006a41:	7c dc                	jl     1006a1f <stkbucket+0x5f>
		h += stk[i];
		h += h<<10;
		h ^= h>>6;
	}
	h += h<<3;
 1006a43:	48 89 d8             	mov    %rbx,%rax
 1006a46:	48 c1 e0 03          	shl    $0x3,%rax
 1006a4a:	48 01 c3             	add    %rax,%rbx
	h ^= h>>11;
 1006a4d:	48 89 d8             	mov    %rbx,%rax
 1006a50:	48 c1 e8 0b          	shr    $0xb,%rax
 1006a54:	48 31 c3             	xor    %rax,%rbx

	i = h%BuckHashSize;
 1006a57:	48 89 d8             	mov    %rbx,%rax
 1006a5a:	48 89 5c 24 30       	mov    %rbx,0x30(%rsp)
 1006a5f:	31 d2                	xor    %edx,%edx
 1006a61:	48 c7 44 24 18 1f bf 	movq   $0x2bf1f,0x18(%rsp)
 1006a68:	02 00 
 1006a6a:	48 f7 74 24 18       	divq   0x18(%rsp)
 1006a6f:	48 63 c2             	movslq %edx,%rax
	for(b = buckhash[i]; b; b=b->next)
 1006a72:	89 44 24 3c          	mov    %eax,0x3c(%rsp)
 1006a76:	48 63 c8             	movslq %eax,%rcx
 1006a79:	4c 89 04 25 50 4e 02 	mov    %r8,0x1024e50
 1006a80:	01 
 1006a81:	49 8b 14 c8          	mov    (%r8,%rcx,8),%rdx
 1006a85:	48 83 fa 00          	cmp    $0x0,%rdx
 1006a89:	74 22                	je     1006aad <stkbucket+0xed>
		if(b->hash == h && b->nstk == nstk &&
 1006a8b:	48 8b 42 30          	mov    0x30(%rdx),%rax
 1006a8f:	48 39 d8             	cmp    %rbx,%rax
 1006a92:	75 10                	jne    1006aa4 <stkbucket+0xe4>
 1006a94:	48 8b 42 38          	mov    0x38(%rdx),%rax
 1006a98:	48 63 ce             	movslq %esi,%rcx
 1006a9b:	48 39 c8             	cmp    %rcx,%rax
 1006a9e:	0f 84 c8 00 00 00    	je     1006b6c <stkbucket+0x1ac>
	}
	h += h<<3;
	h ^= h>>11;

	i = h%BuckHashSize;
	for(b = buckhash[i]; b; b=b->next)
 1006aa4:	48 8b 12             	mov    (%rdx),%rdx
 1006aa7:	48 83 fa 00          	cmp    $0x0,%rdx
 1006aab:	75 de                	jne    1006a8b <stkbucket+0xcb>
		if(b->hash == h && b->nstk == nstk &&
		   runtime·mcmp((byte*)b->stk, (byte*)stk, nstk*sizeof stk[0]) == 0)
			return b;

	b = runtime·mallocgc(sizeof *b + nstk*sizeof stk[0], FlagNoProfiling, 0, 1);
 1006aad:	89 f1                	mov    %esi,%ecx
 1006aaf:	c1 e1 03             	shl    $0x3,%ecx
 1006ab2:	83 c1 48             	add    $0x48,%ecx
 1006ab5:	48 63 c9             	movslq %ecx,%rcx
 1006ab8:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006abc:	b9 02 00 00 00       	mov    $0x2,%ecx
 1006ac1:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1006ac5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
 1006acc:	00 
 1006acd:	b9 01 00 00 00       	mov    $0x1,%ecx
 1006ad2:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1006ad6:	e8 2c bc ff ff       	callq  1002707 <runtime.mallocgc>
 1006adb:	8b 54 24 50          	mov    0x50(%rsp),%edx
 1006adf:	48 89 c1             	mov    %rax,%rcx
	bucketmem += sizeof *b + nstk*sizeof stk[0];
 1006ae2:	89 d0                	mov    %edx,%eax
 1006ae4:	c1 e0 03             	shl    $0x3,%eax
 1006ae7:	83 c0 48             	add    $0x48,%eax
 1006aea:	48 63 c0             	movslq %eax,%rax
 1006aed:	48 01 04 25 40 4e 02 	add    %rax,0x1024e40
 1006af4:	01 
	runtime·memmove(b->stk, stk, nstk*sizeof stk[0]);
 1006af5:	48 89 c8             	mov    %rcx,%rax
 1006af8:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
 1006afd:	48 83 c0 40          	add    $0x40,%rax
 1006b01:	48 89 04 24          	mov    %rax,(%rsp)
 1006b05:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1006b0a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1006b0f:	89 d0                	mov    %edx,%eax
 1006b11:	c1 e0 03             	shl    $0x3,%eax
 1006b14:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1006b18:	e8 b5 d3 ff ff       	callq  1003ed2 <runtime.memmove>
 1006b1d:	48 8b 3c 25 50 4e 02 	mov    0x1024e50,%rdi
 1006b24:	01 
 1006b25:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
 1006b29:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
	b->hash = h;
 1006b2e:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1006b33:	48 89 48 30          	mov    %rcx,0x30(%rax)
	b->nstk = nstk;
 1006b37:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
 1006b3b:	48 63 c9             	movslq %ecx,%rcx
 1006b3e:	48 89 48 38          	mov    %rcx,0x38(%rax)
	b->next = buckhash[i];
 1006b42:	48 63 d6             	movslq %esi,%rdx
 1006b45:	48 8b 0c d7          	mov    (%rdi,%rdx,8),%rcx
 1006b49:	48 89 08             	mov    %rcx,(%rax)
	buckhash[i] = b;
 1006b4c:	48 63 ce             	movslq %esi,%rcx
 1006b4f:	48 89 04 cf          	mov    %rax,(%rdi,%rcx,8)
	b->allnext = buckets;
 1006b53:	48 8b 0c 25 48 4e 02 	mov    0x1024e48,%rcx
 1006b5a:	01 
 1006b5b:	48 89 48 08          	mov    %rcx,0x8(%rax)
	buckets = b;
 1006b5f:	48 89 04 25 48 4e 02 	mov    %rax,0x1024e48
 1006b66:	01 
	return b;
 1006b67:	48 83 c4 40          	add    $0x40,%rsp
 1006b6b:	c3                   	retq   
	h += h<<3;
	h ^= h>>11;

	i = h%BuckHashSize;
	for(b = buckhash[i]; b; b=b->next)
		if(b->hash == h && b->nstk == nstk &&
 1006b6c:	48 89 d1             	mov    %rdx,%rcx
 1006b6f:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
 1006b74:	48 83 c1 40          	add    $0x40,%rcx
 1006b78:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006b7c:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
 1006b81:	89 f1                	mov    %esi,%ecx
 1006b83:	c1 e1 03             	shl    $0x3,%ecx
 1006b86:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1006b8a:	e8 af 32 00 00       	callq  1009e3e <runtime.mcmp>
 1006b8f:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
 1006b94:	8b 74 24 50          	mov    0x50(%rsp),%esi
 1006b98:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 1006b9d:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
 1006ba2:	83 f8 00             	cmp    $0x0,%eax
 1006ba5:	0f 85 f9 fe ff ff    	jne    1006aa4 <stkbucket+0xe4>
		   runtime·mcmp((byte*)b->stk, (byte*)stk, nstk*sizeof stk[0]) == 0)
			return b;
 1006bab:	48 89 d0             	mov    %rdx,%rax
 1006bae:	48 83 c4 40          	add    $0x40,%rsp
 1006bb2:	c3                   	retq   

0000000001006bb3 <setaddrbucket>:
	HashMultiplier = 2654435769U
};

// Set the bucket associated with addr to b.
static void
setaddrbucket(uintptr addr, Bucket *b)
 1006bb3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006bba:	ff ff 
 1006bbc:	48 3b 21             	cmp    (%rcx),%rsp
 1006bbf:	77 05                	ja     1006bc6 <setaddrbucket+0x13>
 1006bc1:	e8 8f ad ff ff       	callq  1001955 <runtime.morestack16>
 1006bc6:	48 83 ec 40          	sub    $0x40,%rsp
 1006bca:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
	int32 i;
	uint32 h;
	AddrHash *ah;
	AddrEntry *e;

	h = (uint32)((addr>>20)*HashMultiplier) >> (32-AddrHashBits);
 1006bcf:	48 89 c7             	mov    %rax,%rdi
 1006bd2:	48 c1 e8 14          	shr    $0x14,%rax
 1006bd6:	b9 b9 79 37 9e       	mov    $0x9e3779b9,%ecx
 1006bdb:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 1006be0:	48 f7 64 24 18       	mulq   0x18(%rsp)
 1006be5:	c1 e8 14             	shr    $0x14,%eax
	for(ah=addrhash[h]; ah; ah=ah->next)
 1006be8:	89 44 24 38          	mov    %eax,0x38(%rsp)
 1006bec:	48 8b 2c c5 80 20 03 	mov    0x1032080(,%rax,8),%rbp
 1006bf3:	01 
 1006bf4:	48 83 fd 00          	cmp    $0x0,%rbp
 1006bf8:	0f 84 01 01 00 00    	je     1006cff <setaddrbucket+0x14c>
		if(ah->addr == (addr>>20))
 1006bfe:	48 89 f8             	mov    %rdi,%rax
 1006c01:	48 c1 e8 14          	shr    $0x14,%rax
 1006c05:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
 1006c0a:	48 8b 4d 08          	mov    0x8(%rbp),%rcx
 1006c0e:	48 39 c1             	cmp    %rax,%rcx
 1006c11:	0f 85 da 00 00 00    	jne    1006cf1 <setaddrbucket+0x13e>
	ah->next = addrhash[h];
	ah->addr = addr>>20;
	addrhash[h] = ah;

found:
	if((e = addrfree) == nil) {
 1006c17:	48 8b 34 25 28 4e 02 	mov    0x1024e28,%rsi
 1006c1e:	01 
 1006c1f:	48 83 fe 00          	cmp    $0x0,%rsi
 1006c23:	75 7d                	jne    1006ca2 <setaddrbucket+0xef>
		e = runtime·mallocgc(64*sizeof *e, FlagNoProfiling, 0, 0);
 1006c25:	48 c7 c1 00 06 00 00 	mov    $0x600,%rcx
 1006c2c:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006c30:	b9 02 00 00 00       	mov    $0x2,%ecx
 1006c35:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1006c39:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
 1006c40:	00 
 1006c41:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
 1006c48:	00 
 1006c49:	e8 b9 ba ff ff       	callq  1002707 <runtime.mallocgc>
 1006c4e:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
 1006c53:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
 1006c58:	48 89 c6             	mov    %rax,%rsi
		addrmem += 64*sizeof *e;
 1006c5b:	48 81 04 25 30 4e 02 	addq   $0x600,0x1024e30
 1006c62:	01 00 06 00 00 
		for(i=0; i+1<64; i++)
 1006c67:	31 db                	xor    %ebx,%ebx
 1006c69:	89 d8                	mov    %ebx,%eax
 1006c6b:	ff c0                	inc    %eax
 1006c6d:	83 f8 40             	cmp    $0x40,%eax
 1006c70:	7d 25                	jge    1006c97 <setaddrbucket+0xe4>
			e[i].next = &e[i+1];
 1006c72:	48 63 cb             	movslq %ebx,%rcx
 1006c75:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 1006c79:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
 1006c7d:	48 83 c0 18          	add    $0x18,%rax
 1006c81:	48 63 cb             	movslq %ebx,%rcx
 1006c84:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 1006c88:	48 89 04 0e          	mov    %rax,(%rsi,%rcx,1)

found:
	if((e = addrfree) == nil) {
		e = runtime·mallocgc(64*sizeof *e, FlagNoProfiling, 0, 0);
		addrmem += 64*sizeof *e;
		for(i=0; i+1<64; i++)
 1006c8c:	ff c3                	inc    %ebx
 1006c8e:	89 d8                	mov    %ebx,%eax
 1006c90:	ff c0                	inc    %eax
 1006c92:	83 f8 40             	cmp    $0x40,%eax
 1006c95:	7c db                	jl     1006c72 <setaddrbucket+0xbf>
			e[i].next = &e[i+1];
		e[63].next = nil;
 1006c97:	48 c7 86 e8 05 00 00 	movq   $0x0,0x5e8(%rsi)
 1006c9e:	00 00 00 00 
	}
	addrfree = e->next;
 1006ca2:	48 8b 06             	mov    (%rsi),%rax
 1006ca5:	48 89 04 25 28 4e 02 	mov    %rax,0x1024e28
 1006cac:	01 
	e->addr = (uint32)~(addr & ((1<<20)-1));
 1006cad:	48 89 f9             	mov    %rdi,%rcx
 1006cb0:	48 81 e1 ff ff 0f 00 	and    $0xfffff,%rcx
 1006cb7:	48 f7 d1             	not    %rcx
 1006cba:	89 4e 08             	mov    %ecx,0x8(%rsi)
	e->b = b;
 1006cbd:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 1006cc2:	48 89 4e 10          	mov    %rcx,0x10(%rsi)
	h = (addr>>7)&(nelem(ah->dense)-1);	// entry in dense is top 13 bits of low 20.
 1006cc6:	48 89 f8             	mov    %rdi,%rax
 1006cc9:	48 c1 e8 07          	shr    $0x7,%rax
 1006ccd:	48 25 ff 1f 00 00    	and    $0x1fff,%rax
	e->next = ah->dense[h];
 1006cd3:	48 89 eb             	mov    %rbp,%rbx
 1006cd6:	48 8d 0c c3          	lea    (%rbx,%rax,8),%rcx
 1006cda:	48 8b 49 10          	mov    0x10(%rcx),%rcx
 1006cde:	48 89 0e             	mov    %rcx,(%rsi)
	ah->dense[h] = e;
 1006ce1:	48 89 ea             	mov    %rbp,%rdx
 1006ce4:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
 1006ce8:	48 89 70 10          	mov    %rsi,0x10(%rax)
 1006cec:	48 83 c4 40          	add    $0x40,%rsp
 1006cf0:	c3                   	retq   
	uint32 h;
	AddrHash *ah;
	AddrEntry *e;

	h = (uint32)((addr>>20)*HashMultiplier) >> (32-AddrHashBits);
	for(ah=addrhash[h]; ah; ah=ah->next)
 1006cf1:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
 1006cf5:	48 83 fd 00          	cmp    $0x0,%rbp
 1006cf9:	0f 85 ff fe ff ff    	jne    1006bfe <setaddrbucket+0x4b>
		if(ah->addr == (addr>>20))
			goto found;

	ah = runtime·mallocgc(sizeof *ah, FlagNoProfiling, 0, 1);
 1006cff:	48 c7 c1 10 00 01 00 	mov    $0x10010,%rcx
 1006d06:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006d0a:	b9 02 00 00 00       	mov    $0x2,%ecx
 1006d0f:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1006d13:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
 1006d1a:	00 
 1006d1b:	b9 01 00 00 00       	mov    $0x1,%ecx
 1006d20:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1006d24:	e8 de b9 ff ff       	callq  1002707 <runtime.mallocgc>
 1006d29:	8b 5c 24 38          	mov    0x38(%rsp),%ebx
 1006d2d:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
 1006d32:	48 89 c5             	mov    %rax,%rbp
	addrmem += sizeof *ah;
 1006d35:	48 81 04 25 30 4e 02 	addq   $0x10010,0x1024e30
 1006d3c:	01 10 00 01 00 
	ah->next = addrhash[h];
 1006d41:	48 8b 0c dd 80 20 03 	mov    0x1032080(,%rbx,8),%rcx
 1006d48:	01 
 1006d49:	48 89 08             	mov    %rcx,(%rax)
	ah->addr = addr>>20;
 1006d4c:	48 89 f8             	mov    %rdi,%rax
 1006d4f:	48 c1 e8 14          	shr    $0x14,%rax
 1006d53:	48 89 45 08          	mov    %rax,0x8(%rbp)
	addrhash[h] = ah;
 1006d57:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
 1006d5c:	48 89 2c dd 80 20 03 	mov    %rbp,0x1032080(,%rbx,8)
 1006d63:	01 

found:
	if((e = addrfree) == nil) {
 1006d64:	e9 ae fe ff ff       	jmpq   1006c17 <setaddrbucket+0x64>

0000000001006d69 <getaddrbucket>:
	ah->dense[h] = e;
}

// Get the bucket associated with addr and clear the association.
static Bucket*
getaddrbucket(uintptr addr)
 1006d69:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006d70:	ff ff 
 1006d72:	48 3b 21             	cmp    (%rcx),%rsp
 1006d75:	77 05                	ja     1006d7c <getaddrbucket+0x13>
 1006d77:	e8 d0 ab ff ff       	callq  100194c <runtime.morestack8>
 1006d7c:	48 83 ec 40          	sub    $0x40,%rsp
 1006d80:	48 8b 6c 24 48       	mov    0x48(%rsp),%rbp
	uint32 h;
	AddrHash *ah;
	AddrEntry *e, **l;
	Bucket *b;

	h = (uint32)((addr>>20)*HashMultiplier) >> (32-AddrHashBits);
 1006d85:	48 89 e8             	mov    %rbp,%rax
 1006d88:	48 c1 e8 14          	shr    $0x14,%rax
 1006d8c:	b9 b9 79 37 9e       	mov    $0x9e3779b9,%ecx
 1006d91:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1006d96:	48 f7 64 24 08       	mulq   0x8(%rsp)
 1006d9b:	c1 e8 14             	shr    $0x14,%eax
	for(ah=addrhash[h]; ah; ah=ah->next)
 1006d9e:	48 8b 1c c5 80 20 03 	mov    0x1032080(,%rax,8),%rbx
 1006da5:	01 
 1006da6:	48 83 fb 00          	cmp    $0x0,%rbx
 1006daa:	0f 84 88 00 00 00    	je     1006e38 <getaddrbucket+0xcf>
		if(ah->addr == (addr>>20))
 1006db0:	48 89 e8             	mov    %rbp,%rax
 1006db3:	48 c1 e8 14          	shr    $0x14,%rax
 1006db7:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
 1006dbb:	48 39 c1             	cmp    %rax,%rcx
 1006dbe:	75 6b                	jne    1006e2b <getaddrbucket+0xc2>
			goto found;
	return nil;

found:
	h = (addr>>7)&(nelem(ah->dense)-1);	// entry in dense is top 13 bits of low 20.
 1006dc0:	48 89 e8             	mov    %rbp,%rax
 1006dc3:	48 c1 e8 07          	shr    $0x7,%rax
 1006dc7:	48 25 ff 1f 00 00    	and    $0x1fff,%rax
	for(l=&ah->dense[h]; (e=*l) != nil; l=&e->next) {
 1006dcd:	48 8d 04 c3          	lea    (%rbx,%rax,8),%rax
 1006dd1:	48 83 c0 10          	add    $0x10,%rax
 1006dd5:	48 89 c3             	mov    %rax,%rbx
 1006dd8:	48 8b 13             	mov    (%rbx),%rdx
 1006ddb:	48 83 fa 00          	cmp    $0x0,%rdx
 1006ddf:	74 42                	je     1006e23 <getaddrbucket+0xba>
		if(e->addr == (uint32)~(addr & ((1<<20)-1))) {
 1006de1:	8b 42 08             	mov    0x8(%rdx),%eax
 1006de4:	48 89 e9             	mov    %rbp,%rcx
 1006de7:	48 81 e1 ff ff 0f 00 	and    $0xfffff,%rcx
 1006dee:	48 f7 d1             	not    %rcx
 1006df1:	39 c8                	cmp    %ecx,%eax
 1006df3:	75 22                	jne    1006e17 <getaddrbucket+0xae>
			*l = e->next;
 1006df5:	48 8b 0a             	mov    (%rdx),%rcx
 1006df8:	48 89 0b             	mov    %rcx,(%rbx)
			b = e->b;
 1006dfb:	48 8b 42 10          	mov    0x10(%rdx),%rax
			e->next = addrfree;
 1006dff:	48 8b 0c 25 28 4e 02 	mov    0x1024e28,%rcx
 1006e06:	01 
 1006e07:	48 89 0a             	mov    %rcx,(%rdx)
			addrfree = e;
 1006e0a:	48 89 14 25 28 4e 02 	mov    %rdx,0x1024e28
 1006e11:	01 
			return b;
 1006e12:	48 83 c4 40          	add    $0x40,%rsp
 1006e16:	c3                   	retq   
			goto found;
	return nil;

found:
	h = (addr>>7)&(nelem(ah->dense)-1);	// entry in dense is top 13 bits of low 20.
	for(l=&ah->dense[h]; (e=*l) != nil; l=&e->next) {
 1006e17:	48 89 d3             	mov    %rdx,%rbx
 1006e1a:	48 8b 13             	mov    (%rbx),%rdx
 1006e1d:	48 83 fa 00          	cmp    $0x0,%rdx
 1006e21:	75 be                	jne    1006de1 <getaddrbucket+0x78>
			e->next = addrfree;
			addrfree = e;
			return b;
		}
	}
	return nil;
 1006e23:	48 31 c0             	xor    %rax,%rax
 1006e26:	48 83 c4 40          	add    $0x40,%rsp
 1006e2a:	c3                   	retq   
	AddrHash *ah;
	AddrEntry *e, **l;
	Bucket *b;

	h = (uint32)((addr>>20)*HashMultiplier) >> (32-AddrHashBits);
	for(ah=addrhash[h]; ah; ah=ah->next)
 1006e2b:	48 8b 1b             	mov    (%rbx),%rbx
 1006e2e:	48 83 fb 00          	cmp    $0x0,%rbx
 1006e32:	0f 85 78 ff ff ff    	jne    1006db0 <getaddrbucket+0x47>
		if(ah->addr == (addr>>20))
			goto found;
	return nil;
 1006e38:	48 31 c0             	xor    %rax,%rax
 1006e3b:	48 83 c4 40          	add    $0x40,%rsp
 1006e3f:	c3                   	retq   

0000000001006e40 <runtime.MProf_Malloc>:
	return nil;
}

// Called by malloc to record a profiled block.
void
runtime·MProf_Malloc(void *p, uintptr size)
 1006e40:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006e47:	ff ff 
 1006e49:	48 8d 84 24 48 ff ff 	lea    -0xb8(%rsp),%rax
 1006e50:	ff 
 1006e51:	48 3b 01             	cmp    (%rcx),%rax
 1006e54:	77 05                	ja     1006e5b <runtime.MProf_Malloc+0x1b>
 1006e56:	e8 fa aa ff ff       	callq  1001955 <runtime.morestack16>
 1006e5b:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp
{
	int32 nstk;
	uintptr stk[32];
	Bucket *b;

	if(m->nomemprof > 0)
 1006e62:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1006e69:	ff ff 
 1006e6b:	8b 80 88 00 00 00    	mov    0x88(%rax),%eax
 1006e71:	83 f8 00             	cmp    $0x0,%eax
 1006e74:	7e 08                	jle    1006e7e <runtime.MProf_Malloc+0x3e>
		return;
 1006e76:	48 81 c4 38 01 00 00 	add    $0x138,%rsp
 1006e7d:	c3                   	retq   

	m->nomemprof++;
 1006e7e:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1006e85:	ff ff 
 1006e87:	ff 80 88 00 00 00    	incl   0x88(%rax)
	nstk = runtime·callers(1, stk, 32);
 1006e8d:	b9 01 00 00 00       	mov    $0x1,%ecx
 1006e92:	89 0c 24             	mov    %ecx,(%rsp)
 1006e95:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
 1006e9a:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1006e9f:	b9 20 00 00 00       	mov    $0x20,%ecx
 1006ea4:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1006ea8:	e8 99 6b 00 00       	callq  100da46 <runtime.callers>
 1006ead:	89 84 24 34 01 00 00 	mov    %eax,0x134(%rsp)
	runtime·lock(&proflock);
 1006eb4:	b8 d0 4e 02 01       	mov    $0x1024ed0,%eax
 1006eb9:	48 89 04 24          	mov    %rax,(%rsp)
 1006ebd:	e8 6e 5f 00 00       	callq  100ce30 <runtime.lock>
	b = stkbucket(stk, nstk);
 1006ec2:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
 1006ec7:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006ecb:	8b 8c 24 34 01 00 00 	mov    0x134(%rsp),%ecx
 1006ed2:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1006ed6:	e8 e5 fa ff ff       	callq  10069c0 <stkbucket>
 1006edb:	48 89 c2             	mov    %rax,%rdx
	b->allocs++;
 1006ede:	48 ff 40 10          	incq   0x10(%rax)
	b->alloc_bytes += size;
 1006ee2:	48 8b 8c 24 48 01 00 	mov    0x148(%rsp),%rcx
 1006ee9:	00 
 1006eea:	48 01 48 20          	add    %rcx,0x20(%rax)
	setaddrbucket((uintptr)p, b);
 1006eee:	48 8b 84 24 40 01 00 	mov    0x140(%rsp),%rax
 1006ef5:	00 
 1006ef6:	48 89 04 24          	mov    %rax,(%rsp)
 1006efa:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 1006eff:	e8 af fc ff ff       	callq  1006bb3 <setaddrbucket>
	runtime·unlock(&proflock);
 1006f04:	b8 d0 4e 02 01       	mov    $0x1024ed0,%eax
 1006f09:	48 89 04 24          	mov    %rax,(%rsp)
 1006f0d:	e8 70 5f 00 00       	callq  100ce82 <runtime.unlock>
	m->nomemprof--;
 1006f12:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1006f19:	ff ff 
 1006f1b:	ff 88 88 00 00 00    	decl   0x88(%rax)
 1006f21:	48 81 c4 38 01 00 00 	add    $0x138,%rsp
 1006f28:	c3                   	retq   

0000000001006f29 <runtime.MProf_Free>:
}

// Called when freeing a profiled block.
void
runtime·MProf_Free(void *p, uintptr size)
 1006f29:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006f30:	ff ff 
 1006f32:	48 3b 21             	cmp    (%rcx),%rsp
 1006f35:	77 05                	ja     1006f3c <runtime.MProf_Free+0x13>
 1006f37:	e8 19 aa ff ff       	callq  1001955 <runtime.morestack16>
 1006f3c:	48 83 ec 20          	sub    $0x20,%rsp
{
	Bucket *b;

	if(m->nomemprof > 0)
 1006f40:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1006f47:	ff ff 
 1006f49:	8b 80 88 00 00 00    	mov    0x88(%rax),%eax
 1006f4f:	83 f8 00             	cmp    $0x0,%eax
 1006f52:	7e 05                	jle    1006f59 <runtime.MProf_Free+0x30>
		return;
 1006f54:	48 83 c4 20          	add    $0x20,%rsp
 1006f58:	c3                   	retq   

	m->nomemprof++;
 1006f59:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1006f60:	ff ff 
 1006f62:	ff 80 88 00 00 00    	incl   0x88(%rax)
	runtime·lock(&proflock);
 1006f68:	b8 d0 4e 02 01       	mov    $0x1024ed0,%eax
 1006f6d:	48 89 04 24          	mov    %rax,(%rsp)
 1006f71:	e8 ba 5e 00 00       	callq  100ce30 <runtime.lock>
	b = getaddrbucket((uintptr)p);
 1006f76:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 1006f7b:	48 89 0c 24          	mov    %rcx,(%rsp)
 1006f7f:	e8 e5 fd ff ff       	callq  1006d69 <getaddrbucket>
	if(b != nil) {
 1006f84:	48 83 f8 00          	cmp    $0x0,%rax
 1006f88:	74 0d                	je     1006f97 <runtime.MProf_Free+0x6e>
		b->frees++;
 1006f8a:	48 ff 40 18          	incq   0x18(%rax)
		b->free_bytes += size;
 1006f8e:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 1006f93:	48 01 48 28          	add    %rcx,0x28(%rax)
	}
	runtime·unlock(&proflock);
 1006f97:	b8 d0 4e 02 01       	mov    $0x1024ed0,%eax
 1006f9c:	48 89 04 24          	mov    %rax,(%rsp)
 1006fa0:	e8 dd 5e 00 00       	callq  100ce82 <runtime.unlock>
 1006fa5:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1006fac:	ff ff 
 1006fae:	ff 88 88 00 00 00    	decl   0x88(%rax)
 1006fb4:	48 83 c4 20          	add    $0x20,%rsp
 1006fb8:	c3                   	retq   

0000000001006fb9 <runtime.SizeToClass>:

static int32 size_to_class8[1024/8 + 1];
static int32 size_to_class128[(MaxSmallSize-1024)/128 + 1];

int32
runtime·SizeToClass(int32 size)
 1006fb9:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1006fc0:	ff ff 
 1006fc2:	48 3b 21             	cmp    (%rcx),%rsp
 1006fc5:	77 05                	ja     1006fcc <runtime.SizeToClass+0x13>
 1006fc7:	e8 80 a9 ff ff       	callq  100194c <runtime.morestack8>
 1006fcc:	48 83 ec 10          	sub    $0x10,%rsp
 1006fd0:	8b 54 24 18          	mov    0x18(%rsp),%edx
{
	if(size > MaxSmallSize)
 1006fd4:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
 1006fda:	7e 12                	jle    1006fee <runtime.SizeToClass+0x35>
		runtime·throw("SizeToClass - invalid size");
 1006fdc:	b8 a0 32 02 01       	mov    $0x10232a0,%eax
 1006fe1:	48 89 04 24          	mov    %rax,(%rsp)
 1006fe5:	e8 4f 2d 00 00       	callq  1009d39 <runtime.throw>
 1006fea:	8b 54 24 18          	mov    0x18(%rsp),%edx
	if(size > 1024-8)
 1006fee:	81 fa f8 03 00 00    	cmp    $0x3f8,%edx
 1006ff4:	7e 1a                	jle    1007010 <runtime.SizeToClass+0x57>
		return size_to_class128[(size-1024+127) >> 7];
 1006ff6:	89 d1                	mov    %edx,%ecx
 1006ff8:	81 c1 7f fc ff ff    	add    $0xfffffc7f,%ecx
 1006ffe:	c1 f9 07             	sar    $0x7,%ecx
 1007001:	48 63 c9             	movslq %ecx,%rcx
 1007004:	8b 04 8d 88 5a 02 01 	mov    0x1025a88(,%rcx,4),%eax
 100700b:	48 83 c4 10          	add    $0x10,%rsp
 100700f:	c3                   	retq   
	return size_to_class8[(size+7)>>3];
 1007010:	89 d1                	mov    %edx,%ecx
 1007012:	83 c1 07             	add    $0x7,%ecx
 1007015:	c1 f9 03             	sar    $0x3,%ecx
 1007018:	48 63 c9             	movslq %ecx,%rcx
 100701b:	8b 04 8d 48 55 02 01 	mov    0x1025548(,%rcx,4),%eax
 1007022:	48 83 c4 10          	add    $0x10,%rsp
 1007026:	c3                   	retq   

0000000001007027 <runtime.InitSizes>:
}

void
runtime·InitSizes(void)
 1007027:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100702e:	ff ff 
 1007030:	48 3b 21             	cmp    (%rcx),%rsp
 1007033:	77 05                	ja     100703a <runtime.InitSizes+0x13>
 1007035:	e8 b9 a8 ff ff       	callq  10018f3 <runtime.morestack00>
 100703a:	48 83 ec 50          	sub    $0x50,%rsp
	int32 align, sizeclass, size, nextsize, n;
	uint32 i;
	uintptr allocsize, npages;

	// Initialize the runtime·class_to_size table (and choose class sizes in the process).
	runtime·class_to_size[0] = 0;
 100703e:	c7 04 25 d8 51 02 01 	movl   $0x0,0x10251d8
 1007045:	00 00 00 00 
	sizeclass = 1;	// 0 means no class
 1007049:	bf 01 00 00 00       	mov    $0x1,%edi
 100704e:	89 7c 24 48          	mov    %edi,0x48(%rsp)
	align = 8;
 1007052:	41 b8 08 00 00 00    	mov    $0x8,%r8d
	for(size = align; size <= MaxSmallSize; size += align) {
 1007058:	44 89 c5             	mov    %r8d,%ebp
 100705b:	81 fd 00 80 00 00    	cmp    $0x8000,%ebp
 1007061:	0f 8f d1 00 00 00    	jg     1007138 <runtime.InitSizes+0x111>
		if((size&(size-1)) == 0) {	// bump alignment once in a while
 1007067:	89 e8                	mov    %ebp,%eax
 1007069:	ff c8                	dec    %eax
 100706b:	89 e9                	mov    %ebp,%ecx
 100706d:	89 6c 24 44          	mov    %ebp,0x44(%rsp)
 1007071:	21 c1                	and    %eax,%ecx
 1007073:	83 f9 00             	cmp    $0x0,%ecx
 1007076:	75 12                	jne    100708a <runtime.InitSizes+0x63>
			if(size >= 2048)
 1007078:	81 fd 00 08 00 00    	cmp    $0x800,%ebp
 100707e:	0f 8c 3e 02 00 00    	jl     10072c2 <runtime.InitSizes+0x29b>
				align = 256;
 1007084:	41 b8 00 01 00 00    	mov    $0x100,%r8d
			else if(size >= 128)
				align = size / 8;
			else if(size >= 16)
				align = 16;	// required for x86 SSE instructions, if we want to use them
		}
		if((align&(align-1)) != 0)
 100708a:	44 89 c0             	mov    %r8d,%eax
 100708d:	ff c8                	dec    %eax
 100708f:	44 89 c1             	mov    %r8d,%ecx
 1007092:	44 89 44 24 4c       	mov    %r8d,0x4c(%rsp)
 1007097:	21 c1                	and    %eax,%ecx
 1007099:	83 f9 00             	cmp    $0x0,%ecx
 100709c:	74 1b                	je     10070b9 <runtime.InitSizes+0x92>
			runtime·throw("InitSizes - bug");
 100709e:	b8 bb 32 02 01       	mov    $0x10232bb,%eax
 10070a3:	48 89 04 24          	mov    %rax,(%rsp)
 10070a7:	e8 8d 2c 00 00       	callq  1009d39 <runtime.throw>
 10070ac:	44 8b 44 24 4c       	mov    0x4c(%rsp),%r8d
 10070b1:	8b 7c 24 48          	mov    0x48(%rsp),%edi
 10070b5:	8b 6c 24 44          	mov    0x44(%rsp),%ebp

		// Make the allocnpages big enough that
		// the leftover is less than 1/8 of the total,
		// so wasted space is at most 12.5%.
		allocsize = PageSize;
 10070b9:	48 c7 c6 00 10 00 00 	mov    $0x1000,%rsi
		while(allocsize%size > allocsize/8)
 10070c0:	48 63 cd             	movslq %ebp,%rcx
 10070c3:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 10070c8:	48 89 f0             	mov    %rsi,%rax
 10070cb:	31 d2                	xor    %edx,%edx
 10070cd:	48 f7 74 24 18       	divq   0x18(%rsp)
 10070d2:	48 89 f1             	mov    %rsi,%rcx
 10070d5:	48 c1 e9 03          	shr    $0x3,%rcx
 10070d9:	48 39 ca             	cmp    %rcx,%rdx
 10070dc:	76 09                	jbe    10070e7 <runtime.InitSizes+0xc0>
			allocsize += PageSize;
 10070de:	48 81 c6 00 10 00 00 	add    $0x1000,%rsi

		// Make the allocnpages big enough that
		// the leftover is less than 1/8 of the total,
		// so wasted space is at most 12.5%.
		allocsize = PageSize;
		while(allocsize%size > allocsize/8)
 10070e5:	eb d9                	jmp    10070c0 <runtime.InitSizes+0x99>
			allocsize += PageSize;
		npages = allocsize >> PageShift;
 10070e7:	48 89 f0             	mov    %rsi,%rax
 10070ea:	48 c1 e8 0c          	shr    $0xc,%rax
 10070ee:	49 89 c1             	mov    %rax,%r9
		// If the previous sizeclass chose the same
		// allocation size and fit the same number of
		// objects into the page, we might as well
		// use just this size instead of having two
		// different sizes.
		if(sizeclass > 1
 10070f1:	83 ff 01             	cmp    $0x1,%edi
 10070f4:	7e 16                	jle    100710c <runtime.InitSizes+0xe5>
 10070f6:	48 63 cf             	movslq %edi,%rcx
 10070f9:	8b 04 8d dc 50 02 01 	mov    0x10250dc(,%rcx,4),%eax
 1007100:	48 63 c0             	movslq %eax,%rax
 1007103:	49 39 c1             	cmp    %rax,%r9
 1007106:	0f 84 63 01 00 00    	je     100726f <runtime.InitSizes+0x248>
		&& allocsize/size == allocsize/runtime·class_to_size[sizeclass-1]) {
			runtime·class_to_size[sizeclass-1] = size;
			continue;
		}

		runtime·class_to_allocnpages[sizeclass] = npages;
 100710c:	49 63 c1             	movslq %r9d,%rax
 100710f:	48 63 cf             	movslq %edi,%rcx
 1007112:	89 04 8d e0 50 02 01 	mov    %eax,0x10250e0(,%rcx,4)
		runtime·class_to_size[sizeclass] = size;
 1007119:	48 63 cf             	movslq %edi,%rcx
 100711c:	89 2c 8d d8 51 02 01 	mov    %ebp,0x10251d8(,%rcx,4)
		sizeclass++;
 1007123:	ff c7                	inc    %edi
 1007125:	89 7c 24 48          	mov    %edi,0x48(%rsp)

	// Initialize the runtime·class_to_size table (and choose class sizes in the process).
	runtime·class_to_size[0] = 0;
	sizeclass = 1;	// 0 means no class
	align = 8;
	for(size = align; size <= MaxSmallSize; size += align) {
 1007129:	44 01 c5             	add    %r8d,%ebp
 100712c:	81 fd 00 80 00 00    	cmp    $0x8000,%ebp
 1007132:	0f 8e 2f ff ff ff    	jle    1007067 <runtime.InitSizes+0x40>

		runtime·class_to_allocnpages[sizeclass] = npages;
		runtime·class_to_size[sizeclass] = size;
		sizeclass++;
	}
	if(sizeclass != NumSizeClasses) {
 1007138:	83 ff 3d             	cmp    $0x3d,%edi
 100713b:	74 29                	je     1007166 <runtime.InitSizes+0x13f>
		runtime·printf("sizeclass=%d NumSizeClasses=%d\n", sizeclass, NumSizeClasses);
 100713d:	b8 cb 32 02 01       	mov    $0x10232cb,%eax
 1007142:	48 89 04 24          	mov    %rax,(%rsp)
 1007146:	89 7c 24 08          	mov    %edi,0x8(%rsp)
 100714a:	b8 3d 00 00 00       	mov    $0x3d,%eax
 100714f:	89 44 24 0c          	mov    %eax,0xc(%rsp)
 1007153:	e8 e6 01 00 00       	callq  100733e <runtime.printf>
		runtime·throw("InitSizes - bad NumSizeClasses");
 1007158:	b8 eb 32 02 01       	mov    $0x10232eb,%eax
 100715d:	48 89 04 24          	mov    %rax,(%rsp)
 1007161:	e8 d3 2b 00 00       	callq  1009d39 <runtime.throw>
	}

	// Initialize the size_to_class tables.
	nextsize = 0;
 1007166:	31 db                	xor    %ebx,%ebx
	for (sizeclass = 1; sizeclass < NumSizeClasses; sizeclass++) {
 1007168:	bd 01 00 00 00       	mov    $0x1,%ebp
 100716d:	83 fd 3d             	cmp    $0x3d,%ebp
 1007170:	7d 6a                	jge    10071dc <runtime.InitSizes+0x1b5>
		for(; nextsize < 1024 && nextsize <= runtime·class_to_size[sizeclass]; nextsize+=8)
 1007172:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
 1007178:	7d 12                	jge    100718c <runtime.InitSizes+0x165>
 100717a:	48 63 cd             	movslq %ebp,%rcx
 100717d:	8b 04 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%eax
 1007184:	39 c3                	cmp    %eax,%ebx
 1007186:	0f 8e c2 00 00 00    	jle    100724e <runtime.InitSizes+0x227>
			size_to_class8[nextsize/8] = sizeclass;
		if(nextsize >= 1024)
 100718c:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
 1007192:	7c 41                	jl     10071d5 <runtime.InitSizes+0x1ae>
			for(; nextsize <= runtime·class_to_size[sizeclass]; nextsize += 128)
 1007194:	48 63 cd             	movslq %ebp,%rcx
 1007197:	8b 04 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%eax
 100719e:	39 c3                	cmp    %eax,%ebx
 10071a0:	7f 33                	jg     10071d5 <runtime.InitSizes+0x1ae>
				size_to_class128[(nextsize-1024)/128] = sizeclass;
 10071a2:	89 d9                	mov    %ebx,%ecx
 10071a4:	81 c1 00 fc ff ff    	add    $0xfffffc00,%ecx
 10071aa:	89 ca                	mov    %ecx,%edx
 10071ac:	c1 fa 1f             	sar    $0x1f,%edx
 10071af:	83 e2 7f             	and    $0x7f,%edx
 10071b2:	01 d1                	add    %edx,%ecx
 10071b4:	c1 f9 07             	sar    $0x7,%ecx
 10071b7:	48 63 c9             	movslq %ecx,%rcx
 10071ba:	89 2c 8d 88 5a 02 01 	mov    %ebp,0x1025a88(,%rcx,4)
	nextsize = 0;
	for (sizeclass = 1; sizeclass < NumSizeClasses; sizeclass++) {
		for(; nextsize < 1024 && nextsize <= runtime·class_to_size[sizeclass]; nextsize+=8)
			size_to_class8[nextsize/8] = sizeclass;
		if(nextsize >= 1024)
			for(; nextsize <= runtime·class_to_size[sizeclass]; nextsize += 128)
 10071c1:	81 c3 80 00 00 00    	add    $0x80,%ebx
 10071c7:	48 63 cd             	movslq %ebp,%rcx
 10071ca:	8b 04 8d d8 51 02 01 	mov    0x10251d8(,%rcx,4),%eax
 10071d1:	39 c3                	cmp    %eax,%ebx
 10071d3:	7e cd                	jle    10071a2 <runtime.InitSizes+0x17b>
		runtime·throw("InitSizes - bad NumSizeClasses");
	}

	// Initialize the size_to_class tables.
	nextsize = 0;
	for (sizeclass = 1; sizeclass < NumSizeClasses; sizeclass++) {
 10071d5:	ff c5                	inc    %ebp
 10071d7:	83 fd 3d             	cmp    $0x3d,%ebp
 10071da:	7c 96                	jl     1007172 <runtime.InitSizes+0x14b>
			}
		}
	}

	// Copy out for statistics table.
	for(i=0; i<nelem(runtime·class_to_size); i++)
 10071dc:	31 d2                	xor    %edx,%edx
 10071de:	83 fa 3d             	cmp    $0x3d,%edx
 10071e1:	73 1b                	jae    10071fe <runtime.InitSizes+0x1d7>
		mstats.by_size[i].size = runtime·class_to_size[i];
 10071e3:	8b 04 95 d8 51 02 01 	mov    0x10251d8(,%rdx,4),%eax
 10071ea:	89 d1                	mov    %edx,%ecx
 10071ec:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 10071f0:	89 04 0d 00 6b 02 01 	mov    %eax,0x1026b00(,%rcx,1)
			}
		}
	}

	// Copy out for statistics table.
	for(i=0; i<nelem(runtime·class_to_size); i++)
 10071f7:	ff c2                	inc    %edx
 10071f9:	83 fa 3d             	cmp    $0x3d,%edx
 10071fc:	72 e5                	jb     10071e3 <runtime.InitSizes+0x1bc>
		mstats.by_size[i].size = runtime·class_to_size[i];

	// Initialize the runtime·class_to_transfercount table.
	for(sizeclass = 1; sizeclass < NumSizeClasses; sizeclass++) {
 10071fe:	bb 01 00 00 00       	mov    $0x1,%ebx
 1007203:	83 fb 3d             	cmp    $0x3d,%ebx
 1007206:	7d 41                	jge    1007249 <runtime.InitSizes+0x222>
		n = 64*1024 / runtime·class_to_size[sizeclass];
 1007208:	48 63 d3             	movslq %ebx,%rdx
 100720b:	8b 0c 95 d8 51 02 01 	mov    0x10251d8(,%rdx,4),%ecx
 1007212:	89 4c 24 1c          	mov    %ecx,0x1c(%rsp)
 1007216:	b8 00 00 01 00       	mov    $0x10000,%eax
 100721b:	99                   	cltd   
 100721c:	f7 7c 24 1c          	idivl  0x1c(%rsp)
 1007220:	89 c1                	mov    %eax,%ecx
		if(n < 2)
 1007222:	83 f8 02             	cmp    $0x2,%eax
 1007225:	7d 05                	jge    100722c <runtime.InitSizes+0x205>
			n = 2;
 1007227:	b9 02 00 00 00       	mov    $0x2,%ecx
		if(n > 32)
 100722c:	83 f9 20             	cmp    $0x20,%ecx
 100722f:	7e 05                	jle    1007236 <runtime.InitSizes+0x20f>
			n = 32;
 1007231:	b9 20 00 00 00       	mov    $0x20,%ecx
		runtime·class_to_transfercount[sizeclass] = n;
 1007236:	89 c8                	mov    %ecx,%eax
 1007238:	48 63 cb             	movslq %ebx,%rcx
 100723b:	89 04 8d d0 52 02 01 	mov    %eax,0x10252d0(,%rcx,4)
	// Copy out for statistics table.
	for(i=0; i<nelem(runtime·class_to_size); i++)
		mstats.by_size[i].size = runtime·class_to_size[i];

	// Initialize the runtime·class_to_transfercount table.
	for(sizeclass = 1; sizeclass < NumSizeClasses; sizeclass++) {
 1007242:	ff c3                	inc    %ebx
 1007244:	83 fb 3d             	cmp    $0x3d,%ebx
 1007247:	7c bf                	jl     1007208 <runtime.InitSizes+0x1e1>
			n = 2;
		if(n > 32)
			n = 32;
		runtime·class_to_transfercount[sizeclass] = n;
	}
	return;
 1007249:	48 83 c4 50          	add    $0x50,%rsp
 100724d:	c3                   	retq   

	// Initialize the size_to_class tables.
	nextsize = 0;
	for (sizeclass = 1; sizeclass < NumSizeClasses; sizeclass++) {
		for(; nextsize < 1024 && nextsize <= runtime·class_to_size[sizeclass]; nextsize+=8)
			size_to_class8[nextsize/8] = sizeclass;
 100724e:	89 d9                	mov    %ebx,%ecx
 1007250:	89 da                	mov    %ebx,%edx
 1007252:	c1 fa 1f             	sar    $0x1f,%edx
 1007255:	83 e2 07             	and    $0x7,%edx
 1007258:	01 d1                	add    %edx,%ecx
 100725a:	c1 f9 03             	sar    $0x3,%ecx
 100725d:	48 63 c9             	movslq %ecx,%rcx
 1007260:	89 2c 8d 48 55 02 01 	mov    %ebp,0x1025548(,%rcx,4)
	}

	// Initialize the size_to_class tables.
	nextsize = 0;
	for (sizeclass = 1; sizeclass < NumSizeClasses; sizeclass++) {
		for(; nextsize < 1024 && nextsize <= runtime·class_to_size[sizeclass]; nextsize+=8)
 1007267:	83 c3 08             	add    $0x8,%ebx
 100726a:	e9 03 ff ff ff       	jmpq   1007172 <runtime.InitSizes+0x14b>
		// If the previous sizeclass chose the same
		// allocation size and fit the same number of
		// objects into the page, we might as well
		// use just this size instead of having two
		// different sizes.
		if(sizeclass > 1
 100726f:	48 63 cd             	movslq %ebp,%rcx
 1007272:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 1007277:	48 89 f0             	mov    %rsi,%rax
 100727a:	31 d2                	xor    %edx,%edx
 100727c:	48 f7 74 24 18       	divq   0x18(%rsp)
 1007281:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1007286:	48 63 df             	movslq %edi,%rbx
 1007289:	8b 14 9d d4 51 02 01 	mov    0x10251d4(,%rbx,4),%edx
 1007290:	48 63 d2             	movslq %edx,%rdx
 1007293:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
 1007298:	48 89 f0             	mov    %rsi,%rax
 100729b:	31 d2                	xor    %edx,%edx
 100729d:	48 f7 74 24 10       	divq   0x10(%rsp)
 10072a2:	48 89 c1             	mov    %rax,%rcx
 10072a5:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 10072aa:	48 39 c8             	cmp    %rcx,%rax
 10072ad:	0f 85 59 fe ff ff    	jne    100710c <runtime.InitSizes+0xe5>
		&& npages == runtime·class_to_allocnpages[sizeclass-1]
		&& allocsize/size == allocsize/runtime·class_to_size[sizeclass-1]) {
			runtime·class_to_size[sizeclass-1] = size;
 10072b3:	48 63 cf             	movslq %edi,%rcx
 10072b6:	89 2c 8d d4 51 02 01 	mov    %ebp,0x10251d4(,%rcx,4)

	// Initialize the runtime·class_to_size table (and choose class sizes in the process).
	runtime·class_to_size[0] = 0;
	sizeclass = 1;	// 0 means no class
	align = 8;
	for(size = align; size <= MaxSmallSize; size += align) {
 10072bd:	e9 67 fe ff ff       	jmpq   1007129 <runtime.InitSizes+0x102>
		if((size&(size-1)) == 0) {	// bump alignment once in a while
			if(size >= 2048)
				align = 256;
			else if(size >= 128)
 10072c2:	81 fd 80 00 00 00    	cmp    $0x80,%ebp
 10072c8:	7c 13                	jl     10072dd <runtime.InitSizes+0x2b6>
				align = size / 8;
 10072ca:	89 e8                	mov    %ebp,%eax
 10072cc:	99                   	cltd   
 10072cd:	83 e2 07             	and    $0x7,%edx
 10072d0:	01 d0                	add    %edx,%eax
 10072d2:	c1 f8 03             	sar    $0x3,%eax
 10072d5:	41 89 c0             	mov    %eax,%r8d
			else if(size >= 16)
				align = 16;	// required for x86 SSE instructions, if we want to use them
		}
		if((align&(align-1)) != 0)
 10072d8:	e9 ad fd ff ff       	jmpq   100708a <runtime.InitSizes+0x63>
		if((size&(size-1)) == 0) {	// bump alignment once in a while
			if(size >= 2048)
				align = 256;
			else if(size >= 128)
				align = size / 8;
			else if(size >= 16)
 10072dd:	83 fd 10             	cmp    $0x10,%ebp
 10072e0:	0f 8c a4 fd ff ff    	jl     100708a <runtime.InitSizes+0x63>
				align = 16;	// required for x86 SSE instructions, if we want to use them
 10072e6:	41 b8 10 00 00 00    	mov    $0x10,%r8d
 10072ec:	e9 99 fd ff ff       	jmpq   100708a <runtime.InitSizes+0x63>

00000000010072f1 <runtime.prints>:
	if(n & 15)
		runtime·prints("\n");
}

void
runtime·prints(int8 *s)
 10072f1:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10072f8:	ff ff 
 10072fa:	48 3b 21             	cmp    (%rcx),%rsp
 10072fd:	77 05                	ja     1007304 <runtime.prints+0x13>
 10072ff:	e8 48 a6 ff ff       	callq  100194c <runtime.morestack8>
 1007304:	48 83 ec 20          	sub    $0x20,%rsp
{
	runtime·write(2, s, runtime·findnull((byte*)s));
 1007308:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100730d:	48 89 0c 24          	mov    %rcx,(%rsp)
 1007311:	e8 b6 43 00 00       	callq  100b6cc <runtime.findnull>
 1007316:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
 100731a:	b8 02 00 00 00       	mov    $0x2,%eax
 100731f:	89 04 24             	mov    %eax,(%rsp)
 1007322:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1007327:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100732c:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
 1007330:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007334:	e8 65 54 00 00       	callq  100c79e <runtime.write>
 1007339:	48 83 c4 20          	add    $0x20,%rsp
 100733d:	c3                   	retq   

000000000100733e <runtime.printf>:
}

#pragma textflag 7
void
runtime·printf(int8 *s, ...)
 100733e:	48 83 ec 28          	sub    $0x28,%rsp
{
	byte *arg;

	arg = (byte*)(&s+1);
 1007342:	48 8d 44 24 38       	lea    0x38(%rsp),%rax
 1007347:	48 89 c1             	mov    %rax,%rcx
	vprintf(s, arg);
 100734a:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100734f:	48 89 04 24          	mov    %rax,(%rsp)
 1007353:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1007358:	e8 05 00 00 00       	callq  1007362 <vprintf>
 100735d:	48 83 c4 28          	add    $0x28,%rsp
 1007361:	c3                   	retq   

0000000001007362 <vprintf>:
}

// Very simple printf.  Only for debugging prints.
// Do not add to this without checking with Rob.
static void
vprintf(int8 *s, byte *base)
 1007362:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007369:	ff ff 
 100736b:	48 3b 21             	cmp    (%rcx),%rsp
 100736e:	77 05                	ja     1007375 <vprintf+0x13>
 1007370:	e8 e0 a5 ff ff       	callq  1001955 <runtime.morestack16>
 1007375:	48 83 ec 50          	sub    $0x50,%rsp
	uintptr arg, narg;
	byte *v;

//	lock(&debuglock);

	lp = p = s;
 1007379:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 100737e:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
	arg = 0;
 1007383:	48 31 db             	xor    %rbx,%rbx
 1007386:	48 89 5c 24 38       	mov    %rbx,0x38(%rsp)
	for(; *p; p++) {
 100738b:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1007390:	0f be 00             	movsbl (%rax),%eax
 1007393:	3c 00                	cmp    $0x0,%al
 1007395:	74 1e                	je     10073b5 <vprintf+0x53>
		if(*p != '%')
 1007397:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 100739c:	0f be 00             	movsbl (%rax),%eax
 100739f:	83 f8 25             	cmp    $0x25,%eax
 10073a2:	74 41                	je     10073e5 <vprintf+0x83>

//	lock(&debuglock);

	lp = p = s;
	arg = 0;
	for(; *p; p++) {
 10073a4:	48 ff 44 24 48       	incq   0x48(%rsp)
 10073a9:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 10073ae:	0f be 00             	movsbl (%rax),%eax
 10073b1:	3c 00                	cmp    $0x0,%al
 10073b3:	75 e2                	jne    1007397 <vprintf+0x35>
			break;
		}
		arg = narg;
		lp = p+1;
	}
	if(p > lp)
 10073b5:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 10073ba:	48 39 c8             	cmp    %rcx,%rax
 10073bd:	76 21                	jbe    10073e0 <vprintf+0x7e>
		runtime·write(2, lp, p-lp);
 10073bf:	b8 02 00 00 00       	mov    $0x2,%eax
 10073c4:	89 04 24             	mov    %eax,(%rsp)
 10073c7:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10073cc:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 10073d1:	48 29 c8             	sub    %rcx,%rax
 10073d4:	48 63 c0             	movslq %eax,%rax
 10073d7:	89 44 24 10          	mov    %eax,0x10(%rsp)
 10073db:	e8 be 53 00 00       	callq  100c79e <runtime.write>
 10073e0:	48 83 c4 50          	add    $0x50,%rsp
 10073e4:	c3                   	retq   
	lp = p = s;
	arg = 0;
	for(; *p; p++) {
		if(*p != '%')
			continue;
		if(p > lp)
 10073e5:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 10073ea:	48 39 c8             	cmp    %rcx,%rax
 10073ed:	76 26                	jbe    1007415 <vprintf+0xb3>
			runtime·write(2, lp, p-lp);
 10073ef:	b8 02 00 00 00       	mov    $0x2,%eax
 10073f4:	89 04 24             	mov    %eax,(%rsp)
 10073f7:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 10073fc:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1007401:	48 29 c8             	sub    %rcx,%rax
 1007404:	48 63 c0             	movslq %eax,%rax
 1007407:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100740b:	e8 8e 53 00 00       	callq  100c79e <runtime.write>
 1007410:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
		p++;
 1007415:	48 ff 44 24 48       	incq   0x48(%rsp)
		narg = 0;
 100741a:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
 1007421:	00 00 
			break;
		case 'i':	// pointer-aligned but bigger
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
 1007423:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1007428:	0f be 00             	movsbl (%rax),%eax
 100742b:	83 f8 65             	cmp    $0x65,%eax
 100742e:	0f 8f a4 02 00 00    	jg     10076d8 <vprintf+0x376>
 1007434:	0f 84 7c 02 00 00    	je     10076b6 <vprintf+0x354>
 100743a:	83 f8 55             	cmp    $0x55,%eax
 100743d:	0f 8f 1c 02 00 00    	jg     100765f <vprintf+0x2fd>
 1007443:	0f 84 d2 01 00 00    	je     100761b <vprintf+0x2b9>
 1007449:	83 f8 43             	cmp    $0x43,%eax
 100744c:	0f 84 eb 01 00 00    	je     100763d <vprintf+0x2db>
 1007452:	83 f8 44             	cmp    $0x44,%eax
 1007455:	0f 84 c0 01 00 00    	je     100761b <vprintf+0x2b9>
 100745b:	83 f8 53             	cmp    $0x53,%eax
 100745e:	0f 84 95 01 00 00    	je     10075f9 <vprintf+0x297>
		}
		v = base+arg;
 1007464:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
 1007469:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
 100746d:	48 89 c2             	mov    %rax,%rdx
		case 'x':
			runtime·printhex(*(uint32*)v);
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
 1007470:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1007475:	0f be 00             	movsbl (%rax),%eax
 1007478:	83 f8 65             	cmp    $0x65,%eax
 100747b:	0f 8f e1 00 00 00    	jg     1007562 <vprintf+0x200>
 1007481:	0f 84 c1 00 00 00    	je     1007548 <vprintf+0x1e6>
 1007487:	83 f8 55             	cmp    $0x55,%eax
 100748a:	7f 72                	jg     10074fe <vprintf+0x19c>
 100748c:	74 62                	je     10074f0 <vprintf+0x18e>
 100748e:	83 f8 43             	cmp    $0x43,%eax
 1007491:	74 46                	je     10074d9 <vprintf+0x177>
 1007493:	83 f8 44             	cmp    $0x44,%eax
 1007496:	74 33                	je     10074cb <vprintf+0x169>
 1007498:	83 f8 53             	cmp    $0x53,%eax
 100749b:	74 17                	je     10074b4 <vprintf+0x152>
		}
		arg = narg;
 100749d:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
 10074a2:	48 89 5c 24 38       	mov    %rbx,0x38(%rsp)
		lp = p+1;
 10074a7:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 10074ac:	48 ff c1             	inc    %rcx

//	lock(&debuglock);

	lp = p = s;
	arg = 0;
	for(; *p; p++) {
 10074af:	e9 f0 fe ff ff       	jmpq   10073a4 <vprintf+0x42>
			break;
		case 's':
			runtime·prints(*(int8**)v);
			break;
		case 'S':
			runtime·printstring(*(String*)v);
 10074b4:	48 8b 02             	mov    (%rdx),%rax
 10074b7:	48 89 04 24          	mov    %rax,(%rsp)
 10074bb:	48 8b 42 08          	mov    0x8(%rdx),%rax
 10074bf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10074c4:	e8 ff 07 00 00       	callq  1007cc8 <runtime.printstring>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10074c9:	eb d2                	jmp    100749d <vprintf+0x13b>
			break;
		case 'd':
			runtime·printint(*(int32*)v);
			break;
		case 'D':
			runtime·printint(*(int64*)v);
 10074cb:	48 8b 02             	mov    (%rdx),%rax
 10074ce:	48 89 04 24          	mov    %rax,(%rsp)
 10074d2:	e8 af 06 00 00       	callq  1007b86 <runtime.printint>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10074d7:	eb c4                	jmp    100749d <vprintf+0x13b>
			break;
		case 'f':
			runtime·printfloat(*(float64*)v);
			break;
		case 'C':
			runtime·printcomplex(*(Complex128*)v);
 10074d9:	48 8b 02             	mov    (%rdx),%rax
 10074dc:	48 89 04 24          	mov    %rax,(%rsp)
 10074e0:	48 8b 42 08          	mov    0x8(%rdx),%rax
 10074e4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10074e9:	e8 7d 05 00 00       	callq  1007a6b <runtime.printcomplex>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10074ee:	eb ad                	jmp    100749d <vprintf+0x13b>
			break;
		case 't':
			runtime·printbool(*(bool*)v);
			break;
		case 'U':
			runtime·printuint(*(uint64*)v);
 10074f0:	48 8b 02             	mov    (%rdx),%rax
 10074f3:	48 89 04 24          	mov    %rax,(%rsp)
 10074f7:	e8 eb 05 00 00       	callq  1007ae7 <runtime.printuint>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10074fc:	eb 9f                	jmp    100749d <vprintf+0x13b>
		case 'x':
			runtime·printhex(*(uint32*)v);
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
 10074fe:	83 f8 58             	cmp    $0x58,%eax
 1007501:	74 34                	je     1007537 <vprintf+0x1d5>
 1007503:	83 f8 61             	cmp    $0x61,%eax
 1007506:	74 15                	je     100751d <vprintf+0x1bb>
 1007508:	83 f8 64             	cmp    $0x64,%eax
 100750b:	75 90                	jne    100749d <vprintf+0x13b>
		switch(*p) {
		case 'a':
			runtime·printslice(*(Slice*)v);
			break;
		case 'd':
			runtime·printint(*(int32*)v);
 100750d:	8b 02                	mov    (%rdx),%eax
 100750f:	48 63 c0             	movslq %eax,%rax
 1007512:	48 89 04 24          	mov    %rax,(%rsp)
 1007516:	e8 6b 06 00 00       	callq  1007b86 <runtime.printint>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 100751b:	eb 80                	jmp    100749d <vprintf+0x13b>
			break;
		}
		v = base+arg;
		switch(*p) {
		case 'a':
			runtime·printslice(*(Slice*)v);
 100751d:	48 8b 02             	mov    (%rdx),%rax
 1007520:	48 89 04 24          	mov    %rax,(%rsp)
 1007524:	48 8b 42 08          	mov    0x8(%rdx),%rax
 1007528:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100752d:	e8 2c 41 00 00       	callq  100b65e <runtime.printslice>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 1007532:	e9 66 ff ff ff       	jmpq   100749d <vprintf+0x13b>
			break;
		case 'x':
			runtime·printhex(*(uint32*)v);
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
 1007537:	48 8b 02             	mov    (%rdx),%rax
 100753a:	48 89 04 24          	mov    %rax,(%rsp)
 100753e:	e8 9b 06 00 00       	callq  1007bde <runtime.printhex>
			break;
		}
		arg = narg;
 1007543:	e9 55 ff ff ff       	jmpq   100749d <vprintf+0x13b>
			break;
		case 'D':
			runtime·printint(*(int64*)v);
			break;
		case 'e':
			runtime·printeface(*(Eface*)v);
 1007548:	48 8b 02             	mov    (%rdx),%rax
 100754b:	48 89 04 24          	mov    %rax,(%rsp)
 100754f:	48 8b 42 08          	mov    0x8(%rdx),%rax
 1007553:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007558:	e8 e2 a6 ff ff       	callq  1001c3f <runtime.printeface>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 100755d:	e9 3b ff ff ff       	jmpq   100749d <vprintf+0x13b>
		case 'x':
			runtime·printhex(*(uint32*)v);
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
 1007562:	83 f8 73             	cmp    $0x73,%eax
 1007565:	7f 64                	jg     10075cb <vprintf+0x269>
 1007567:	74 51                	je     10075ba <vprintf+0x258>
 1007569:	83 f8 66             	cmp    $0x66,%eax
 100756c:	74 39                	je     10075a7 <vprintf+0x245>
 100756e:	83 f8 69             	cmp    $0x69,%eax
 1007571:	74 1a                	je     100758d <vprintf+0x22b>
 1007573:	83 f8 70             	cmp    $0x70,%eax
 1007576:	0f 85 21 ff ff ff    	jne    100749d <vprintf+0x13b>
			break;
		case 'i':
			runtime·printiface(*(Iface*)v);
			break;
		case 'p':
			runtime·printpointer(*(void**)v);
 100757c:	48 8b 02             	mov    (%rdx),%rax
 100757f:	48 89 04 24          	mov    %rax,(%rsp)
 1007583:	e8 16 07 00 00       	callq  1007c9e <runtime.printpointer>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 1007588:	e9 10 ff ff ff       	jmpq   100749d <vprintf+0x13b>
			break;
		case 'C':
			runtime·printcomplex(*(Complex128*)v);
			break;
		case 'i':
			runtime·printiface(*(Iface*)v);
 100758d:	48 8b 02             	mov    (%rdx),%rax
 1007590:	48 89 04 24          	mov    %rax,(%rsp)
 1007594:	48 8b 42 08          	mov    0x8(%rdx),%rax
 1007598:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100759d:	e8 5f a6 ff ff       	callq  1001c01 <runtime.printiface>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10075a2:	e9 f6 fe ff ff       	jmpq   100749d <vprintf+0x13b>
			break;
		case 'e':
			runtime·printeface(*(Eface*)v);
			break;
		case 'f':
			runtime·printfloat(*(float64*)v);
 10075a7:	f2 0f 10 02          	movsd  (%rdx),%xmm0
 10075ab:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 10075b0:	e8 ee 01 00 00       	callq  10077a3 <runtime.printfloat>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10075b5:	e9 e3 fe ff ff       	jmpq   100749d <vprintf+0x13b>
			break;
		case 'p':
			runtime·printpointer(*(void**)v);
			break;
		case 's':
			runtime·prints(*(int8**)v);
 10075ba:	48 8b 02             	mov    (%rdx),%rax
 10075bd:	48 89 04 24          	mov    %rax,(%rsp)
 10075c1:	e8 2b fd ff ff       	callq  10072f1 <runtime.prints>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10075c6:	e9 d2 fe ff ff       	jmpq   100749d <vprintf+0x13b>
		case 'x':
			runtime·printhex(*(uint32*)v);
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
 10075cb:	83 f8 74             	cmp    $0x74,%eax
 10075ce:	74 19                	je     10075e9 <vprintf+0x287>
 10075d0:	83 f8 78             	cmp    $0x78,%eax
 10075d3:	0f 85 c4 fe ff ff    	jne    100749d <vprintf+0x13b>
			break;
		case 'U':
			runtime·printuint(*(uint64*)v);
			break;
		case 'x':
			runtime·printhex(*(uint32*)v);
 10075d9:	8b 02                	mov    (%rdx),%eax
 10075db:	48 89 04 24          	mov    %rax,(%rsp)
 10075df:	e8 fa 05 00 00       	callq  1007bde <runtime.printhex>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10075e4:	e9 b4 fe ff ff       	jmpq   100749d <vprintf+0x13b>
			break;
		case 'S':
			runtime·printstring(*(String*)v);
			break;
		case 't':
			runtime·printbool(*(bool*)v);
 10075e9:	0f b6 02             	movzbl (%rdx),%eax
 10075ec:	88 04 24             	mov    %al,(%rsp)
 10075ef:	e8 47 01 00 00       	callq  100773b <runtime.printbool>
			break;
		case 'X':
			runtime·printhex(*(uint64*)v);
			break;
		}
		arg = narg;
 10075f4:	e9 a4 fe ff ff       	jmpq   100749d <vprintf+0x13b>
		case 's':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(uintptr);
			break;
		case 'S':	// pointer-aligned but bigger
			arg = runtime·rnd(arg, sizeof(uintptr));
 10075f9:	89 1c 24             	mov    %ebx,(%rsp)
 10075fc:	b9 08 00 00 00       	mov    $0x8,%ecx
 1007601:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
 1007605:	e8 df 28 00 00       	callq  1009ee9 <runtime.rnd>
 100760a:	48 89 c3             	mov    %rax,%rbx
			narg = arg + sizeof(String);
 100760d:	48 83 c0 10          	add    $0x10,%rax
 1007611:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
		}
		v = base+arg;
 1007616:	e9 49 fe ff ff       	jmpq   1007464 <vprintf+0x102>
			break;
		case 'D':	// 64-bit
		case 'U':
		case 'X':
		case 'f':
			arg = runtime·rnd(arg, sizeof(uintptr));
 100761b:	89 1c 24             	mov    %ebx,(%rsp)
 100761e:	b9 08 00 00 00       	mov    $0x8,%ecx
 1007623:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
 1007627:	e8 bd 28 00 00       	callq  1009ee9 <runtime.rnd>
 100762c:	48 89 c3             	mov    %rax,%rbx
			narg = arg + 8;
 100762f:	48 83 c0 08          	add    $0x8,%rax
 1007633:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
		}
		v = base+arg;
 1007638:	e9 27 fe ff ff       	jmpq   1007464 <vprintf+0x102>
		case 'f':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + 8;
			break;
		case 'C':
			arg = runtime·rnd(arg, sizeof(uintptr));
 100763d:	89 1c 24             	mov    %ebx,(%rsp)
 1007640:	b9 08 00 00 00       	mov    $0x8,%ecx
 1007645:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
 1007649:	e8 9b 28 00 00       	callq  1009ee9 <runtime.rnd>
 100764e:	48 89 c3             	mov    %rax,%rbx
			narg = arg + 16;
 1007651:	48 83 c0 10          	add    $0x10,%rax
 1007655:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
		}
		v = base+arg;
 100765a:	e9 05 fe ff ff       	jmpq   1007464 <vprintf+0x102>
			break;
		case 'i':	// pointer-aligned but bigger
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
 100765f:	83 f8 58             	cmp    $0x58,%eax
 1007662:	74 b7                	je     100761b <vprintf+0x2b9>
 1007664:	83 f8 61             	cmp    $0x61,%eax
 1007667:	74 2b                	je     1007694 <vprintf+0x332>
 1007669:	83 f8 64             	cmp    $0x64,%eax
 100766c:	0f 85 f2 fd ff ff    	jne    1007464 <vprintf+0x102>
		case 't':
			narg = arg + 1;
			break;
		case 'd':	// 32-bit
		case 'x':
			arg = runtime·rnd(arg, 4);
 1007672:	89 1c 24             	mov    %ebx,(%rsp)
 1007675:	b9 04 00 00 00       	mov    $0x4,%ecx
 100767a:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
 100767e:	e8 66 28 00 00       	callq  1009ee9 <runtime.rnd>
 1007683:	48 89 c3             	mov    %rax,%rbx
			narg = arg + 4;
 1007686:	48 83 c0 04          	add    $0x4,%rax
 100768a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
		}
		v = base+arg;
 100768f:	e9 d0 fd ff ff       	jmpq   1007464 <vprintf+0x102>
		case 'S':	// pointer-aligned but bigger
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(String);
			break;
		case 'a':	// pointer-aligned but bigger
			arg = runtime·rnd(arg, sizeof(uintptr));
 1007694:	89 1c 24             	mov    %ebx,(%rsp)
 1007697:	b9 08 00 00 00       	mov    $0x8,%ecx
 100769c:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
 10076a0:	e8 44 28 00 00       	callq  1009ee9 <runtime.rnd>
 10076a5:	48 89 c3             	mov    %rax,%rbx
			narg = arg + sizeof(Slice);
 10076a8:	48 83 c0 10          	add    $0x10,%rax
 10076ac:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
		}
		v = base+arg;
 10076b1:	e9 ae fd ff ff       	jmpq   1007464 <vprintf+0x102>
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Slice);
			break;
		case 'i':	// pointer-aligned but bigger
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
 10076b6:	89 1c 24             	mov    %ebx,(%rsp)
 10076b9:	b9 08 00 00 00       	mov    $0x8,%ecx
 10076be:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
 10076c2:	e8 22 28 00 00       	callq  1009ee9 <runtime.rnd>
 10076c7:	48 89 c3             	mov    %rax,%rbx
			narg = arg + sizeof(Eface);
 10076ca:	48 83 c0 10          	add    $0x10,%rax
 10076ce:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
			break;
		}
		v = base+arg;
 10076d3:	e9 8c fd ff ff       	jmpq   1007464 <vprintf+0x102>
			break;
		case 'i':	// pointer-aligned but bigger
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
 10076d8:	83 f8 73             	cmp    $0x73,%eax
 10076db:	7f 3b                	jg     1007718 <vprintf+0x3b6>
 10076dd:	74 17                	je     10076f6 <vprintf+0x394>
 10076df:	83 f8 66             	cmp    $0x66,%eax
 10076e2:	0f 84 33 ff ff ff    	je     100761b <vprintf+0x2b9>
 10076e8:	83 f8 69             	cmp    $0x69,%eax
 10076eb:	74 c9                	je     10076b6 <vprintf+0x354>
 10076ed:	83 f8 70             	cmp    $0x70,%eax
 10076f0:	0f 85 6e fd ff ff    	jne    1007464 <vprintf+0x102>
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + 16;
			break;
		case 'p':	// pointer-sized
		case 's':
			arg = runtime·rnd(arg, sizeof(uintptr));
 10076f6:	89 1c 24             	mov    %ebx,(%rsp)
 10076f9:	b9 08 00 00 00       	mov    $0x8,%ecx
 10076fe:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
 1007702:	e8 e2 27 00 00       	callq  1009ee9 <runtime.rnd>
 1007707:	48 89 c3             	mov    %rax,%rbx
			narg = arg + sizeof(uintptr);
 100770a:	48 83 c0 08          	add    $0x8,%rax
 100770e:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
		}
		v = base+arg;
 1007713:	e9 4c fd ff ff       	jmpq   1007464 <vprintf+0x102>
			break;
		case 'i':	// pointer-aligned but bigger
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
 1007718:	83 f8 74             	cmp    $0x74,%eax
 100771b:	74 0e                	je     100772b <vprintf+0x3c9>
 100771d:	83 f8 78             	cmp    $0x78,%eax
 1007720:	0f 85 3e fd ff ff    	jne    1007464 <vprintf+0x102>
		case 't':
			narg = arg + 1;
			break;
		case 'd':	// 32-bit
		case 'x':
			arg = runtime·rnd(arg, 4);
 1007726:	e9 47 ff ff ff       	jmpq   1007672 <vprintf+0x310>
			runtime·write(2, lp, p-lp);
		p++;
		narg = 0;
		switch(*p) {
		case 't':
			narg = arg + 1;
 100772b:	48 89 d8             	mov    %rbx,%rax
 100772e:	48 ff c0             	inc    %rax
 1007731:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		case 'e':
			arg = runtime·rnd(arg, sizeof(uintptr));
			narg = arg + sizeof(Eface);
			break;
		}
		v = base+arg;
 1007736:	e9 29 fd ff ff       	jmpq   1007464 <vprintf+0x102>

000000000100773b <runtime.printbool>:
	runtime·prints("PC=");
	runtime·printhex((uint64)runtime·getcallerpc(p));
}

void
runtime·printbool(bool v)
 100773b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007742:	ff ff 
 1007744:	48 3b 21             	cmp    (%rcx),%rsp
 1007747:	77 05                	ja     100774e <runtime.printbool+0x13>
 1007749:	e8 fe a1 ff ff       	callq  100194c <runtime.morestack8>
 100774e:	48 83 ec 20          	sub    $0x20,%rsp
{
	if(v) {
 1007752:	80 7c 24 28 00       	cmpb   $0x0,0x28(%rsp)
 1007757:	74 25                	je     100777e <runtime.printbool+0x43>
		runtime·write(2, (byte*)"true", 4);
 1007759:	b8 02 00 00 00       	mov    $0x2,%eax
 100775e:	89 04 24             	mov    %eax,(%rsp)
 1007761:	b8 ba 30 02 01       	mov    $0x10230ba,%eax
 1007766:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100776b:	b8 04 00 00 00       	mov    $0x4,%eax
 1007770:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007774:	e8 25 50 00 00       	callq  100c79e <runtime.write>
		return;
 1007779:	48 83 c4 20          	add    $0x20,%rsp
 100777d:	c3                   	retq   
	}
	runtime·write(2, (byte*)"false", 5);
 100777e:	b8 02 00 00 00       	mov    $0x2,%eax
 1007783:	89 04 24             	mov    %eax,(%rsp)
 1007786:	b8 bf 30 02 01       	mov    $0x10230bf,%eax
 100778b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007790:	b8 05 00 00 00       	mov    $0x5,%eax
 1007795:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007799:	e8 00 50 00 00       	callq  100c79e <runtime.write>
 100779e:	48 83 c4 20          	add    $0x20,%rsp
 10077a2:	c3                   	retq   

00000000010077a3 <runtime.printfloat>:
}

void
runtime·printfloat(float64 v)
 10077a3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10077aa:	ff ff 
 10077ac:	48 3b 21             	cmp    (%rcx),%rsp
 10077af:	77 05                	ja     10077b6 <runtime.printfloat+0x13>
 10077b1:	e8 96 a1 ff ff       	callq  100194c <runtime.morestack8>
 10077b6:	48 83 ec 58          	sub    $0x58,%rsp
{
	byte buf[20];
	int32 e, s, i, n;
	float64 h;

	if(runtime·isNaN(v)) {
 10077ba:	f2 0f 10 44 24 60    	movsd  0x60(%rsp),%xmm0
 10077c0:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 10077c5:	e8 d0 a3 ff ff       	callq  1001b9a <runtime.isNaN>
 10077ca:	3c 00                	cmp    $0x0,%al
 10077cc:	74 25                	je     10077f3 <runtime.printfloat+0x50>
		runtime·write(2, "NaN", 3);
 10077ce:	b8 02 00 00 00       	mov    $0x2,%eax
 10077d3:	89 04 24             	mov    %eax,(%rsp)
 10077d6:	b8 c5 30 02 01       	mov    $0x10230c5,%eax
 10077db:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10077e0:	b8 03 00 00 00       	mov    $0x3,%eax
 10077e5:	89 44 24 10          	mov    %eax,0x10(%rsp)
 10077e9:	e8 b0 4f 00 00       	callq  100c79e <runtime.write>
		return;
 10077ee:	48 83 c4 58          	add    $0x58,%rsp
 10077f2:	c3                   	retq   
	}
	if(runtime·isInf(v, 1)) {
 10077f3:	f2 0f 10 44 24 60    	movsd  0x60(%rsp),%xmm0
 10077f9:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 10077fe:	b9 01 00 00 00       	mov    $0x1,%ecx
 1007803:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1007807:	e8 0b a3 ff ff       	callq  1001b17 <runtime.isInf>
 100780c:	3c 00                	cmp    $0x0,%al
 100780e:	74 25                	je     1007835 <runtime.printfloat+0x92>
		runtime·write(2, "+Inf", 4);
 1007810:	b8 02 00 00 00       	mov    $0x2,%eax
 1007815:	89 04 24             	mov    %eax,(%rsp)
 1007818:	b8 c9 30 02 01       	mov    $0x10230c9,%eax
 100781d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007822:	b8 04 00 00 00       	mov    $0x4,%eax
 1007827:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100782b:	e8 6e 4f 00 00       	callq  100c79e <runtime.write>
		return;
 1007830:	48 83 c4 58          	add    $0x58,%rsp
 1007834:	c3                   	retq   
	}
	if(runtime·isInf(v, -1)) {
 1007835:	f2 0f 10 44 24 60    	movsd  0x60(%rsp),%xmm0
 100783b:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 1007840:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 1007845:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1007849:	e8 c9 a2 ff ff       	callq  1001b17 <runtime.isInf>
 100784e:	f2 0f 10 6c 24 60    	movsd  0x60(%rsp),%xmm5
 1007854:	3c 00                	cmp    $0x0,%al
 1007856:	74 25                	je     100787d <runtime.printfloat+0xda>
		runtime·write(2, "-Inf", 4);
 1007858:	b8 02 00 00 00       	mov    $0x2,%eax
 100785d:	89 04 24             	mov    %eax,(%rsp)
 1007860:	b8 ce 30 02 01       	mov    $0x10230ce,%eax
 1007865:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100786a:	b8 04 00 00 00       	mov    $0x4,%eax
 100786f:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007873:	e8 26 4f 00 00       	callq  100c79e <runtime.write>
		return;
 1007878:	48 83 c4 58          	add    $0x58,%rsp
 100787c:	c3                   	retq   
	}

	n = 7;	// digits printed
 100787d:	bd 07 00 00 00       	mov    $0x7,%ebp
	e = 0;	// exp
 1007882:	31 db                	xor    %ebx,%ebx
	s = 0;	// sign
 1007884:	31 d2                	xor    %edx,%edx
	if(v != 0) {
 1007886:	66 0f 57 c0          	xorpd  %xmm0,%xmm0
 100788a:	66 0f 2e e8          	ucomisd %xmm0,%xmm5
 100788e:	0f 84 d5 00 00 00    	je     1007969 <runtime.printfloat+0x1c6>
		// sign
		if(v < 0) {
 1007894:	66 0f 57 c0          	xorpd  %xmm0,%xmm0
 1007898:	66 0f 2e e8          	ucomisd %xmm0,%xmm5
 100789c:	73 11                	jae    10078af <runtime.printfloat+0x10c>
			v = -v;
 100789e:	66 0f 57 c0          	xorpd  %xmm0,%xmm0
 10078a2:	f2 0f 5c c5          	subsd  %xmm5,%xmm0
 10078a6:	f2 0f 10 e8          	movsd  %xmm0,%xmm5
			s = 1;
 10078aa:	ba 01 00 00 00       	mov    $0x1,%edx
		}

		// normalize
		while(v >= 10) {
 10078af:	f2 0f 10 04 25 20 30 	movsd  0x1023020,%xmm0
 10078b6:	02 01 
 10078b8:	66 0f 2e e8          	ucomisd %xmm0,%xmm5
 10078bc:	72 22                	jb     10078e0 <runtime.printfloat+0x13d>
			e++;
 10078be:	ff c3                	inc    %ebx
			v /= 10;
 10078c0:	f2 0f 10 c5          	movsd  %xmm5,%xmm0
 10078c4:	f2 0f 5e 04 25 20 30 	divsd  0x1023020,%xmm0
 10078cb:	02 01 
 10078cd:	f2 0f 10 e8          	movsd  %xmm0,%xmm5
			v = -v;
			s = 1;
		}

		// normalize
		while(v >= 10) {
 10078d1:	f2 0f 10 04 25 20 30 	movsd  0x1023020,%xmm0
 10078d8:	02 01 
 10078da:	66 0f 2e e8          	ucomisd %xmm0,%xmm5
 10078de:	73 de                	jae    10078be <runtime.printfloat+0x11b>
			e++;
			v /= 10;
		}
		while(v < 1) {
 10078e0:	f2 0f 10 04 25 10 30 	movsd  0x1023010,%xmm0
 10078e7:	02 01 
 10078e9:	66 0f 2e e8          	ucomisd %xmm0,%xmm5
 10078ed:	73 22                	jae    1007911 <runtime.printfloat+0x16e>
			e--;
 10078ef:	ff cb                	dec    %ebx
			v *= 10;
 10078f1:	f2 0f 10 c5          	movsd  %xmm5,%xmm0
 10078f5:	f2 0f 59 04 25 20 30 	mulsd  0x1023020,%xmm0
 10078fc:	02 01 
 10078fe:	f2 0f 10 e8          	movsd  %xmm0,%xmm5
		// normalize
		while(v >= 10) {
			e++;
			v /= 10;
		}
		while(v < 1) {
 1007902:	f2 0f 10 04 25 10 30 	movsd  0x1023010,%xmm0
 1007909:	02 01 
 100790b:	66 0f 2e e8          	ucomisd %xmm0,%xmm5
 100790f:	72 de                	jb     10078ef <runtime.printfloat+0x14c>
			e--;
			v *= 10;
		}

		// round
		h = 5;
 1007911:	f2 0f 10 04 25 18 30 	movsd  0x1023018,%xmm0
 1007918:	02 01 
 100791a:	f2 0f 10 f0          	movsd  %xmm0,%xmm6
		for(i=0; i<n; i++)
 100791e:	31 c9                	xor    %ecx,%ecx
 1007920:	39 e9                	cmp    %ebp,%ecx
 1007922:	7d 17                	jge    100793b <runtime.printfloat+0x198>
			h /= 10;
 1007924:	f2 0f 10 c6          	movsd  %xmm6,%xmm0
 1007928:	f2 0f 5e 04 25 20 30 	divsd  0x1023020,%xmm0
 100792f:	02 01 
 1007931:	f2 0f 10 f0          	movsd  %xmm0,%xmm6
			v *= 10;
		}

		// round
		h = 5;
		for(i=0; i<n; i++)
 1007935:	ff c1                	inc    %ecx
 1007937:	39 e9                	cmp    %ebp,%ecx
 1007939:	7c e9                	jl     1007924 <runtime.printfloat+0x181>
			h /= 10;

		v += h;
 100793b:	f2 0f 10 c5          	movsd  %xmm5,%xmm0
 100793f:	f2 0f 58 c6          	addsd  %xmm6,%xmm0
 1007943:	f2 0f 10 e8          	movsd  %xmm0,%xmm5
		if(v >= 10) {
 1007947:	f2 0f 10 04 25 20 30 	movsd  0x1023020,%xmm0
 100794e:	02 01 
 1007950:	66 0f 2e e8          	ucomisd %xmm0,%xmm5
 1007954:	72 13                	jb     1007969 <runtime.printfloat+0x1c6>
			e++;
 1007956:	ff c3                	inc    %ebx
			v /= 10;
 1007958:	f2 0f 10 c5          	movsd  %xmm5,%xmm0
 100795c:	f2 0f 5e 04 25 20 30 	divsd  0x1023020,%xmm0
 1007963:	02 01 
 1007965:	f2 0f 10 e8          	movsd  %xmm0,%xmm5
		}
	}

	// format +d.dddd+edd
	buf[0] = '+';
 1007969:	c6 44 24 44 2b       	movb   $0x2b,0x44(%rsp)
	if(s)
 100796e:	83 fa 00             	cmp    $0x0,%edx
 1007971:	74 05                	je     1007978 <runtime.printfloat+0x1d5>
		buf[0] = '-';
 1007973:	c6 44 24 44 2d       	movb   $0x2d,0x44(%rsp)
	for(i=0; i<n; i++) {
 1007978:	31 f6                	xor    %esi,%esi
 100797a:	39 ee                	cmp    %ebp,%esi
 100797c:	7d 37                	jge    10079b5 <runtime.printfloat+0x212>
		s = v;
 100797e:	f2 0f 2c d5          	cvttsd2si %xmm5,%edx
		buf[i+2] = s+'0';
 1007982:	89 d0                	mov    %edx,%eax
 1007984:	83 c0 30             	add    $0x30,%eax
 1007987:	48 63 ce             	movslq %esi,%rcx
 100798a:	88 44 0c 46          	mov    %al,0x46(%rsp,%rcx,1)
		v -= s;
 100798e:	f2 0f 2a ca          	cvtsi2sd %edx,%xmm1
 1007992:	f2 0f 10 c1          	movsd  %xmm1,%xmm0
 1007996:	f2 0f 10 cd          	movsd  %xmm5,%xmm1
 100799a:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
		v *= 10.;
 100799e:	f2 0f 10 c1          	movsd  %xmm1,%xmm0
 10079a2:	f2 0f 59 04 25 20 30 	mulsd  0x1023020,%xmm0
 10079a9:	02 01 
 10079ab:	f2 0f 10 e8          	movsd  %xmm0,%xmm5

	// format +d.dddd+edd
	buf[0] = '+';
	if(s)
		buf[0] = '-';
	for(i=0; i<n; i++) {
 10079af:	ff c6                	inc    %esi
 10079b1:	39 ee                	cmp    %ebp,%esi
 10079b3:	7c c9                	jl     100797e <runtime.printfloat+0x1db>
		s = v;
		buf[i+2] = s+'0';
		v -= s;
		v *= 10.;
	}
	buf[1] = buf[2];
 10079b5:	0f b6 44 24 46       	movzbl 0x46(%rsp),%eax
 10079ba:	88 44 24 45          	mov    %al,0x45(%rsp)
	buf[2] = '.';
 10079be:	c6 44 24 46 2e       	movb   $0x2e,0x46(%rsp)

	buf[n+2] = 'e';
 10079c3:	48 63 c5             	movslq %ebp,%rax
 10079c6:	c6 44 04 46 65       	movb   $0x65,0x46(%rsp,%rax,1)
	buf[n+3] = '+';
 10079cb:	48 63 c5             	movslq %ebp,%rax
 10079ce:	c6 44 04 47 2b       	movb   $0x2b,0x47(%rsp,%rax,1)
	if(e < 0) {
 10079d3:	83 fb 00             	cmp    $0x0,%ebx
 10079d6:	7d 0a                	jge    10079e2 <runtime.printfloat+0x23f>
		e = -e;
 10079d8:	f7 db                	neg    %ebx
		buf[n+3] = '-';
 10079da:	48 63 c5             	movslq %ebp,%rax
 10079dd:	c6 44 04 47 2d       	movb   $0x2d,0x47(%rsp,%rax,1)
	}

	buf[n+4] = (e/100) + '0';
 10079e2:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
 10079e7:	f7 eb                	imul   %ebx
 10079e9:	89 d8                	mov    %ebx,%eax
 10079eb:	c1 e8 1f             	shr    $0x1f,%eax
 10079ee:	c1 fa 05             	sar    $0x5,%edx
 10079f1:	01 c2                	add    %eax,%edx
 10079f3:	89 d0                	mov    %edx,%eax
 10079f5:	83 c0 30             	add    $0x30,%eax
 10079f8:	48 63 cd             	movslq %ebp,%rcx
 10079fb:	88 44 0c 48          	mov    %al,0x48(%rsp,%rcx,1)
	buf[n+5] = (e/10)%10 + '0';
 10079ff:	b8 67 66 66 66       	mov    $0x66666667,%eax
 1007a04:	f7 eb                	imul   %ebx
 1007a06:	89 d8                	mov    %ebx,%eax
 1007a08:	c1 e8 1f             	shr    $0x1f,%eax
 1007a0b:	c1 fa 02             	sar    $0x2,%edx
 1007a0e:	01 c2                	add    %eax,%edx
 1007a10:	89 d0                	mov    %edx,%eax
 1007a12:	99                   	cltd   
 1007a13:	c7 44 24 1c 0a 00 00 	movl   $0xa,0x1c(%rsp)
 1007a1a:	00 
 1007a1b:	f7 7c 24 1c          	idivl  0x1c(%rsp)
 1007a1f:	89 d0                	mov    %edx,%eax
 1007a21:	83 c0 30             	add    $0x30,%eax
 1007a24:	48 63 cd             	movslq %ebp,%rcx
 1007a27:	88 44 0c 49          	mov    %al,0x49(%rsp,%rcx,1)
	buf[n+6] = (e%10) + '0';
 1007a2b:	89 d8                	mov    %ebx,%eax
 1007a2d:	99                   	cltd   
 1007a2e:	c7 44 24 1c 0a 00 00 	movl   $0xa,0x1c(%rsp)
 1007a35:	00 
 1007a36:	f7 7c 24 1c          	idivl  0x1c(%rsp)
 1007a3a:	89 d0                	mov    %edx,%eax
 1007a3c:	83 c0 30             	add    $0x30,%eax
 1007a3f:	48 63 cd             	movslq %ebp,%rcx
 1007a42:	88 44 0c 4a          	mov    %al,0x4a(%rsp,%rcx,1)
	runtime·write(2, buf, n+7);
 1007a46:	b8 02 00 00 00       	mov    $0x2,%eax
 1007a4b:	89 04 24             	mov    %eax,(%rsp)
 1007a4e:	48 8d 44 24 44       	lea    0x44(%rsp),%rax
 1007a53:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007a58:	89 e8                	mov    %ebp,%eax
 1007a5a:	83 c0 07             	add    $0x7,%eax
 1007a5d:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007a61:	e8 38 4d 00 00       	callq  100c79e <runtime.write>
 1007a66:	48 83 c4 58          	add    $0x58,%rsp
 1007a6a:	c3                   	retq   

0000000001007a6b <runtime.printcomplex>:
}

void
runtime·printcomplex(Complex128 v)
 1007a6b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007a72:	ff ff 
 1007a74:	48 3b 21             	cmp    (%rcx),%rsp
 1007a77:	77 05                	ja     1007a7e <runtime.printcomplex+0x13>
 1007a79:	e8 d7 9e ff ff       	callq  1001955 <runtime.morestack16>
 1007a7e:	48 83 ec 20          	sub    $0x20,%rsp
{
	runtime·write(2, "(", 1);
 1007a82:	b8 02 00 00 00       	mov    $0x2,%eax
 1007a87:	89 04 24             	mov    %eax,(%rsp)
 1007a8a:	b8 d3 30 02 01       	mov    $0x10230d3,%eax
 1007a8f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007a94:	b8 01 00 00 00       	mov    $0x1,%eax
 1007a99:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007a9d:	e8 fc 4c 00 00       	callq  100c79e <runtime.write>
	runtime·printfloat(v.real);
 1007aa2:	f2 0f 10 44 24 28    	movsd  0x28(%rsp),%xmm0
 1007aa8:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 1007aad:	e8 f1 fc ff ff       	callq  10077a3 <runtime.printfloat>
	runtime·printfloat(v.imag);
 1007ab2:	f2 0f 10 44 24 30    	movsd  0x30(%rsp),%xmm0
 1007ab8:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
 1007abd:	e8 e1 fc ff ff       	callq  10077a3 <runtime.printfloat>
	runtime·write(2, "i)", 2);
 1007ac2:	b8 02 00 00 00       	mov    $0x2,%eax
 1007ac7:	89 04 24             	mov    %eax,(%rsp)
 1007aca:	b8 d5 30 02 01       	mov    $0x10230d5,%eax
 1007acf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007ad4:	b8 02 00 00 00       	mov    $0x2,%eax
 1007ad9:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007add:	e8 bc 4c 00 00       	callq  100c79e <runtime.write>
 1007ae2:	48 83 c4 20          	add    $0x20,%rsp
 1007ae6:	c3                   	retq   

0000000001007ae7 <runtime.printuint>:
}

void
runtime·printuint(uint64 v)
 1007ae7:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007aee:	ff ff 
 1007af0:	48 8d 44 24 f0       	lea    -0x10(%rsp),%rax
 1007af5:	48 3b 01             	cmp    (%rcx),%rax
 1007af8:	77 05                	ja     1007aff <runtime.printuint+0x18>
 1007afa:	e8 4d 9e ff ff       	callq  100194c <runtime.morestack8>
 1007aff:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
 1007b06:	48 8b 9c 24 98 00 00 	mov    0x98(%rsp),%rbx
 1007b0d:	00 
{
	byte buf[100];
	int32 i;

	for(i=nelem(buf)-1; i>0; i--) {
 1007b0e:	bd 63 00 00 00       	mov    $0x63,%ebp
 1007b13:	83 fd 00             	cmp    $0x0,%ebp
 1007b16:	7e 27                	jle    1007b3f <runtime.printuint+0x58>
		buf[i] = v%10 + '0';
 1007b18:	48 89 d8             	mov    %rbx,%rax
 1007b1b:	31 d2                	xor    %edx,%edx
 1007b1d:	48 c7 44 24 18 0a 00 	movq   $0xa,0x18(%rsp)
 1007b24:	00 00 
 1007b26:	48 f7 74 24 18       	divq   0x18(%rsp)
 1007b2b:	48 89 d0             	mov    %rdx,%rax
 1007b2e:	48 83 c0 30          	add    $0x30,%rax
 1007b32:	48 63 cd             	movslq %ebp,%rcx
 1007b35:	88 44 0c 2c          	mov    %al,0x2c(%rsp,%rcx,1)
		if(v < 10)
 1007b39:	48 83 fb 0a          	cmp    $0xa,%rbx
 1007b3d:	73 2d                	jae    1007b6c <runtime.printuint+0x85>
			break;
		v = v/10;
	}
	runtime·write(2, buf+i, nelem(buf)-i);
 1007b3f:	b8 02 00 00 00       	mov    $0x2,%eax
 1007b44:	89 04 24             	mov    %eax,(%rsp)
 1007b47:	48 63 cd             	movslq %ebp,%rcx
 1007b4a:	48 8d 44 0c 2c       	lea    0x2c(%rsp,%rcx,1),%rax
 1007b4f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007b54:	b8 64 00 00 00       	mov    $0x64,%eax
 1007b59:	29 e8                	sub    %ebp,%eax
 1007b5b:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007b5f:	e8 3a 4c 00 00       	callq  100c79e <runtime.write>
 1007b64:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
 1007b6b:	c3                   	retq   

	for(i=nelem(buf)-1; i>0; i--) {
		buf[i] = v%10 + '0';
		if(v < 10)
			break;
		v = v/10;
 1007b6c:	48 89 d8             	mov    %rbx,%rax
 1007b6f:	31 d2                	xor    %edx,%edx
 1007b71:	48 c7 44 24 18 0a 00 	movq   $0xa,0x18(%rsp)
 1007b78:	00 00 
 1007b7a:	48 f7 74 24 18       	divq   0x18(%rsp)
 1007b7f:	48 89 c3             	mov    %rax,%rbx
runtime·printuint(uint64 v)
{
	byte buf[100];
	int32 i;

	for(i=nelem(buf)-1; i>0; i--) {
 1007b82:	ff cd                	dec    %ebp
 1007b84:	eb 8d                	jmp    1007b13 <runtime.printuint+0x2c>

0000000001007b86 <runtime.printint>:
	}
	runtime·write(2, buf+i, nelem(buf)-i);
}

void
runtime·printint(int64 v)
 1007b86:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007b8d:	ff ff 
 1007b8f:	48 3b 21             	cmp    (%rcx),%rsp
 1007b92:	77 05                	ja     1007b99 <runtime.printint+0x13>
 1007b94:	e8 b3 9d ff ff       	callq  100194c <runtime.morestack8>
 1007b99:	48 83 ec 20          	sub    $0x20,%rsp
 1007b9d:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
{
	if(v < 0) {
 1007ba2:	48 83 f9 00          	cmp    $0x0,%rcx
 1007ba6:	7d 28                	jge    1007bd0 <runtime.printint+0x4a>
		runtime·write(2, "-", 1);
 1007ba8:	b8 02 00 00 00       	mov    $0x2,%eax
 1007bad:	89 04 24             	mov    %eax,(%rsp)
 1007bb0:	b8 d8 30 02 01       	mov    $0x10230d8,%eax
 1007bb5:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007bba:	b8 01 00 00 00       	mov    $0x1,%eax
 1007bbf:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007bc3:	e8 d6 4b 00 00       	callq  100c79e <runtime.write>
		v = -v;
 1007bc8:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 1007bcd:	48 f7 d9             	neg    %rcx
	}
	runtime·printuint(v);
 1007bd0:	48 89 0c 24          	mov    %rcx,(%rsp)
 1007bd4:	e8 0e ff ff ff       	callq  1007ae7 <runtime.printuint>
 1007bd9:	48 83 c4 20          	add    $0x20,%rsp
 1007bdd:	c3                   	retq   

0000000001007bde <runtime.printhex>:
}

void
runtime·printhex(uint64 v)
 1007bde:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007be5:	ff ff 
 1007be7:	48 8d 44 24 f0       	lea    -0x10(%rsp),%rax
 1007bec:	48 3b 01             	cmp    (%rcx),%rax
 1007bef:	77 05                	ja     1007bf6 <runtime.printhex+0x18>
 1007bf1:	e8 56 9d ff ff       	callq  100194c <runtime.morestack8>
 1007bf6:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
 1007bfd:	48 8b 3c 25 28 30 02 	mov    0x1023028,%rdi
 1007c04:	01 
 1007c05:	48 8b b4 24 98 00 00 	mov    0x98(%rsp),%rsi
 1007c0c:	00 
{
	static int8 *dig = "0123456789abcdef";
	byte buf[100];
	int32 i;

	i=nelem(buf);
 1007c0d:	bd 64 00 00 00       	mov    $0x64,%ebp
	for(; v>0; v/=16)
 1007c12:	48 83 fe 00          	cmp    $0x0,%rsi
 1007c16:	76 24                	jbe    1007c3c <runtime.printhex+0x5e>
		buf[--i] = dig[v%16];
 1007c18:	ff cd                	dec    %ebp
 1007c1a:	48 63 c5             	movslq %ebp,%rax
 1007c1d:	48 8d 4c 24 2c       	lea    0x2c(%rsp),%rcx
 1007c22:	48 01 c8             	add    %rcx,%rax
 1007c25:	48 89 f2             	mov    %rsi,%rdx
 1007c28:	48 83 e2 0f          	and    $0xf,%rdx
 1007c2c:	0f b6 0c 17          	movzbl (%rdi,%rdx,1),%ecx
 1007c30:	88 08                	mov    %cl,(%rax)
	static int8 *dig = "0123456789abcdef";
	byte buf[100];
	int32 i;

	i=nelem(buf);
	for(; v>0; v/=16)
 1007c32:	48 c1 ee 04          	shr    $0x4,%rsi
 1007c36:	48 83 fe 00          	cmp    $0x0,%rsi
 1007c3a:	77 dc                	ja     1007c18 <runtime.printhex+0x3a>
		buf[--i] = dig[v%16];
	if(i == nelem(buf))
 1007c3c:	83 fd 64             	cmp    $0x64,%ebp
 1007c3f:	75 10                	jne    1007c51 <runtime.printhex+0x73>
		buf[--i] = '0';
 1007c41:	ff cd                	dec    %ebp
 1007c43:	48 63 c5             	movslq %ebp,%rax
 1007c46:	48 8d 4c 24 2c       	lea    0x2c(%rsp),%rcx
 1007c4b:	48 01 c8             	add    %rcx,%rax
 1007c4e:	c6 00 30             	movb   $0x30,(%rax)
	buf[--i] = 'x';
 1007c51:	ff cd                	dec    %ebp
 1007c53:	48 63 c5             	movslq %ebp,%rax
 1007c56:	48 8d 4c 24 2c       	lea    0x2c(%rsp),%rcx
 1007c5b:	48 01 c8             	add    %rcx,%rax
 1007c5e:	c6 00 78             	movb   $0x78,(%rax)
	buf[--i] = '0';
 1007c61:	ff cd                	dec    %ebp
 1007c63:	48 63 c5             	movslq %ebp,%rax
 1007c66:	48 8d 4c 24 2c       	lea    0x2c(%rsp),%rcx
 1007c6b:	48 01 c8             	add    %rcx,%rax
 1007c6e:	c6 00 30             	movb   $0x30,(%rax)
	runtime·write(2, buf+i, nelem(buf)-i);
 1007c71:	b8 02 00 00 00       	mov    $0x2,%eax
 1007c76:	89 04 24             	mov    %eax,(%rsp)
 1007c79:	48 63 cd             	movslq %ebp,%rcx
 1007c7c:	48 8d 44 0c 2c       	lea    0x2c(%rsp,%rcx,1),%rax
 1007c81:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007c86:	b8 64 00 00 00       	mov    $0x64,%eax
 1007c8b:	29 e8                	sub    %ebp,%eax
 1007c8d:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007c91:	e8 08 4b 00 00       	callq  100c79e <runtime.write>
 1007c96:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
 1007c9d:	c3                   	retq   

0000000001007c9e <runtime.printpointer>:
}

void
runtime·printpointer(void *p)
 1007c9e:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007ca5:	ff ff 
 1007ca7:	48 3b 21             	cmp    (%rcx),%rsp
 1007caa:	77 05                	ja     1007cb1 <runtime.printpointer+0x13>
 1007cac:	e8 9b 9c ff ff       	callq  100194c <runtime.morestack8>
 1007cb1:	48 83 ec 10          	sub    $0x10,%rsp
{
	runtime·printhex((uint64)p);
 1007cb5:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 1007cba:	48 89 04 24          	mov    %rax,(%rsp)
 1007cbe:	e8 1b ff ff ff       	callq  1007bde <runtime.printhex>
 1007cc3:	48 83 c4 10          	add    $0x10,%rsp
 1007cc7:	c3                   	retq   

0000000001007cc8 <runtime.printstring>:
}

void
runtime·printstring(String v)
 1007cc8:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007ccf:	ff ff 
 1007cd1:	48 3b 21             	cmp    (%rcx),%rsp
 1007cd4:	77 05                	ja     1007cdb <runtime.printstring+0x13>
 1007cd6:	e8 7a 9c ff ff       	callq  1001955 <runtime.morestack16>
 1007cdb:	48 83 ec 20          	sub    $0x20,%rsp
{
	extern uint32 runtime·maxstring;

	if(v.len > runtime·maxstring) {
 1007cdf:	8b 44 24 30          	mov    0x30(%rsp),%eax
 1007ce3:	3b 04 25 0c 30 02 01 	cmp    0x102300c,%eax
 1007cea:	76 25                	jbe    1007d11 <runtime.printstring+0x49>
		runtime·write(2, "[invalid string]", 16);
 1007cec:	b8 02 00 00 00       	mov    $0x2,%eax
 1007cf1:	89 04 24             	mov    %eax,(%rsp)
 1007cf4:	b8 eb 30 02 01       	mov    $0x10230eb,%eax
 1007cf9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007cfe:	b8 10 00 00 00       	mov    $0x10,%eax
 1007d03:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007d07:	e8 92 4a 00 00       	callq  100c79e <runtime.write>
		return;
 1007d0c:	48 83 c4 20          	add    $0x20,%rsp
 1007d10:	c3                   	retq   
	}
	if(v.len > 0)
 1007d11:	83 7c 24 30 00       	cmpl   $0x0,0x30(%rsp)
 1007d16:	7e 1f                	jle    1007d37 <runtime.printstring+0x6f>
		runtime·write(2, v.str, v.len);
 1007d18:	b8 02 00 00 00       	mov    $0x2,%eax
 1007d1d:	89 04 24             	mov    %eax,(%rsp)
 1007d20:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1007d25:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007d2a:	8b 44 24 30          	mov    0x30(%rsp),%eax
 1007d2e:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1007d32:	e8 67 4a 00 00       	callq  100c79e <runtime.write>
 1007d37:	48 83 c4 20          	add    $0x20,%rsp
 1007d3b:	c3                   	retq   

0000000001007d3c <runtime.typestring>:
{
	runtime·write(2, "\n", 1);
}

void
runtime·typestring(Eface e, String s)
 1007d3c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007d43:	ff ff 
 1007d45:	48 3b 21             	cmp    (%rcx),%rsp
 1007d48:	77 05                	ja     1007d4f <runtime.typestring+0x13>
 1007d4a:	e8 18 9c ff ff       	callq  1001967 <runtime.morestack32>
{
	s = *e.type->string;
 1007d4f:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
 1007d54:	48 8b 49 20          	mov    0x20(%rcx),%rcx
 1007d58:	48 8b 01             	mov    (%rcx),%rax
 1007d5b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1007d60:	48 8b 41 08          	mov    0x8(%rcx),%rax
 1007d64:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1007d69:	c3                   	retq   

0000000001007d6a <setmcpumax>:
static void readylocked(G*);	// ready, but sched is locked
static void mnextg(M*, G*);
static void mcommoninit(M*);

void
setmcpumax(uint32 n)
 1007d6a:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007d71:	ff ff 
 1007d73:	48 3b 21             	cmp    (%rcx),%rsp
 1007d76:	77 05                	ja     1007d7d <setmcpumax+0x13>
 1007d78:	e8 cf 9b ff ff       	callq  100194c <runtime.morestack8>
 1007d7d:	48 83 ec 28          	sub    $0x28,%rsp
{
	uint32 v, w;

	for(;;) {
		v = runtime·sched.atomic;
 1007d81:	8b 1c 25 f8 4f 02 01 	mov    0x1024ff8,%ebx
		w = v;
 1007d88:	89 da                	mov    %ebx,%edx
		w &= ~(mcpuMask<<mcpumaxShift);
 1007d8a:	81 e2 ff 7f 00 c0    	and    $0xc0007fff,%edx
		w |= n<<mcpumaxShift;
 1007d90:	8b 44 24 30          	mov    0x30(%rsp),%eax
 1007d94:	c1 e0 0f             	shl    $0xf,%eax
 1007d97:	09 c2                	or     %eax,%edx
		if(runtime·cas(&runtime·sched.atomic, v, w))
 1007d99:	b9 f8 4f 02 01       	mov    $0x1024ff8,%ecx
 1007d9e:	48 89 0c 24          	mov    %rcx,(%rsp)
 1007da2:	89 5c 24 08          	mov    %ebx,0x8(%rsp)
 1007da6:	89 54 24 0c          	mov    %edx,0xc(%rsp)
 1007daa:	e8 ec 9b ff ff       	callq  100199b <runtime.cas>
 1007daf:	80 f8 00             	cmp    $0x0,%al
 1007db2:	74 cd                	je     1007d81 <setmcpumax+0x17>
			break;
 1007db4:	48 83 c4 28          	add    $0x28,%rsp
 1007db8:	c3                   	retq   

0000000001007db9 <runtime.schedinit>:
//
//	call main·init_function
//	call initdone
//	call main·main
void
runtime·schedinit(void)
 1007db9:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007dc0:	ff ff 
 1007dc2:	48 3b 21             	cmp    (%rcx),%rsp
 1007dc5:	77 05                	ja     1007dcc <runtime.schedinit+0x13>
 1007dc7:	e8 27 9b ff ff       	callq  10018f3 <runtime.morestack00>
 1007dcc:	48 83 ec 28          	sub    $0x28,%rsp
{
	int32 n;
	byte *p;

	m->nomemprof++;
 1007dd0:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1007dd7:	ff ff 
 1007dd9:	ff 80 88 00 00 00    	incl   0x88(%rax)
	runtime·mallocinit();
 1007ddf:	e8 88 b1 ff ff       	callq  1002f6c <runtime.mallocinit>
	mcommoninit(m);
 1007de4:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1007deb:	ff ff 
 1007ded:	48 89 04 24          	mov    %rax,(%rsp)
 1007df1:	e8 12 02 00 00       	callq  1008008 <mcommoninit>

	runtime·goargs();
 1007df6:	e8 5b 21 00 00       	callq  1009f56 <runtime.goargs>
	runtime·goenvs();
 1007dfb:	e8 2f 52 00 00       	callq  100d02f <runtime.goenvs>
	// For debugging:
	// Allocate internal symbol table representation now,
	// so that we don't need to call malloc when we crash.
	// runtime·findfunc(0);

	runtime·gomaxprocs = 1;
 1007e00:	c7 04 25 18 4e 02 01 	movl   $0x1,0x1024e18
 1007e07:	01 00 00 00 
	p = runtime·getenv("GOMAXPROCS");
 1007e0b:	b9 d0 45 02 01       	mov    $0x10245d0,%ecx
 1007e10:	48 89 0c 24          	mov    %rcx,(%rsp)
 1007e14:	e8 b8 22 00 00       	callq  100a0d1 <runtime.getenv>
	if(p != nil && (n = runtime·atoi(p)) != 0) {
 1007e19:	48 83 f8 00          	cmp    $0x0,%rax
 1007e1d:	74 10                	je     1007e2f <runtime.schedinit+0x76>
 1007e1f:	48 89 04 24          	mov    %rax,(%rsp)
 1007e23:	e8 54 23 00 00       	callq  100a17c <runtime.atoi>
 1007e28:	89 c1                	mov    %eax,%ecx
 1007e2a:	83 f8 00             	cmp    $0x0,%eax
 1007e2d:	75 48                	jne    1007e77 <runtime.schedinit+0xbe>
		if(n > maxgomaxprocs)
			n = maxgomaxprocs;
		runtime·gomaxprocs = n;
	}
	setmcpumax(runtime·gomaxprocs);
 1007e2f:	8b 04 25 18 4e 02 01 	mov    0x1024e18,%eax
 1007e36:	89 04 24             	mov    %eax,(%rsp)
 1007e39:	e8 2c ff ff ff       	callq  1007d6a <setmcpumax>
	runtime·singleproc = runtime·gomaxprocs == 1;
 1007e3e:	83 3c 25 18 4e 02 01 	cmpl   $0x1,0x1024e18
 1007e45:	01 
 1007e46:	75 2b                	jne    1007e73 <runtime.schedinit+0xba>
 1007e48:	b8 01 00 00 00       	mov    $0x1,%eax
 1007e4d:	88 04 25 e3 4d 02 01 	mov    %al,0x1024de3
	runtime·sched.predawn = 1;
 1007e54:	c7 04 25 fc 4f 02 01 	movl   $0x1,0x1024ffc
 1007e5b:	01 00 00 00 

	m->nomemprof--;
 1007e5f:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1007e66:	ff ff 
 1007e68:	ff 88 88 00 00 00    	decl   0x88(%rax)
 1007e6e:	48 83 c4 28          	add    $0x28,%rsp
 1007e72:	c3                   	retq   
		if(n > maxgomaxprocs)
			n = maxgomaxprocs;
		runtime·gomaxprocs = n;
	}
	setmcpumax(runtime·gomaxprocs);
	runtime·singleproc = runtime·gomaxprocs == 1;
 1007e73:	31 c0                	xor    %eax,%eax
 1007e75:	eb d6                	jmp    1007e4d <runtime.schedinit+0x94>
	// runtime·findfunc(0);

	runtime·gomaxprocs = 1;
	p = runtime·getenv("GOMAXPROCS");
	if(p != nil && (n = runtime·atoi(p)) != 0) {
		if(n > maxgomaxprocs)
 1007e77:	3d f5 7f 00 00       	cmp    $0x7ff5,%eax
 1007e7c:	7e 05                	jle    1007e83 <runtime.schedinit+0xca>
			n = maxgomaxprocs;
 1007e7e:	b9 f5 7f 00 00       	mov    $0x7ff5,%ecx
		runtime·gomaxprocs = n;
 1007e83:	89 0c 25 18 4e 02 01 	mov    %ecx,0x1024e18
	}
	setmcpumax(runtime·gomaxprocs);
 1007e8a:	eb a3                	jmp    1007e2f <runtime.schedinit+0x76>

0000000001007e8c <schedlock>:
	m->nomemprof--;
}

// Lock the scheduler.
static void
schedlock(void)
 1007e8c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007e93:	ff ff 
 1007e95:	48 3b 21             	cmp    (%rcx),%rsp
 1007e98:	77 05                	ja     1007e9f <schedlock+0x13>
 1007e9a:	e8 54 9a ff ff       	callq  10018f3 <runtime.morestack00>
 1007e9f:	48 83 ec 10          	sub    $0x10,%rsp
{
	runtime·lock(&runtime·sched);
 1007ea3:	b8 b0 4f 02 01       	mov    $0x1024fb0,%eax
 1007ea8:	48 89 04 24          	mov    %rax,(%rsp)
 1007eac:	e8 7f 4f 00 00       	callq  100ce30 <runtime.lock>
 1007eb1:	48 83 c4 10          	add    $0x10,%rsp
 1007eb5:	c3                   	retq   

0000000001007eb6 <schedunlock>:
}

// Unlock the scheduler.
static void
schedunlock(void)
 1007eb6:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007ebd:	ff ff 
 1007ebf:	48 3b 21             	cmp    (%rcx),%rsp
 1007ec2:	77 05                	ja     1007ec9 <schedunlock+0x13>
 1007ec4:	e8 2a 9a ff ff       	callq  10018f3 <runtime.morestack00>
 1007ec9:	48 83 ec 20          	sub    $0x20,%rsp
{
	M *m;

	m = mwakeup;
 1007ecd:	48 8b 04 25 a8 4e 02 	mov    0x1024ea8,%rax
 1007ed4:	01 
 1007ed5:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
	mwakeup = nil;
 1007eda:	48 c7 04 25 a8 4e 02 	movq   $0x0,0x1024ea8
 1007ee1:	01 00 00 00 00 
	runtime·unlock(&runtime·sched);
 1007ee6:	b8 b0 4f 02 01       	mov    $0x1024fb0,%eax
 1007eeb:	48 89 04 24          	mov    %rax,(%rsp)
 1007eef:	e8 8e 4f 00 00       	callq  100ce82 <runtime.unlock>
 1007ef4:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
	if(m != nil)
 1007ef9:	48 83 f9 00          	cmp    $0x0,%rcx
 1007efd:	74 12                	je     1007f11 <schedunlock+0x5b>
		runtime·notewakeup(&m->havenextg);
 1007eff:	48 89 c8             	mov    %rcx,%rax
 1007f02:	48 05 a8 00 00 00    	add    $0xa8,%rax
 1007f08:	48 89 04 24          	mov    %rax,(%rsp)
 1007f0c:	e8 e2 4f 00 00       	callq  100cef3 <runtime.notewakeup>
 1007f11:	48 83 c4 20          	add    $0x20,%rsp
 1007f15:	c3                   	retq   

0000000001007f16 <runtime.initdone>:
}

// Called after main·init_function; main·main will be called on return.
void
runtime·initdone(void)
 1007f16:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007f1d:	ff ff 
 1007f1f:	48 3b 21             	cmp    (%rcx),%rsp
 1007f22:	77 05                	ja     1007f29 <runtime.initdone+0x13>
 1007f24:	e8 ca 99 ff ff       	callq  10018f3 <runtime.morestack00>
{
	// Let's go.
	runtime·sched.predawn = 0;
 1007f29:	c7 04 25 fc 4f 02 01 	movl   $0x0,0x1024ffc
 1007f30:	00 00 00 00 
	mstats.enablegc = 1;
 1007f34:	c6 04 25 fc 6a 02 01 	movb   $0x1,0x1026afc
 1007f3b:	01 

	// If main·init_function started other goroutines,
	// kick off new m's to handle them, like ready
	// would have, had it not been pre-dawn.
	schedlock();
 1007f3c:	e8 4b ff ff ff       	callq  1007e8c <schedlock>
	matchmg();
 1007f41:	e8 b3 0a 00 00       	callq  10089f9 <matchmg>
	schedunlock();
 1007f46:	e8 6b ff ff ff       	callq  1007eb6 <schedunlock>
 1007f4b:	c3                   	retq   

0000000001007f4c <runtime.goexit>:
}

void
runtime·goexit(void)
 1007f4c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007f53:	ff ff 
 1007f55:	48 3b 21             	cmp    (%rcx),%rsp
 1007f58:	77 05                	ja     1007f5f <runtime.goexit+0x13>
 1007f5a:	e8 94 99 ff ff       	callq  10018f3 <runtime.morestack00>
{
	g->status = Gmoribund;
 1007f5f:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1007f66:	ff ff 
 1007f68:	66 c7 40 70 05 00    	movw   $0x5,0x70(%rax)
	runtime·gosched();
 1007f6e:	e8 3d 0e 00 00       	callq  1008db0 <runtime.gosched>
 1007f73:	c3                   	retq   

0000000001007f74 <runtime.tracebackothers>:
}

void
runtime·tracebackothers(G *me)
 1007f74:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1007f7b:	ff ff 
 1007f7d:	48 3b 21             	cmp    (%rcx),%rsp
 1007f80:	77 05                	ja     1007f87 <runtime.tracebackothers+0x13>
 1007f82:	e8 c5 99 ff ff       	callq  100194c <runtime.morestack8>
 1007f87:	48 83 ec 38          	sub    $0x38,%rsp
{
	G *g;

	for(g = runtime·allg; g != nil; g = g->alllink) {
 1007f8b:	48 8b 0c 25 d8 4e 02 	mov    0x1024ed8,%rcx
 1007f92:	01 
 1007f93:	48 83 f9 00          	cmp    $0x0,%rcx
 1007f97:	74 6a                	je     1008003 <runtime.tracebackothers+0x8f>
		if(g == me || g->status == Gdead)
 1007f99:	48 3b 4c 24 40       	cmp    0x40(%rsp),%rcx
 1007f9e:	74 59                	je     1007ff9 <runtime.tracebackothers+0x85>
 1007fa0:	0f bf 41 70          	movswl 0x70(%rcx),%eax
 1007fa4:	83 f8 06             	cmp    $0x6,%eax
 1007fa7:	74 50                	je     1007ff9 <runtime.tracebackothers+0x85>
			continue;
		runtime·printf("\ngoroutine %d [%d]:\n", g->goid, g->status);
 1007fa9:	b8 db 45 02 01       	mov    $0x10245db,%eax
 1007fae:	48 89 04 24          	mov    %rax,(%rsp)
 1007fb2:	8b 41 74             	mov    0x74(%rcx),%eax
 1007fb5:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1007fb9:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
 1007fbe:	0f bf 41 70          	movswl 0x70(%rcx),%eax
 1007fc2:	89 44 24 0c          	mov    %eax,0xc(%rsp)
 1007fc6:	e8 73 f3 ff ff       	callq  100733e <runtime.printf>
 1007fcb:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
		runtime·traceback(g->sched.pc, g->sched.sp, 0, g);
 1007fd0:	48 8b 41 28          	mov    0x28(%rcx),%rax
 1007fd4:	48 89 04 24          	mov    %rax,(%rsp)
 1007fd8:	48 8b 41 20          	mov    0x20(%rcx),%rax
 1007fdc:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1007fe1:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 1007fe8:	00 00 
 1007fea:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 1007fef:	e8 f1 59 00 00       	callq  100d9e5 <runtime.traceback>
 1007ff4:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
void
runtime·tracebackothers(G *me)
{
	G *g;

	for(g = runtime·allg; g != nil; g = g->alllink) {
 1007ff9:	48 8b 49 60          	mov    0x60(%rcx),%rcx
 1007ffd:	48 83 f9 00          	cmp    $0x0,%rcx
 1008001:	75 96                	jne    1007f99 <runtime.tracebackothers+0x25>
		if(g == me || g->status == Gdead)
			continue;
		runtime·printf("\ngoroutine %d [%d]:\n", g->goid, g->status);
		runtime·traceback(g->sched.pc, g->sched.sp, 0, g);
 1008003:	48 83 c4 38          	add    $0x38,%rsp
 1008007:	c3                   	retq   

0000000001008008 <mcommoninit>:
		runtime·throw("g is already an idle goroutine");
	g->idlem = m;
}

static void
mcommoninit(M *m)
 1008008:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100800f:	ff ff 
 1008011:	48 3b 21             	cmp    (%rcx),%rsp
 1008014:	77 05                	ja     100801b <mcommoninit+0x13>
 1008016:	e8 31 99 ff ff       	callq  100194c <runtime.morestack8>
 100801b:	48 83 ec 30          	sub    $0x30,%rsp
 100801f:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
{
	// Add to runtime·allm so garbage collector doesn't free m
	// when it is just in a register or thread-local storage.
	m->alllink = runtime·allm;
 1008024:	48 8b 0c 25 e0 4e 02 	mov    0x1024ee0,%rcx
 100802b:	01 
 100802c:	48 89 8a c0 00 00 00 	mov    %rcx,0xc0(%rdx)
	// runtime·Cgocalls() iterates over allm w/o schedlock,
	// so we need to publish it safely.
	runtime·atomicstorep(&runtime·allm, m);
 1008033:	b8 e0 4e 02 01       	mov    $0x1024ee0,%eax
 1008038:	48 89 04 24          	mov    %rax,(%rsp)
 100803c:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 1008041:	e8 ba 99 ff ff       	callq  1001a00 <runtime.atomicstorep>
 1008046:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx

	m->id = runtime·sched.mcount++;
 100804b:	8b 0c 25 f4 4f 02 01 	mov    0x1024ff4,%ecx
 1008052:	ff 04 25 f4 4f 02 01 	incl   0x1024ff4
 1008059:	89 4a 78             	mov    %ecx,0x78(%rdx)
	m->fastrand = 0x49f6428aUL + m->id;
 100805c:	8b 4a 78             	mov    0x78(%rdx),%ecx
 100805f:	81 c1 8a 42 f6 49    	add    $0x49f6428a,%ecx
 1008065:	89 8a 98 00 00 00    	mov    %ecx,0x98(%rdx)
	m->stackalloc = runtime·malloc(sizeof(*m->stackalloc));
 100806b:	48 c7 c1 48 00 00 00 	mov    $0x48,%rcx
 1008072:	48 89 0c 24          	mov    %rcx,(%rsp)
 1008076:	e8 10 aa ff ff       	callq  1002a8b <runtime.malloc>
 100807b:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 1008080:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	runtime·FixAlloc_Init(m->stackalloc, FixedStack, runtime·SysAlloc, nil, nil);
 1008087:	48 8b 82 e0 00 00 00 	mov    0xe0(%rdx),%rax
 100808e:	48 89 04 24          	mov    %rax,(%rsp)
 1008092:	48 c7 c0 00 10 00 00 	mov    $0x1000,%rax
 1008099:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100809e:	b8 99 3c 00 01       	mov    $0x1003c99,%eax
 10080a3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 10080a8:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
 10080af:	00 00 
 10080b1:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
 10080b8:	00 00 
 10080ba:	e8 69 c0 ff ff       	callq  1004128 <runtime.FixAlloc_Init>
 10080bf:	48 83 c4 30          	add    $0x30,%rsp
 10080c3:	c3                   	retq   

00000000010080c4 <canaddmcpu>:
}

// Try to increment mcpu.  Report whether succeeded.
static bool
canaddmcpu(void)
 10080c4:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10080cb:	ff ff 
 10080cd:	48 3b 21             	cmp    (%rcx),%rsp
 10080d0:	77 05                	ja     10080d7 <canaddmcpu+0x13>
 10080d2:	e8 1c 98 ff ff       	callq  10018f3 <runtime.morestack00>
 10080d7:	48 83 ec 28          	sub    $0x28,%rsp
{
	uint32 v;

	for(;;) {
		v = runtime·sched.atomic;
 10080db:	8b 14 25 f8 4f 02 01 	mov    0x1024ff8,%edx
		if(atomic_mcpu(v) >= atomic_mcpumax(v))
 10080e2:	89 d0                	mov    %edx,%eax
 10080e4:	c1 e8 0f             	shr    $0xf,%eax
 10080e7:	25 ff 7f 00 00       	and    $0x7fff,%eax
 10080ec:	89 d1                	mov    %edx,%ecx
 10080ee:	81 e1 ff 7f 00 00    	and    $0x7fff,%ecx
 10080f4:	39 c1                	cmp    %eax,%ecx
 10080f6:	72 07                	jb     10080ff <canaddmcpu+0x3b>
			return 0;
 10080f8:	31 c0                	xor    %eax,%eax
 10080fa:	48 83 c4 28          	add    $0x28,%rsp
 10080fe:	c3                   	retq   
		if(runtime·cas(&runtime·sched.atomic, v, v+(1<<mcpuShift)))
 10080ff:	b9 f8 4f 02 01       	mov    $0x1024ff8,%ecx
 1008104:	48 89 0c 24          	mov    %rcx,(%rsp)
 1008108:	89 54 24 08          	mov    %edx,0x8(%rsp)
 100810c:	89 d1                	mov    %edx,%ecx
 100810e:	ff c1                	inc    %ecx
 1008110:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 1008114:	e8 82 98 ff ff       	callq  100199b <runtime.cas>
 1008119:	80 f8 00             	cmp    $0x0,%al
 100811c:	74 bd                	je     10080db <canaddmcpu+0x17>
			return 1;
 100811e:	b8 01 00 00 00       	mov    $0x1,%eax
 1008123:	48 83 c4 28          	add    $0x28,%rsp
 1008127:	c3                   	retq   

0000000001008128 <gput>:
	}
}

// Put on `g' queue.  Sched must be locked.
static void
gput(G *g)
 1008128:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100812f:	ff ff 
 1008131:	48 3b 21             	cmp    (%rcx),%rsp
 1008134:	77 05                	ja     100813b <gput+0x13>
 1008136:	e8 11 98 ff ff       	callq  100194c <runtime.morestack8>
 100813b:	48 83 ec 30          	sub    $0x30,%rsp
 100813f:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
{
	M *m;

	// If g is wired, hand it off directly.
	if((m = g->lockedm) != nil && canaddmcpu()) {
 1008144:	48 8b 82 98 00 00 00 	mov    0x98(%rdx),%rax
 100814b:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 1008150:	48 83 f8 00          	cmp    $0x0,%rax
 1008154:	74 12                	je     1008168 <gput+0x40>
 1008156:	e8 69 ff ff ff       	callq  10080c4 <canaddmcpu>
 100815b:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 1008160:	3c 00                	cmp    $0x0,%al
 1008162:	0f 85 e5 00 00 00    	jne    100824d <gput+0x125>
		mnextg(m, g);
		return;
	}

	// If g is the idle goroutine for an m, hand it off.
	if(g->idlem != nil) {
 1008168:	48 8b 82 a0 00 00 00 	mov    0xa0(%rdx),%rax
 100816f:	48 83 f8 00          	cmp    $0x0,%rax
 1008173:	74 72                	je     10081e7 <gput+0xbf>
		if(g->idlem->idleg != nil) {
 1008175:	48 8b 82 a0 00 00 00 	mov    0xa0(%rdx),%rax
 100817c:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
 1008183:	48 83 f8 00          	cmp    $0x0,%rax
 1008187:	74 4b                	je     10081d4 <gput+0xac>
			runtime·printf("m%d idle out of sync: g%d g%d\n",
 1008189:	b8 0f 46 02 01       	mov    $0x102460f,%eax
 100818e:	48 89 04 24          	mov    %rax,(%rsp)
 1008192:	48 8b 82 a0 00 00 00 	mov    0xa0(%rdx),%rax
 1008199:	8b 40 78             	mov    0x78(%rax),%eax
 100819c:	89 44 24 08          	mov    %eax,0x8(%rsp)
 10081a0:	48 8b 82 a0 00 00 00 	mov    0xa0(%rdx),%rax
 10081a7:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
 10081ae:	8b 40 74             	mov    0x74(%rax),%eax
 10081b1:	89 44 24 0c          	mov    %eax,0xc(%rsp)
 10081b5:	8b 42 74             	mov    0x74(%rdx),%eax
 10081b8:	89 44 24 10          	mov    %eax,0x10(%rsp)
 10081bc:	e8 7d f1 ff ff       	callq  100733e <runtime.printf>
				g->idlem->id,
				g->idlem->idleg->goid, g->goid);
			runtime·throw("runtime: double idle");
 10081c1:	b8 2e 46 02 01       	mov    $0x102462e,%eax
 10081c6:	48 89 04 24          	mov    %rax,(%rsp)
 10081ca:	e8 6a 1b 00 00       	callq  1009d39 <runtime.throw>
 10081cf:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
		}
		g->idlem->idleg = g;
 10081d4:	48 8b 82 a0 00 00 00 	mov    0xa0(%rdx),%rax
 10081db:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
		return;
 10081e2:	48 83 c4 30          	add    $0x30,%rsp
 10081e6:	c3                   	retq   
	}

	g->schedlink = nil;
 10081e7:	48 c7 82 80 00 00 00 	movq   $0x0,0x80(%rdx)
 10081ee:	00 00 00 00 
	if(runtime·sched.ghead == nil)
 10081f2:	48 83 3c 25 c8 4f 02 	cmpq   $0x0,0x1024fc8
 10081f9:	01 00 
 10081fb:	75 3f                	jne    100823c <gput+0x114>
		runtime·sched.ghead = g;
 10081fd:	48 89 14 25 c8 4f 02 	mov    %rdx,0x1024fc8
 1008204:	01 
	else
		runtime·sched.gtail->schedlink = g;
	runtime·sched.gtail = g;
 1008205:	48 89 14 25 d0 4f 02 	mov    %rdx,0x1024fd0
 100820c:	01 

	// increment gwait.
	// if it transitions to nonzero, set atomic gwaiting bit.
	if(runtime·sched.gwait++ == 0)
 100820d:	8b 04 25 d8 4f 02 01 	mov    0x1024fd8,%eax
 1008214:	ff 04 25 d8 4f 02 01 	incl   0x1024fd8
 100821b:	83 f8 00             	cmp    $0x0,%eax
 100821e:	75 17                	jne    1008237 <gput+0x10f>
		runtime·xadd(&runtime·sched.atomic, 1<<gwaitingShift);
 1008220:	b8 f8 4f 02 01       	mov    $0x1024ff8,%eax
 1008225:	48 89 04 24          	mov    %rax,(%rsp)
 1008229:	b8 00 00 00 80       	mov    $0x80000000,%eax
 100822e:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1008232:	e8 9f 97 ff ff       	callq  10019d6 <runtime.xadd>
 1008237:	48 83 c4 30          	add    $0x30,%rsp
 100823b:	c3                   	retq   

	g->schedlink = nil;
	if(runtime·sched.ghead == nil)
		runtime·sched.ghead = g;
	else
		runtime·sched.gtail->schedlink = g;
 100823c:	48 8b 04 25 d0 4f 02 	mov    0x1024fd0,%rax
 1008243:	01 
 1008244:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
	runtime·sched.gtail = g;
 100824b:	eb b8                	jmp    1008205 <gput+0xdd>
{
	M *m;

	// If g is wired, hand it off directly.
	if((m = g->lockedm) != nil && canaddmcpu()) {
		mnextg(m, g);
 100824d:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1008252:	48 89 04 24          	mov    %rax,(%rsp)
 1008256:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 100825b:	e8 aa 02 00 00       	callq  100850a <mnextg>
		return;
 1008260:	48 83 c4 30          	add    $0x30,%rsp
 1008264:	c3                   	retq   

0000000001008265 <haveg>:
		runtime·xadd(&runtime·sched.atomic, 1<<gwaitingShift);
}

// Report whether gget would return something.
static bool
haveg(void)
 1008265:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100826c:	ff ff 
 100826e:	48 3b 21             	cmp    (%rcx),%rsp
 1008271:	77 05                	ja     1008278 <haveg+0x13>
 1008273:	e8 7b 96 ff ff       	callq  10018f3 <runtime.morestack00>
{
	return runtime·sched.ghead != nil || m->idleg != nil;
 1008278:	48 83 3c 25 c8 4f 02 	cmpq   $0x0,0x1024fc8
 100827f:	01 00 
 1008281:	75 19                	jne    100829c <haveg+0x37>
 1008283:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 100828a:	ff ff 
 100828c:	48 8b 89 f0 00 00 00 	mov    0xf0(%rcx),%rcx
 1008293:	48 83 f9 00          	cmp    $0x0,%rcx
 1008297:	75 03                	jne    100829c <haveg+0x37>
 1008299:	31 c0                	xor    %eax,%eax
 100829b:	c3                   	retq   
 100829c:	b8 01 00 00 00       	mov    $0x1,%eax
 10082a1:	eb f8                	jmp    100829b <haveg+0x36>

00000000010082a3 <gget>:
}

// Get from `g' queue.  Sched must be locked.
static G*
gget(void)
 10082a3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10082aa:	ff ff 
 10082ac:	48 3b 21             	cmp    (%rcx),%rsp
 10082af:	77 05                	ja     10082b6 <gget+0x13>
 10082b1:	e8 3d 96 ff ff       	callq  10018f3 <runtime.morestack00>
 10082b6:	48 83 ec 28          	sub    $0x28,%rsp
{
	G *g;

	g = runtime·sched.ghead;
 10082ba:	48 8b 0c 25 c8 4f 02 	mov    0x1024fc8,%rcx
 10082c1:	01 
	if(g){
 10082c2:	48 83 f9 00          	cmp    $0x0,%rcx
 10082c6:	74 62                	je     100832a <gget+0x87>
		runtime·sched.ghead = g->schedlink;
 10082c8:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 10082cd:	48 8b 81 80 00 00 00 	mov    0x80(%rcx),%rax
 10082d4:	48 89 04 25 c8 4f 02 	mov    %rax,0x1024fc8
 10082db:	01 
		if(runtime·sched.ghead == nil)
 10082dc:	48 83 3c 25 c8 4f 02 	cmpq   $0x0,0x1024fc8
 10082e3:	01 00 
 10082e5:	75 0c                	jne    10082f3 <gget+0x50>
			runtime·sched.gtail = nil;
 10082e7:	48 c7 04 25 d0 4f 02 	movq   $0x0,0x1024fd0
 10082ee:	01 00 00 00 00 
		// decrement gwait.
		// if it transitions to zero, clear atomic gwaiting bit.
		if(--runtime·sched.gwait == 0)
 10082f3:	ff 0c 25 d8 4f 02 01 	decl   0x1024fd8
 10082fa:	8b 04 25 d8 4f 02 01 	mov    0x1024fd8,%eax
 1008301:	83 f8 00             	cmp    $0x0,%eax
 1008304:	75 1c                	jne    1008322 <gget+0x7f>
			runtime·xadd(&runtime·sched.atomic, -1<<gwaitingShift);
 1008306:	b8 f8 4f 02 01       	mov    $0x1024ff8,%eax
 100830b:	48 89 04 24          	mov    %rax,(%rsp)
 100830f:	b8 00 00 00 80       	mov    $0x80000000,%eax
 1008314:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1008318:	e8 b9 96 ff ff       	callq  10019d6 <runtime.xadd>
 100831d:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
	} else if(m->idleg != nil) {
		g = m->idleg;
		m->idleg = nil;
	}
	return g;
 1008322:	48 89 c8             	mov    %rcx,%rax
 1008325:	48 83 c4 28          	add    $0x28,%rsp
 1008329:	c3                   	retq   
			runtime·sched.gtail = nil;
		// decrement gwait.
		// if it transitions to zero, clear atomic gwaiting bit.
		if(--runtime·sched.gwait == 0)
			runtime·xadd(&runtime·sched.atomic, -1<<gwaitingShift);
	} else if(m->idleg != nil) {
 100832a:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008331:	ff ff 
 1008333:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
 100833a:	48 83 f8 00          	cmp    $0x0,%rax
 100833e:	74 e2                	je     1008322 <gget+0x7f>
		g = m->idleg;
 1008340:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008347:	ff ff 
 1008349:	48 8b 88 f0 00 00 00 	mov    0xf0(%rax),%rcx
		m->idleg = nil;
 1008350:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008357:	ff ff 
 1008359:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
 1008360:	00 00 00 00 
	}
	return g;
 1008364:	eb bc                	jmp    1008322 <gget+0x7f>

0000000001008366 <mput>:
}

// Put on `m' list.  Sched must be locked.
static void
mput(M *m)
 1008366:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100836d:	ff ff 
 100836f:	48 3b 21             	cmp    (%rcx),%rsp
 1008372:	77 05                	ja     1008379 <mput+0x13>
 1008374:	e8 d3 95 ff ff       	callq  100194c <runtime.morestack8>
 1008379:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
{
	m->schedlink = runtime·sched.mhead;
 100837e:	48 8b 0c 25 e8 4f 02 	mov    0x1024fe8,%rcx
 1008385:	01 
 1008386:	48 89 8a c8 00 00 00 	mov    %rcx,0xc8(%rdx)
	runtime·sched.mhead = m;
 100838d:	48 89 14 25 e8 4f 02 	mov    %rdx,0x1024fe8
 1008394:	01 
	runtime·sched.mwait++;
 1008395:	ff 04 25 f0 4f 02 01 	incl   0x1024ff0
 100839c:	c3                   	retq   

000000000100839d <mget>:
}

// Get an `m' to run `g'.  Sched must be locked.
static M*
mget(G *g)
 100839d:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10083a4:	ff ff 
 10083a6:	48 3b 21             	cmp    (%rcx),%rsp
 10083a9:	77 05                	ja     10083b0 <mget+0x13>
 10083ab:	e8 9c 95 ff ff       	callq  100194c <runtime.morestack8>
 10083b0:	48 83 ec 10          	sub    $0x10,%rsp
{
	M *m;

	// if g has its own m, use it.
	if((m = g->lockedm) != nil)
 10083b4:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 10083b9:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
 10083c0:	48 83 f8 00          	cmp    $0x0,%rax
 10083c4:	74 05                	je     10083cb <mget+0x2e>
		return m;
 10083c6:	48 83 c4 10          	add    $0x10,%rsp
 10083ca:	c3                   	retq   

	// otherwise use general m pool.
	if((m = runtime·sched.mhead) != nil){
 10083cb:	48 8b 0c 25 e8 4f 02 	mov    0x1024fe8,%rcx
 10083d2:	01 
 10083d3:	48 83 f9 00          	cmp    $0x0,%rcx
 10083d7:	74 16                	je     10083ef <mget+0x52>
		runtime·sched.mhead = m->schedlink;
 10083d9:	48 8b 81 c8 00 00 00 	mov    0xc8(%rcx),%rax
 10083e0:	48 89 04 25 e8 4f 02 	mov    %rax,0x1024fe8
 10083e7:	01 
		runtime·sched.mwait--;
 10083e8:	ff 0c 25 f0 4f 02 01 	decl   0x1024ff0
	}
	return m;
 10083ef:	48 89 c8             	mov    %rcx,%rax
 10083f2:	48 83 c4 10          	add    $0x10,%rsp
 10083f6:	c3                   	retq   

00000000010083f7 <runtime.ready>:
}

// Mark g ready to run.
void
runtime·ready(G *g)
 10083f7:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10083fe:	ff ff 
 1008400:	48 3b 21             	cmp    (%rcx),%rsp
 1008403:	77 05                	ja     100840a <runtime.ready+0x13>
 1008405:	e8 42 95 ff ff       	callq  100194c <runtime.morestack8>
 100840a:	48 83 ec 10          	sub    $0x10,%rsp
{
	schedlock();
 100840e:	e8 79 fa ff ff       	callq  1007e8c <schedlock>
	readylocked(g);
 1008413:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 1008418:	48 89 04 24          	mov    %rax,(%rsp)
 100841c:	e8 0a 00 00 00       	callq  100842b <readylocked>
	schedunlock();
 1008421:	e8 90 fa ff ff       	callq  1007eb6 <schedunlock>
 1008426:	48 83 c4 10          	add    $0x10,%rsp
 100842a:	c3                   	retq   

000000000100842b <readylocked>:

// Mark g ready to run.  Sched is already locked.
// G might be running already and about to stop.
// The sched lock protects g->status from changing underfoot.
static void
readylocked(G *g)
 100842b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1008432:	ff ff 
 1008434:	48 3b 21             	cmp    (%rcx),%rsp
 1008437:	77 05                	ja     100843e <readylocked+0x13>
 1008439:	e8 0e 95 ff ff       	callq  100194c <runtime.morestack8>
 100843e:	48 83 ec 18          	sub    $0x18,%rsp
 1008442:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
{
	if(g->m){
 1008447:	48 8b 81 90 00 00 00 	mov    0x90(%rcx),%rax
 100844e:	48 83 f8 00          	cmp    $0x0,%rax
 1008452:	74 0c                	je     1008460 <readylocked+0x35>
		// Running on another machine.
		// Ready it when it stops.
		g->readyonstop = 1;
 1008454:	c6 81 88 00 00 00 01 	movb   $0x1,0x88(%rcx)
		return;
 100845b:	48 83 c4 18          	add    $0x18,%rsp
 100845f:	c3                   	retq   
	}

	// Mark runnable.
	if(g->status == Grunnable || g->status == Grunning) {
 1008460:	0f bf 41 70          	movswl 0x70(%rcx),%eax
 1008464:	83 f8 01             	cmp    $0x1,%eax
 1008467:	74 2c                	je     1008495 <readylocked+0x6a>
 1008469:	0f bf 41 70          	movswl 0x70(%rcx),%eax
 100846d:	83 f8 02             	cmp    $0x2,%eax
 1008470:	74 23                	je     1008495 <readylocked+0x6a>
		runtime·printf("goroutine %d has status %d\n", g->goid, g->status);
		runtime·throw("bad g->status in ready");
	}
	g->status = Grunnable;
 1008472:	66 c7 41 70 01 00    	movw   $0x1,0x70(%rcx)

	gput(g);
 1008478:	48 89 0c 24          	mov    %rcx,(%rsp)
 100847c:	e8 a7 fc ff ff       	callq  1008128 <gput>
	if(!runtime·sched.predawn)
 1008481:	83 3c 25 fc 4f 02 01 	cmpl   $0x0,0x1024ffc
 1008488:	00 
 1008489:	75 05                	jne    1008490 <readylocked+0x65>
		matchmg();
 100848b:	e8 69 05 00 00       	callq  10089f9 <matchmg>
 1008490:	48 83 c4 18          	add    $0x18,%rsp
 1008494:	c3                   	retq   
		return;
	}

	// Mark runnable.
	if(g->status == Grunnable || g->status == Grunning) {
		runtime·printf("goroutine %d has status %d\n", g->goid, g->status);
 1008495:	b8 43 46 02 01       	mov    $0x1024643,%eax
 100849a:	48 89 04 24          	mov    %rax,(%rsp)
 100849e:	8b 41 74             	mov    0x74(%rcx),%eax
 10084a1:	89 44 24 08          	mov    %eax,0x8(%rsp)
 10084a5:	0f bf 41 70          	movswl 0x70(%rcx),%eax
 10084a9:	89 44 24 0c          	mov    %eax,0xc(%rsp)
 10084ad:	e8 8c ee ff ff       	callq  100733e <runtime.printf>
		runtime·throw("bad g->status in ready");
 10084b2:	b8 5f 46 02 01       	mov    $0x102465f,%eax
 10084b7:	48 89 04 24          	mov    %rax,(%rsp)
 10084bb:	e8 79 18 00 00       	callq  1009d39 <runtime.throw>
 10084c0:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
	}
	g->status = Grunnable;
 10084c5:	eb ab                	jmp    1008472 <readylocked+0x47>

00000000010084c7 <nop>:
	if(!runtime·sched.predawn)
		matchmg();
}

static void
nop(void)
 10084c7:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10084ce:	ff ff 
 10084d0:	48 3b 21             	cmp    (%rcx),%rsp
 10084d3:	77 05                	ja     10084da <nop+0x13>
 10084d5:	e8 19 94 ff ff       	callq  10018f3 <runtime.morestack00>
{
}
 10084da:	c3                   	retq   

00000000010084db <newprocreadylocked>:

// Same as readylocked but a different symbol so that
// debuggers can set a breakpoint here and catch all
// new goroutines.
static void
newprocreadylocked(G *g)
 10084db:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10084e2:	ff ff 
 10084e4:	48 3b 21             	cmp    (%rcx),%rsp
 10084e7:	77 05                	ja     10084ee <newprocreadylocked+0x13>
 10084e9:	e8 5e 94 ff ff       	callq  100194c <runtime.morestack8>
 10084ee:	48 83 ec 10          	sub    $0x10,%rsp
{
	nop();	// avoid inlining in 6l
 10084f2:	e8 d0 ff ff ff       	callq  10084c7 <nop>
	readylocked(g);
 10084f7:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 10084fc:	48 89 04 24          	mov    %rax,(%rsp)
 1008500:	e8 26 ff ff ff       	callq  100842b <readylocked>
 1008505:	48 83 c4 10          	add    $0x10,%rsp
 1008509:	c3                   	retq   

000000000100850a <mnextg>:
}

// Pass g to m for running.
// Caller has already incremented mcpu.
static void
mnextg(M *m, G *g)
 100850a:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1008511:	ff ff 
 1008513:	48 3b 21             	cmp    (%rcx),%rsp
 1008516:	77 05                	ja     100851d <mnextg+0x13>
 1008518:	e8 38 94 ff ff       	callq  1001955 <runtime.morestack16>
 100851d:	48 83 ec 10          	sub    $0x10,%rsp
 1008521:	48 8b 1c 25 a8 4e 02 	mov    0x1024ea8,%rbx
 1008528:	01 
 1008529:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
{
	runtime·sched.grunning++;
 100852e:	ff 04 25 e0 4f 02 01 	incl   0x1024fe0
	m->nextg = g;
 1008535:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 100853a:	48 89 8a b8 00 00 00 	mov    %rcx,0xb8(%rdx)
	if(m->waitnextg) {
 1008541:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
 1008547:	83 f8 00             	cmp    $0x0,%eax
 100854a:	74 2f                	je     100857b <mnextg+0x71>
		m->waitnextg = 0;
 100854c:	c7 82 8c 00 00 00 00 	movl   $0x0,0x8c(%rdx)
 1008553:	00 00 00 
		if(mwakeup != nil)
 1008556:	48 83 fb 00          	cmp    $0x0,%rbx
 100855a:	74 17                	je     1008573 <mnextg+0x69>
			runtime·notewakeup(&mwakeup->havenextg);
 100855c:	48 89 d8             	mov    %rbx,%rax
 100855f:	48 05 a8 00 00 00    	add    $0xa8,%rax
 1008565:	48 89 04 24          	mov    %rax,(%rsp)
 1008569:	e8 85 49 00 00       	callq  100cef3 <runtime.notewakeup>
 100856e:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
		mwakeup = m;
 1008573:	48 89 14 25 a8 4e 02 	mov    %rdx,0x1024ea8
 100857a:	01 
 100857b:	48 83 c4 10          	add    $0x10,%rsp
 100857f:	c3                   	retq   

0000000001008580 <nextgandunlock>:
// Get the next goroutine that m should run.
// Sched must be locked on entry, is unlocked on exit.
// Makes sure that at most $GOMAXPROCS g's are
// running on cpus (not in system calls) at any given time.
static G*
nextgandunlock(void)
 1008580:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1008587:	ff ff 
 1008589:	48 3b 21             	cmp    (%rcx),%rsp
 100858c:	77 05                	ja     1008593 <nextgandunlock+0x13>
 100858e:	e8 60 93 ff ff       	callq  10018f3 <runtime.morestack00>
 1008593:	48 83 ec 30          	sub    $0x30,%rsp
{
	G *gp;
	uint32 v;

	if(atomic_mcpu(runtime·sched.atomic) >= maxgomaxprocs)
 1008597:	8b 04 25 f8 4f 02 01 	mov    0x1024ff8,%eax
 100859e:	25 ff 7f 00 00       	and    $0x7fff,%eax
 10085a3:	3d f5 7f 00 00       	cmp    $0x7ff5,%eax
 10085a8:	72 0e                	jb     10085b8 <nextgandunlock+0x38>
		runtime·throw("negative mcpu");
 10085aa:	b8 76 46 02 01       	mov    $0x1024676,%eax
 10085af:	48 89 04 24          	mov    %rax,(%rsp)
 10085b3:	e8 81 17 00 00       	callq  1009d39 <runtime.throw>

	// If there is a g waiting as m->nextg, the mcpu++
	// happened before it was passed to mnextg.
	if(m->nextg != nil) {
 10085b8:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10085bf:	ff ff 
 10085c1:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 10085c8:	48 83 f8 00          	cmp    $0x0,%rax
 10085cc:	74 38                	je     1008606 <nextgandunlock+0x86>
		gp = m->nextg;
 10085ce:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10085d5:	ff ff 
 10085d7:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 10085de:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
		m->nextg = nil;
 10085e3:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10085ea:	ff ff 
 10085ec:	48 c7 80 b8 00 00 00 	movq   $0x0,0xb8(%rax)
 10085f3:	00 00 00 00 
		schedunlock();
 10085f7:	e8 ba f8 ff ff       	callq  1007eb6 <schedunlock>
		return gp;
 10085fc:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1008601:	48 83 c4 30          	add    $0x30,%rsp
 1008605:	c3                   	retq   
	}

	if(m->lockedg != nil) {
 1008606:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100860d:	ff ff 
 100860f:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
 1008616:	48 83 f8 00          	cmp    $0x0,%rax
 100861a:	0f 84 7b 01 00 00    	je     100879b <nextgandunlock+0x21b>
		// We can only run one g, and it's not available.
		// Make sure some other cpu is running to handle
		// the ordinary run queue.
		if(runtime·sched.gwait != 0) {
 1008620:	83 3c 25 d8 4f 02 01 	cmpl   $0x0,0x1024fd8
 1008627:	00 
 1008628:	74 53                	je     100867d <nextgandunlock+0xfd>
			matchmg();
 100862a:	e8 ca 03 00 00       	callq  10089f9 <matchmg>
			// m->lockedg might have been on the queue.
			if(m->nextg != nil) {
 100862f:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008636:	ff ff 
 1008638:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 100863f:	48 83 f8 00          	cmp    $0x0,%rax
 1008643:	74 38                	je     100867d <nextgandunlock+0xfd>
				gp = m->nextg;
 1008645:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100864c:	ff ff 
 100864e:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 1008655:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
				m->nextg = nil;
 100865a:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008661:	ff ff 
 1008663:	48 c7 80 b8 00 00 00 	movq   $0x0,0xb8(%rax)
 100866a:	00 00 00 00 
				schedunlock();
 100866e:	e8 43 f8 ff ff       	callq  1007eb6 <schedunlock>
				return gp;
 1008673:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1008678:	48 83 c4 30          	add    $0x30,%rsp
 100867c:	c3                   	retq   
		//
		// Wait on global m queue.
		mput(m);
	}

	v = runtime·atomicload(&runtime·sched.atomic);
 100867d:	b9 f8 4f 02 01       	mov    $0x1024ff8,%ecx
 1008682:	48 89 0c 24          	mov    %rcx,(%rsp)
 1008686:	e8 4e 94 ff ff       	callq  1001ad9 <runtime.atomicload>
 100868b:	89 44 24 24          	mov    %eax,0x24(%rsp)
	if(runtime·sched.grunning == 0)
 100868f:	83 3c 25 e0 4f 02 01 	cmpl   $0x0,0x1024fe0
 1008696:	00 
 1008697:	75 0e                	jne    10086a7 <nextgandunlock+0x127>
		runtime·throw("all goroutines are asleep - deadlock!");
 1008699:	b8 97 46 02 01       	mov    $0x1024697,%eax
 100869e:	48 89 04 24          	mov    %rax,(%rsp)
 10086a2:	e8 92 16 00 00       	callq  1009d39 <runtime.throw>
	m->nextg = nil;
 10086a7:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10086ae:	ff ff 
 10086b0:	48 c7 80 b8 00 00 00 	movq   $0x0,0xb8(%rax)
 10086b7:	00 00 00 00 
	m->waitnextg = 1;
 10086bb:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10086c2:	ff ff 
 10086c4:	c7 80 8c 00 00 00 01 	movl   $0x1,0x8c(%rax)
 10086cb:	00 00 00 
	runtime·noteclear(&m->havenextg);
 10086ce:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10086d5:	ff ff 
 10086d7:	48 05 a8 00 00 00    	add    $0xa8,%rax
 10086dd:	48 89 04 24          	mov    %rax,(%rsp)
 10086e1:	e8 ee 47 00 00       	callq  100ced4 <runtime.noteclear>
 10086e6:	8b 54 24 24          	mov    0x24(%rsp),%edx

	// Stoptheworld is waiting for all but its cpu to go to stop.
	// Entersyscall might have decremented mcpu too, but if so
	// it will see the waitstop and take the slow path.
	// Exitsyscall never increments mcpu beyond mcpumax.
	if(atomic_waitstop(v) && atomic_mcpu(v) <= atomic_mcpumax(v)) {
 10086ea:	89 d0                	mov    %edx,%eax
 10086ec:	c1 e8 1e             	shr    $0x1e,%eax
 10086ef:	83 e0 01             	and    $0x1,%eax
 10086f2:	83 f8 00             	cmp    $0x0,%eax
 10086f5:	74 16                	je     100870d <nextgandunlock+0x18d>
 10086f7:	89 d0                	mov    %edx,%eax
 10086f9:	c1 e8 0f             	shr    $0xf,%eax
 10086fc:	25 ff 7f 00 00       	and    $0x7fff,%eax
 1008701:	89 d1                	mov    %edx,%ecx
 1008703:	81 e1 ff 7f 00 00    	and    $0x7fff,%ecx
 1008709:	39 c1                	cmp    %eax,%ecx
 100870b:	76 64                	jbe    1008771 <nextgandunlock+0x1f1>
		// set waitstop = 0 (known to be 1)
		runtime·xadd(&runtime·sched.atomic, -1<<waitstopShift);
		runtime·notewakeup(&runtime·sched.stopped);
	}
	schedunlock();
 100870d:	e8 a4 f7 ff ff       	callq  1007eb6 <schedunlock>

	runtime·notesleep(&m->havenextg);
 1008712:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008719:	ff ff 
 100871b:	48 05 a8 00 00 00    	add    $0xa8,%rax
 1008721:	48 89 04 24          	mov    %rax,(%rsp)
 1008725:	e8 13 48 00 00       	callq  100cf3d <runtime.notesleep>
	if((gp = m->nextg) == nil)
 100872a:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008731:	ff ff 
 1008733:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 100873a:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 100873f:	48 83 f8 00          	cmp    $0x0,%rax
 1008743:	75 0e                	jne    1008753 <nextgandunlock+0x1d3>
		runtime·throw("bad m->nextg in nextgoroutine");
 1008745:	b8 bd 46 02 01       	mov    $0x10246bd,%eax
 100874a:	48 89 04 24          	mov    %rax,(%rsp)
 100874e:	e8 e6 15 00 00       	callq  1009d39 <runtime.throw>
	m->nextg = nil;
 1008753:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100875a:	ff ff 
 100875c:	48 c7 80 b8 00 00 00 	movq   $0x0,0xb8(%rax)
 1008763:	00 00 00 00 
	return gp;
 1008767:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100876c:	48 83 c4 30          	add    $0x30,%rsp
 1008770:	c3                   	retq   
	// Entersyscall might have decremented mcpu too, but if so
	// it will see the waitstop and take the slow path.
	// Exitsyscall never increments mcpu beyond mcpumax.
	if(atomic_waitstop(v) && atomic_mcpu(v) <= atomic_mcpumax(v)) {
		// set waitstop = 0 (known to be 1)
		runtime·xadd(&runtime·sched.atomic, -1<<waitstopShift);
 1008771:	b8 f8 4f 02 01       	mov    $0x1024ff8,%eax
 1008776:	48 89 04 24          	mov    %rax,(%rsp)
 100877a:	b8 00 00 00 c0       	mov    $0xc0000000,%eax
 100877f:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1008783:	e8 4e 92 ff ff       	callq  10019d6 <runtime.xadd>
		runtime·notewakeup(&runtime·sched.stopped);
 1008788:	b8 04 50 02 01       	mov    $0x1025004,%eax
 100878d:	48 89 04 24          	mov    %rax,(%rsp)
 1008791:	e8 5d 47 00 00       	callq  100cef3 <runtime.notewakeup>
	}
	schedunlock();
 1008796:	e9 72 ff ff ff       	jmpq   100870d <nextgandunlock+0x18d>
				return gp;
			}
		}
	} else {
		// Look for work on global queue.
		while(haveg() && canaddmcpu()) {
 100879b:	e8 c5 fa ff ff       	callq  1008265 <haveg>
 10087a0:	3c 00                	cmp    $0x0,%al
 10087a2:	74 09                	je     10087ad <nextgandunlock+0x22d>
 10087a4:	e8 1b f9 ff ff       	callq  10080c4 <canaddmcpu>
 10087a9:	3c 00                	cmp    $0x0,%al
 10087ab:	75 17                	jne    10087c4 <nextgandunlock+0x244>
		// mcpu, but if does so when there is something on the g queue,
		// the gwait bit will be set, so entersyscall will take the slow path
		// and use the sched lock.  So it cannot invalidate our decision.
		//
		// Wait on global m queue.
		mput(m);
 10087ad:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10087b4:	ff ff 
 10087b6:	48 89 04 24          	mov    %rax,(%rsp)
 10087ba:	e8 a7 fb ff ff       	callq  1008366 <mput>
	}

	v = runtime·atomicload(&runtime·sched.atomic);
 10087bf:	e9 b9 fe ff ff       	jmpq   100867d <nextgandunlock+0xfd>
			}
		}
	} else {
		// Look for work on global queue.
		while(haveg() && canaddmcpu()) {
			gp = gget();
 10087c4:	e8 da fa ff ff       	callq  10082a3 <gget>
 10087c9:	48 89 c1             	mov    %rax,%rcx
			if(gp == nil)
 10087cc:	48 83 f8 00          	cmp    $0x0,%rax
 10087d0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 10087d5:	75 13                	jne    10087ea <nextgandunlock+0x26a>
				runtime·throw("gget inconsistency");
 10087d7:	b8 84 46 02 01       	mov    $0x1024684,%eax
 10087dc:	48 89 04 24          	mov    %rax,(%rsp)
 10087e0:	e8 54 15 00 00       	callq  1009d39 <runtime.throw>
 10087e5:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx

			if(gp->lockedm) {
 10087ea:	48 8b 81 98 00 00 00 	mov    0x98(%rcx),%rax
 10087f1:	48 83 f8 00          	cmp    $0x0,%rax
 10087f5:	74 17                	je     100880e <nextgandunlock+0x28e>
				mnextg(gp->lockedm, gp);
 10087f7:	48 8b 81 98 00 00 00 	mov    0x98(%rcx),%rax
 10087fe:	48 89 04 24          	mov    %rax,(%rsp)
 1008802:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1008807:	e8 fe fc ff ff       	callq  100850a <mnextg>
				return gp;
			}
		}
	} else {
		// Look for work on global queue.
		while(haveg() && canaddmcpu()) {
 100880c:	eb 8d                	jmp    100879b <nextgandunlock+0x21b>

			if(gp->lockedm) {
				mnextg(gp->lockedm, gp);
				continue;
			}
			runtime·sched.grunning++;
 100880e:	ff 04 25 e0 4f 02 01 	incl   0x1024fe0
			schedunlock();
 1008815:	e8 9c f6 ff ff       	callq  1007eb6 <schedunlock>
			return gp;
 100881a:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100881f:	48 83 c4 30          	add    $0x30,%rsp
 1008823:	c3                   	retq   

0000000001008824 <runtime.stoptheworld>:
	m->nextg = nil;
	return gp;
}

void
runtime·stoptheworld(void)
 1008824:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100882b:	ff ff 
 100882d:	48 3b 21             	cmp    (%rcx),%rsp
 1008830:	77 05                	ja     1008837 <runtime.stoptheworld+0x13>
 1008832:	e8 bc 90 ff ff       	callq  10018f3 <runtime.morestack00>
 1008837:	48 83 ec 28          	sub    $0x28,%rsp
{
	uint32 v;

	schedlock();
 100883b:	e8 4c f6 ff ff       	callq  1007e8c <schedlock>
	runtime·gcwaiting = 1;
 1008840:	c7 04 25 14 4e 02 01 	movl   $0x1,0x1024e14
 1008847:	01 00 00 00 

	setmcpumax(1);
 100884b:	b8 01 00 00 00       	mov    $0x1,%eax
 1008850:	89 04 24             	mov    %eax,(%rsp)
 1008853:	e8 12 f5 ff ff       	callq  1007d6a <setmcpumax>

	// while mcpu > 1
	for(;;) {
		v = runtime·sched.atomic;
 1008858:	8b 04 25 f8 4f 02 01 	mov    0x1024ff8,%eax
		if(atomic_mcpu(v) <= 1)
 100885f:	89 44 24 24          	mov    %eax,0x24(%rsp)
 1008863:	25 ff 7f 00 00       	and    $0x7fff,%eax
 1008868:	83 f8 01             	cmp    $0x1,%eax
 100886b:	77 24                	ja     1008891 <runtime.stoptheworld+0x6d>

		schedunlock();
		runtime·notesleep(&runtime·sched.stopped);
		schedlock();
	}
	runtime·singleproc = runtime·gomaxprocs == 1;
 100886d:	83 3c 25 18 4e 02 01 	cmpl   $0x1,0x1024e18
 1008874:	01 
 1008875:	75 16                	jne    100888d <runtime.stoptheworld+0x69>
 1008877:	b8 01 00 00 00       	mov    $0x1,%eax
 100887c:	88 04 25 e3 4d 02 01 	mov    %al,0x1024de3
	schedunlock();
 1008883:	e8 2e f6 ff ff       	callq  1007eb6 <schedunlock>
 1008888:	48 83 c4 28          	add    $0x28,%rsp
 100888c:	c3                   	retq   

		schedunlock();
		runtime·notesleep(&runtime·sched.stopped);
		schedlock();
	}
	runtime·singleproc = runtime·gomaxprocs == 1;
 100888d:	31 c0                	xor    %eax,%eax
 100888f:	eb eb                	jmp    100887c <runtime.stoptheworld+0x58>
			break;

		// It would be unsafe for multiple threads to be using
		// the stopped note at once, but there is only
		// ever one thread doing garbage collection.
		runtime·noteclear(&runtime·sched.stopped);
 1008891:	b8 04 50 02 01       	mov    $0x1025004,%eax
 1008896:	48 89 04 24          	mov    %rax,(%rsp)
 100889a:	e8 35 46 00 00       	callq  100ced4 <runtime.noteclear>
 100889f:	8b 54 24 24          	mov    0x24(%rsp),%edx
		if(atomic_waitstop(v))
 10088a3:	89 d0                	mov    %edx,%eax
 10088a5:	c1 e8 1e             	shr    $0x1e,%eax
 10088a8:	83 e0 01             	and    $0x1,%eax
 10088ab:	83 f8 00             	cmp    $0x0,%eax
 10088ae:	74 12                	je     10088c2 <runtime.stoptheworld+0x9e>
			runtime·throw("invalid waitstop");
 10088b0:	b8 db 46 02 01       	mov    $0x10246db,%eax
 10088b5:	48 89 04 24          	mov    %rax,(%rsp)
 10088b9:	e8 7b 14 00 00       	callq  1009d39 <runtime.throw>
 10088be:	8b 54 24 24          	mov    0x24(%rsp),%edx

		// atomic { waitstop = 1 }, predicated on mcpu <= 1 check above
		// still being true.
		if(!runtime·cas(&runtime·sched.atomic, v, v+(1<<waitstopShift)))
 10088c2:	b9 f8 4f 02 01       	mov    $0x1024ff8,%ecx
 10088c7:	48 89 0c 24          	mov    %rcx,(%rsp)
 10088cb:	89 54 24 08          	mov    %edx,0x8(%rsp)
 10088cf:	89 d1                	mov    %edx,%ecx
 10088d1:	81 c1 00 00 00 40    	add    $0x40000000,%ecx
 10088d7:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 10088db:	e8 bb 90 ff ff       	callq  100199b <runtime.cas>
 10088e0:	80 f8 00             	cmp    $0x0,%al
 10088e3:	0f 84 6f ff ff ff    	je     1008858 <runtime.stoptheworld+0x34>
			continue;

		schedunlock();
 10088e9:	e8 c8 f5 ff ff       	callq  1007eb6 <schedunlock>
		runtime·notesleep(&runtime·sched.stopped);
 10088ee:	b8 04 50 02 01       	mov    $0x1025004,%eax
 10088f3:	48 89 04 24          	mov    %rax,(%rsp)
 10088f7:	e8 41 46 00 00       	callq  100cf3d <runtime.notesleep>
		schedlock();
 10088fc:	e8 8b f5 ff ff       	callq  1007e8c <schedlock>

	setmcpumax(1);

	// while mcpu > 1
	for(;;) {
		v = runtime·sched.atomic;
 1008901:	e9 52 ff ff ff       	jmpq   1008858 <runtime.stoptheworld+0x34>

0000000001008906 <runtime.starttheworld>:
}

// TODO(rsc): Remove. This is only temporary,
// for the mark and sweep collector.
void
runtime·starttheworld(void)
 1008906:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100890d:	ff ff 
 100890f:	48 3b 21             	cmp    (%rcx),%rsp
 1008912:	77 05                	ja     1008919 <runtime.starttheworld+0x13>
 1008914:	e8 da 8f ff ff       	callq  10018f3 <runtime.morestack00>
 1008919:	48 83 ec 10          	sub    $0x10,%rsp
{
	schedlock();
 100891d:	e8 6a f5 ff ff       	callq  1007e8c <schedlock>
	runtime·gcwaiting = 0;
 1008922:	c7 04 25 14 4e 02 01 	movl   $0x0,0x1024e14
 1008929:	00 00 00 00 
	setmcpumax(runtime·gomaxprocs);
 100892d:	8b 04 25 18 4e 02 01 	mov    0x1024e18,%eax
 1008934:	89 04 24             	mov    %eax,(%rsp)
 1008937:	e8 2e f4 ff ff       	callq  1007d6a <setmcpumax>
	matchmg();
 100893c:	e8 b8 00 00 00       	callq  10089f9 <matchmg>
	schedunlock();
 1008941:	e8 70 f5 ff ff       	callq  1007eb6 <schedunlock>
 1008946:	48 83 c4 10          	add    $0x10,%rsp
 100894a:	c3                   	retq   

000000000100894b <runtime.mstart>:
}

// Called to start an M.
void
runtime·mstart(void)
 100894b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1008952:	ff ff 
 1008954:	48 3b 21             	cmp    (%rcx),%rsp
 1008957:	77 05                	ja     100895e <runtime.mstart+0x13>
 1008959:	e8 95 8f ff ff       	callq  10018f3 <runtime.morestack00>
 100895e:	48 83 ec 10          	sub    $0x10,%rsp
{
	if(g != m->g0)
 1008962:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1008969:	ff ff 
 100896b:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 1008972:	ff ff 
 1008974:	48 8b 09             	mov    (%rcx),%rcx
 1008977:	48 39 c8             	cmp    %rcx,%rax
 100897a:	74 0e                	je     100898a <runtime.mstart+0x3f>
		runtime·throw("bad runtime·mstart");
 100897c:	b8 ec 46 02 01       	mov    $0x10246ec,%eax
 1008981:	48 89 04 24          	mov    %rax,(%rsp)
 1008985:	e8 af 13 00 00       	callq  1009d39 <runtime.throw>
	if(m->mcache == nil)
 100898a:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008991:	ff ff 
 1008993:	48 8b 80 d8 00 00 00 	mov    0xd8(%rax),%rax
 100899a:	48 83 f8 00          	cmp    $0x0,%rax
 100899e:	75 15                	jne    10089b5 <runtime.mstart+0x6a>
		m->mcache = runtime·allocmcache();
 10089a0:	e8 79 a4 ff ff       	callq  1002e1e <runtime.allocmcache>
 10089a5:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 10089ac:	ff ff 
 10089ae:	48 89 81 d8 00 00 00 	mov    %rax,0xd8(%rcx)

	// Record top of stack for use by mcall.
	// Once we call schedule we're never coming back,
	// so other calls can reuse this stack space.
	runtime·gosave(&m->g0->sched);
 10089b5:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10089bc:	ff ff 
 10089be:	48 8b 00             	mov    (%rax),%rax
 10089c1:	48 83 c0 20          	add    $0x20,%rax
 10089c5:	48 89 04 24          	mov    %rax,(%rsp)
 10089c9:	e8 76 8d ff ff       	callq  1001744 <runtime.gosave>
	m->g0->sched.pc = (void*)-1;  // make sure it is never used
 10089ce:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10089d5:	ff ff 
 10089d7:	48 8b 00             	mov    (%rax),%rax
 10089da:	48 c7 40 28 ff ff ff 	movq   $0xffffffffffffffff,0x28(%rax)
 10089e1:	ff 

	runtime·minit();
 10089e2:	e8 61 46 00 00       	callq  100d048 <runtime.minit>
	schedule(nil);
 10089e7:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
 10089ee:	00 
 10089ef:	e8 86 01 00 00       	callq  1008b7a <schedule>
 10089f4:	48 83 c4 10          	add    $0x10,%rsp
 10089f8:	c3                   	retq   

00000000010089f9 <matchmg>:
// Kick off new m's as needed (up to mcpumax).
// There are already `other' other cpus that will
// start looking for goroutines shortly.
// Sched is locked.
static void
matchmg(void)
 10089f9:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1008a00:	ff ff 
 1008a02:	48 3b 21             	cmp    (%rcx),%rsp
 1008a05:	77 05                	ja     1008a0c <matchmg+0x13>
 1008a07:	e8 e7 8e ff ff       	callq  10018f3 <runtime.morestack00>
 1008a0c:	48 83 ec 58          	sub    $0x58,%rsp
{
	G *g;

	if(m->mallocing || m->gcing)
 1008a10:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008a17:	ff ff 
 1008a19:	8b 40 7c             	mov    0x7c(%rax),%eax
 1008a1c:	83 f8 00             	cmp    $0x0,%eax
 1008a1f:	0f 85 50 01 00 00    	jne    1008b75 <matchmg+0x17c>
 1008a25:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008a2c:	ff ff 
 1008a2e:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
 1008a34:	83 f8 00             	cmp    $0x0,%eax
 1008a37:	0f 85 38 01 00 00    	jne    1008b75 <matchmg+0x17c>
		return;

	while(haveg() && canaddmcpu()) {
 1008a3d:	e8 23 f8 ff ff       	callq  1008265 <haveg>
 1008a42:	3c 00                	cmp    $0x0,%al
 1008a44:	74 09                	je     1008a4f <matchmg+0x56>
 1008a46:	e8 79 f6 ff ff       	callq  10080c4 <canaddmcpu>
 1008a4b:	3c 00                	cmp    $0x0,%al
 1008a4d:	75 05                	jne    1008a54 <matchmg+0x5b>
				else
					m->g0 = runtime·malg(8192);
				runtime·newosproc(m, m->g0, m->g0->stackbase, runtime·mstart);
			}
		}
		mnextg(m, g);
 1008a4f:	48 83 c4 58          	add    $0x58,%rsp
 1008a53:	c3                   	retq   

	if(m->mallocing || m->gcing)
		return;

	while(haveg() && canaddmcpu()) {
		g = gget();
 1008a54:	e8 4a f8 ff ff       	callq  10082a3 <gget>
 1008a59:	48 89 c2             	mov    %rax,%rdx
		if(g == nil)
 1008a5c:	48 83 f8 00          	cmp    $0x0,%rax
 1008a60:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
 1008a65:	75 13                	jne    1008a7a <matchmg+0x81>
			runtime·throw("gget inconsistency");
 1008a67:	b8 00 47 02 01       	mov    $0x1024700,%eax
 1008a6c:	48 89 04 24          	mov    %rax,(%rsp)
 1008a70:	e8 c4 12 00 00       	callq  1009d39 <runtime.throw>
 1008a75:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx

		// Find the m that will run g.
		M *m;
		if((m = mget(g)) == nil){
 1008a7a:	48 89 14 24          	mov    %rdx,(%rsp)
 1008a7e:	e8 1a f9 ff ff       	callq  100839d <mget>
 1008a83:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
 1008a88:	48 83 f8 00          	cmp    $0x0,%rax
 1008a8c:	0f 85 88 00 00 00    	jne    1008b1a <matchmg+0x121>
			m = runtime·malloc(sizeof(M));
 1008a92:	48 c7 c1 80 01 00 00 	mov    $0x180,%rcx
 1008a99:	48 89 0c 24          	mov    %rcx,(%rsp)
 1008a9d:	e8 e9 9f ff ff       	callq  1002a8b <runtime.malloc>
			mcommoninit(m);
 1008aa2:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
 1008aa7:	48 89 04 24          	mov    %rax,(%rsp)
 1008aab:	e8 58 f5 ff ff       	callq  1008008 <mcommoninit>

			if(runtime·iscgo) {
 1008ab0:	80 3c 25 e2 4d 02 01 	cmpb   $0x0,0x1024de2
 1008ab7:	00 
 1008ab8:	74 7d                	je     1008b37 <matchmg+0x13e>
				CgoThreadStart ts;

				if(libcgo_thread_start == nil)
 1008aba:	48 83 3c 25 a0 4e 02 	cmpq   $0x0,0x1024ea0
 1008ac1:	01 00 
 1008ac3:	75 0e                	jne    1008ad3 <matchmg+0xda>
					runtime·throw("libcgo_thread_start missing");
 1008ac5:	b8 13 47 02 01       	mov    $0x1024713,%eax
 1008aca:	48 89 04 24          	mov    %rax,(%rsp)
 1008ace:	e8 66 12 00 00       	callq  1009d39 <runtime.throw>
				// pthread_create will make us a stack.
				m->g0 = runtime·malg(-1);
 1008ad3:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 1008ad8:	89 0c 24             	mov    %ecx,(%rsp)
 1008adb:	e8 f7 06 00 00       	callq  10091d7 <runtime.malg>
 1008ae0:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
 1008ae5:	48 89 02             	mov    %rax,(%rdx)
				ts.m = m;
 1008ae8:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
				ts.g = m->g0;
 1008aed:	48 8b 02             	mov    (%rdx),%rax
 1008af0:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
				ts.fn = runtime·mstart;
 1008af5:	b8 4b 89 00 01       	mov    $0x100894b,%eax
 1008afa:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
				runtime·asmcgocall(libcgo_thread_start, &ts);
 1008aff:	48 8b 04 25 a0 4e 02 	mov    0x1024ea0,%rax
 1008b06:	01 
 1008b07:	48 89 04 24          	mov    %rax,(%rsp)
 1008b0b:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
 1008b10:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1008b15:	e8 01 8f ff ff       	callq  1001a1b <runtime.asmcgocall>
				else
					m->g0 = runtime·malg(8192);
				runtime·newosproc(m, m->g0, m->g0->stackbase, runtime·mstart);
			}
		}
		mnextg(m, g);
 1008b1a:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 1008b1f:	48 89 04 24          	mov    %rax,(%rsp)
 1008b23:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1008b28:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1008b2d:	e8 d8 f9 ff ff       	callq  100850a <mnextg>
	G *g;

	if(m->mallocing || m->gcing)
		return;

	while(haveg() && canaddmcpu()) {
 1008b32:	e9 06 ff ff ff       	jmpq   1008a3d <matchmg+0x44>
			} else {
				if(Windows)
					// windows will layout sched stack on os stack
					m->g0 = runtime·malg(-1);
				else
					m->g0 = runtime·malg(8192);
 1008b37:	b9 00 20 00 00       	mov    $0x2000,%ecx
 1008b3c:	89 0c 24             	mov    %ecx,(%rsp)
 1008b3f:	e8 93 06 00 00       	callq  10091d7 <runtime.malg>
 1008b44:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
 1008b49:	48 89 02             	mov    %rax,(%rdx)
				runtime·newosproc(m, m->g0, m->g0->stackbase, runtime·mstart);
 1008b4c:	48 89 14 24          	mov    %rdx,(%rsp)
 1008b50:	48 8b 02             	mov    (%rdx),%rax
 1008b53:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1008b58:	48 8b 02             	mov    (%rdx),%rax
 1008b5b:	48 8b 40 08          	mov    0x8(%rax),%rax
 1008b5f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1008b64:	b8 4b 89 00 01       	mov    $0x100894b,%eax
 1008b69:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1008b6e:	e8 11 44 00 00       	callq  100cf84 <runtime.newosproc>
			}
		}
		mnextg(m, g);
 1008b73:	eb a5                	jmp    1008b1a <matchmg+0x121>
matchmg(void)
{
	G *g;

	if(m->mallocing || m->gcing)
		return;
 1008b75:	48 83 c4 58          	add    $0x58,%rsp
 1008b79:	c3                   	retq   

0000000001008b7a <schedule>:
// One round of scheduler: find a goroutine and run it.
// The argument is the goroutine that was running before
// schedule was called, or nil if this is the first call.
// Never returns.
static void
schedule(G *gp)
 1008b7a:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1008b81:	ff ff 
 1008b83:	48 3b 21             	cmp    (%rcx),%rsp
 1008b86:	77 05                	ja     1008b8d <schedule+0x13>
 1008b88:	e8 bf 8d ff ff       	callq  100194c <runtime.morestack8>
 1008b8d:	48 83 ec 28          	sub    $0x28,%rsp
{
	int32 hz;
	uint32 v;

	schedlock();
 1008b91:	e8 f6 f2 ff ff       	callq  1007e8c <schedlock>
	if(gp != nil) {
 1008b96:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
 1008b9c:	0f 84 ad 00 00 00    	je     1008c4f <schedule+0xd5>
		if(runtime·sched.predawn)
 1008ba2:	83 3c 25 fc 4f 02 01 	cmpl   $0x0,0x1024ffc
 1008ba9:	00 
 1008baa:	74 0e                	je     1008bba <schedule+0x40>
			runtime·throw("init rescheduling");
 1008bac:	b8 2f 47 02 01       	mov    $0x102472f,%eax
 1008bb1:	48 89 04 24          	mov    %rax,(%rsp)
 1008bb5:	e8 7f 11 00 00       	callq  1009d39 <runtime.throw>

		// Just finished running gp.
		gp->m = nil;
 1008bba:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1008bbf:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
 1008bc6:	00 00 00 00 
		runtime·sched.grunning--;
 1008bca:	ff 0c 25 e0 4f 02 01 	decl   0x1024fe0

		// atomic { mcpu-- }
		v = runtime·xadd(&runtime·sched.atomic, -1<<mcpuShift);
 1008bd1:	b9 f8 4f 02 01       	mov    $0x1024ff8,%ecx
 1008bd6:	48 89 0c 24          	mov    %rcx,(%rsp)
 1008bda:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 1008bdf:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1008be3:	e8 ee 8d ff ff       	callq  10019d6 <runtime.xadd>
 1008be8:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
		if(atomic_mcpu(v) > maxgomaxprocs)
 1008bed:	25 ff 7f 00 00       	and    $0x7fff,%eax
 1008bf2:	3d f5 7f 00 00       	cmp    $0x7ff5,%eax
 1008bf7:	76 13                	jbe    1008c0c <schedule+0x92>
			runtime·throw("negative mcpu in scheduler");
 1008bf9:	b8 41 47 02 01       	mov    $0x1024741,%eax
 1008bfe:	48 89 04 24          	mov    %rax,(%rsp)
 1008c02:	e8 32 11 00 00       	callq  1009d39 <runtime.throw>
 1008c07:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
			gp->idlem = nil;
			unwindstack(gp, nil);
			gfput(gp);
			if(--runtime·sched.gcount == 0)
				runtime·exit(0);
			break;
 1008c0c:	0f bf 41 70          	movswl 0x70(%rcx),%eax
 1008c10:	83 f8 01             	cmp    $0x1,%eax
 1008c13:	0f 84 dc 00 00 00    	je     1008cf5 <schedule+0x17b>
 1008c19:	83 f8 02             	cmp    $0x2,%eax
 1008c1c:	0f 84 e6 00 00 00    	je     1008d08 <schedule+0x18e>
 1008c22:	83 f8 05             	cmp    $0x5,%eax
 1008c25:	0f 84 f6 00 00 00    	je     1008d21 <schedule+0x1a7>
 1008c2b:	83 f8 06             	cmp    $0x6,%eax
 1008c2e:	0f 84 c1 00 00 00    	je     1008cf5 <schedule+0x17b>
		}
		if(gp->readyonstop){
 1008c34:	0f b6 81 88 00 00 00 	movzbl 0x88(%rcx),%eax
 1008c3b:	3c 00                	cmp    $0x0,%al
 1008c3d:	74 10                	je     1008c4f <schedule+0xd5>
			gp->readyonstop = 0;
 1008c3f:	c6 81 88 00 00 00 00 	movb   $0x0,0x88(%rcx)
			readylocked(gp);
 1008c46:	48 89 0c 24          	mov    %rcx,(%rsp)
 1008c4a:	e8 dc f7 ff ff       	callq  100842b <readylocked>
		}
	}

	// Find (or wait for) g to run.  Unlocks runtime·sched.
	gp = nextgandunlock();
 1008c4f:	e8 2c f9 ff ff       	callq  1008580 <nextgandunlock>
 1008c54:	48 89 c2             	mov    %rax,%rdx
	gp->readyonstop = 0;
 1008c57:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%rax)
	gp->status = Grunning;
 1008c5e:	66 c7 40 70 02 00    	movw   $0x2,0x70(%rax)
	m->curg = gp;
 1008c64:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008c6b:	ff ff 
 1008c6d:	48 89 50 70          	mov    %rdx,0x70(%rax)
	gp->m = m;
 1008c71:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
 1008c76:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 1008c7d:	ff ff 
 1008c7f:	48 89 8a 90 00 00 00 	mov    %rcx,0x90(%rdx)

	// Check whether the profiler needs to be turned on or off.
	hz = runtime·sched.profilehz;
 1008c86:	8b 0c 25 00 50 02 01 	mov    0x1025000,%ecx
	if(m->profilehz != hz)
 1008c8d:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008c94:	ff ff 
 1008c96:	8b 80 94 00 00 00    	mov    0x94(%rax),%eax
 1008c9c:	39 c8                	cmp    %ecx,%eax
 1008c9e:	74 0d                	je     1008cad <schedule+0x133>
		runtime·resetcpuprofiler(hz);
 1008ca0:	89 0c 24             	mov    %ecx,(%rsp)
 1008ca3:	e8 f5 27 00 00       	callq  100b49d <runtime.resetcpuprofiler>
 1008ca8:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx

	if(gp->sched.pc == (byte*)runtime·goexit) {	// kickoff
 1008cad:	48 8b 42 28          	mov    0x28(%rdx),%rax
 1008cb1:	48 3d 4c 7f 00 01    	cmp    $0x1007f4c,%rax
 1008cb7:	75 1e                	jne    1008cd7 <schedule+0x15d>
		runtime·gogocall(&gp->sched, (void(*)(void))gp->entry);
 1008cb9:	48 89 d0             	mov    %rdx,%rax
 1008cbc:	48 83 c0 20          	add    $0x20,%rax
 1008cc0:	48 89 04 24          	mov    %rax,(%rsp)
 1008cc4:	48 8b 42 58          	mov    0x58(%rdx),%rax
 1008cc8:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1008ccd:	e8 b8 8a ff ff       	callq  100178a <runtime.gogocall>
 1008cd2:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
	}
	runtime·gogo(&gp->sched, 0);
 1008cd7:	48 89 d0             	mov    %rdx,%rax
 1008cda:	48 83 c0 20          	add    $0x20,%rax
 1008cde:	48 89 04 24          	mov    %rax,(%rsp)
 1008ce2:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
 1008ce9:	00 00 
 1008ceb:	e8 77 8a ff ff       	callq  1001767 <runtime.gogo>
 1008cf0:	48 83 c4 28          	add    $0x28,%rsp
 1008cf4:	c3                   	retq   

		switch(gp->status){
		case Grunnable:
		case Gdead:
			// Shouldn't have been running!
			runtime·throw("bad gp->status in sched");
 1008cf5:	b8 5c 47 02 01       	mov    $0x102475c,%eax
 1008cfa:	48 89 04 24          	mov    %rax,(%rsp)
 1008cfe:	e8 36 10 00 00       	callq  1009d39 <runtime.throw>
 1008d03:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
		case Grunning:
			gp->status = Grunnable;
 1008d08:	66 c7 41 70 01 00    	movw   $0x1,0x70(%rcx)
			gput(gp);
 1008d0e:	48 89 0c 24          	mov    %rcx,(%rsp)
 1008d12:	e8 11 f4 ff ff       	callq  1008128 <gput>
 1008d17:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
			gfput(gp);
			if(--runtime·sched.gcount == 0)
				runtime·exit(0);
			break;
		}
		if(gp->readyonstop){
 1008d1c:	e9 13 ff ff ff       	jmpq   1008c34 <schedule+0xba>
		case Grunning:
			gp->status = Grunnable;
			gput(gp);
			break;
		case Gmoribund:
			gp->status = Gdead;
 1008d21:	66 c7 41 70 06 00    	movw   $0x6,0x70(%rcx)
			if(gp->lockedm) {
 1008d27:	48 8b 81 98 00 00 00 	mov    0x98(%rcx),%rax
 1008d2e:	48 83 f8 00          	cmp    $0x0,%rax
 1008d32:	74 1f                	je     1008d53 <schedule+0x1d9>
				gp->lockedm = nil;
 1008d34:	48 c7 81 98 00 00 00 	movq   $0x0,0x98(%rcx)
 1008d3b:	00 00 00 00 
				m->lockedg = nil;
 1008d3f:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008d46:	ff ff 
 1008d48:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
 1008d4f:	00 00 00 00 
			}
			gp->idlem = nil;
 1008d53:	48 c7 81 a0 00 00 00 	movq   $0x0,0xa0(%rcx)
 1008d5a:	00 00 00 00 
			unwindstack(gp, nil);
 1008d5e:	48 89 0c 24          	mov    %rcx,(%rsp)
 1008d62:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
 1008d69:	00 00 
 1008d6b:	e8 8a 07 00 00       	callq  10094fa <unwindstack>
			gfput(gp);
 1008d70:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1008d75:	48 89 04 24          	mov    %rax,(%rsp)
 1008d79:	e8 3d 0b 00 00       	callq  10098bb <gfput>
 1008d7e:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
			if(--runtime·sched.gcount == 0)
 1008d83:	ff 0c 25 dc 4f 02 01 	decl   0x1024fdc
 1008d8a:	8b 04 25 dc 4f 02 01 	mov    0x1024fdc,%eax
 1008d91:	83 f8 00             	cmp    $0x0,%eax
 1008d94:	0f 85 9a fe ff ff    	jne    1008c34 <schedule+0xba>
				runtime·exit(0);
 1008d9a:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
 1008da1:	e8 cb 39 00 00       	callq  100c771 <runtime.exit>
 1008da6:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
			break;
		}
		if(gp->readyonstop){
 1008dab:	e9 84 fe ff ff       	jmpq   1008c34 <schedule+0xba>

0000000001008db0 <runtime.gosched>:
// kills off g.
// Cannot split stack because it is called from exitsyscall.
// See comment below.
#pragma textflag 7
void
runtime·gosched(void)
 1008db0:	48 83 ec 10          	sub    $0x10,%rsp
{
	if(m->locks != 0)
 1008db4:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008dbb:	ff ff 
 1008dbd:	8b 80 84 00 00 00    	mov    0x84(%rax),%eax
 1008dc3:	83 f8 00             	cmp    $0x0,%eax
 1008dc6:	74 0e                	je     1008dd6 <runtime.gosched+0x26>
		runtime·throw("gosched holding locks");
 1008dc8:	b8 74 47 02 01       	mov    $0x1024774,%eax
 1008dcd:	48 89 04 24          	mov    %rax,(%rsp)
 1008dd1:	e8 63 0f 00 00       	callq  1009d39 <runtime.throw>
	if(g == m->g0)
 1008dd6:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1008ddd:	ff ff 
 1008ddf:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 1008de6:	ff ff 
 1008de8:	48 8b 09             	mov    (%rcx),%rcx
 1008deb:	48 39 c8             	cmp    %rcx,%rax
 1008dee:	75 0e                	jne    1008dfe <runtime.gosched+0x4e>
		runtime·throw("gosched of g0");
 1008df0:	b8 8a 47 02 01       	mov    $0x102478a,%eax
 1008df5:	48 89 04 24          	mov    %rax,(%rsp)
 1008df9:	e8 3b 0f 00 00       	callq  1009d39 <runtime.throw>
	runtime·mcall(schedule);
 1008dfe:	b8 7a 8b 00 01       	mov    $0x1008b7a,%eax
 1008e03:	48 89 04 24          	mov    %rax,(%rsp)
 1008e07:	e8 a2 89 ff ff       	callq  10017ae <runtime.mcall>
 1008e0c:	48 83 c4 10          	add    $0x10,%rsp
 1008e10:	c3                   	retq   

0000000001008e11 <runtime.oldstack>:
	// is not running.
	g->gcstack = nil;
}

void
runtime·oldstack(void)
 1008e11:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1008e18:	ff ff 
 1008e1a:	48 8d 44 24 e8       	lea    -0x18(%rsp),%rax
 1008e1f:	48 3b 01             	cmp    (%rcx),%rax
 1008e22:	77 05                	ja     1008e29 <runtime.oldstack+0x18>
 1008e24:	e8 ca 8a ff ff       	callq  10018f3 <runtime.morestack00>
 1008e29:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
	G *g1;
	int32 goid;

//printf("oldstack m->cret=%p\n", m->cret);

	g1 = m->curg;
 1008e30:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008e37:	ff ff 
 1008e39:	48 8b 68 70          	mov    0x70(%rax),%rbp
	top = (Stktop*)g1->stackbase;
 1008e3d:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
 1008e42:	48 8b 5d 08          	mov    0x8(%rbp),%rbx
	sp = (byte*)top;
 1008e46:	48 89 de             	mov    %rbx,%rsi
	old = *top;
 1008e49:	48 89 da             	mov    %rbx,%rdx
 1008e4c:	48 8d 7c 24 48       	lea    0x48(%rsp),%rdi
 1008e51:	b9 12 00 00 00       	mov    $0x12,%ecx
 1008e56:	fc                   	cld    
 1008e57:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
	argsize = old.argsize;
 1008e59:	8b 4c 24 70          	mov    0x70(%rsp),%ecx
	if(argsize > 0) {
 1008e5d:	83 f9 00             	cmp    $0x0,%ecx
 1008e60:	76 1e                	jbe    1008e80 <runtime.oldstack+0x6f>
		sp -= argsize;
 1008e62:	48 29 cb             	sub    %rcx,%rbx
		runtime·memmove(top->argp, sp, argsize);
 1008e65:	48 8b 42 30          	mov    0x30(%rdx),%rax
 1008e69:	48 89 04 24          	mov    %rax,(%rsp)
 1008e6d:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 1008e72:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 1008e76:	e8 57 b0 ff ff       	callq  1003ed2 <runtime.memmove>
 1008e7b:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
	}
	goid = old.gobuf.g->goid;	// fault if g is bad, before gogo
 1008e80:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
 1008e85:	8b 40 74             	mov    0x74(%rax),%eax
	USED(goid);

	if(old.free != 0)
 1008e88:	48 83 bc 24 80 00 00 	cmpq   $0x0,0x80(%rsp)
 1008e8f:	00 00 
 1008e91:	74 25                	je     1008eb8 <runtime.oldstack+0xa7>
		runtime·stackfree(g1->stackguard - StackGuard, old.free);
 1008e93:	48 8b 45 00          	mov    0x0(%rbp),%rax
 1008e97:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 1008e9d:	48 89 04 24          	mov    %rax,(%rsp)
 1008ea1:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
 1008ea8:	00 
 1008ea9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1008eae:	e8 d9 a3 ff ff       	callq  100328c <runtime.stackfree>
 1008eb3:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
	g1->stackbase = old.stackbase;
 1008eb8:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 1008ebd:	48 89 4d 08          	mov    %rcx,0x8(%rbp)
	g1->stackguard = old.stackguard;
 1008ec1:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 1008ec6:	48 89 4d 00          	mov    %rcx,0x0(%rbp)

	runtime·gogo(&old.gobuf, m->cret);
 1008eca:	48 8d 44 24 58       	lea    0x58(%rsp),%rax
 1008ecf:	48 89 04 24          	mov    %rax,(%rsp)
 1008ed3:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008eda:	ff ff 
 1008edc:	48 8b 40 38          	mov    0x38(%rax),%rax
 1008ee0:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1008ee5:	e8 7d 88 ff ff       	callq  1001767 <runtime.gogo>
 1008eea:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
 1008ef1:	c3                   	retq   

0000000001008ef2 <runtime.newstack>:
}

void
runtime·newstack(void)
 1008ef2:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1008ef9:	ff ff 
 1008efb:	48 3b 21             	cmp    (%rcx),%rsp
 1008efe:	77 05                	ja     1008f05 <runtime.newstack+0x13>
 1008f00:	e8 ee 89 ff ff       	callq  10018f3 <runtime.morestack00>
 1008f05:	48 83 ec 78          	sub    $0x78,%rsp
	G *g1;
	Gobuf label;
	bool reflectcall;
	uintptr free;

	framesize = m->moreframesize;
 1008f09:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008f10:	ff ff 
 1008f12:	8b 58 30             	mov    0x30(%rax),%ebx
 1008f15:	89 5c 24 74          	mov    %ebx,0x74(%rsp)
	argsize = m->moreargsize;
 1008f19:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008f20:	ff ff 
 1008f22:	8b 70 34             	mov    0x34(%rax),%esi
 1008f25:	89 74 24 70          	mov    %esi,0x70(%rsp)
	g1 = m->curg;
 1008f29:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008f30:	ff ff 
 1008f32:	48 8b 68 70          	mov    0x70(%rax),%rbp

	if(m->morebuf.sp < g1->stackguard - StackGuard) {
 1008f36:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008f3d:	ff ff 
 1008f3f:	48 8b 40 18          	mov    0x18(%rax),%rax
 1008f43:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
 1008f48:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 1008f4c:	48 81 c1 00 ff ff ff 	add    $0xffffffffffffff00,%rcx
 1008f53:	48 39 c8             	cmp    %rcx,%rax
 1008f56:	73 4a                	jae    1008fa2 <runtime.newstack+0xb0>
		runtime·printf("runtime: split stack overflow: %p < %p\n", m->morebuf.sp, g1->stackguard - StackGuard);
 1008f58:	b8 a5 47 02 01       	mov    $0x10247a5,%eax
 1008f5d:	48 89 04 24          	mov    %rax,(%rsp)
 1008f61:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1008f68:	ff ff 
 1008f6a:	48 8b 40 18          	mov    0x18(%rax),%rax
 1008f6e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1008f73:	48 8b 45 00          	mov    0x0(%rbp),%rax
 1008f77:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 1008f7d:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1008f82:	e8 b7 e3 ff ff       	callq  100733e <runtime.printf>
		runtime·throw("runtime: split stack overflow");
 1008f87:	b8 cd 47 02 01       	mov    $0x10247cd,%eax
 1008f8c:	48 89 04 24          	mov    %rax,(%rsp)
 1008f90:	e8 a4 0d 00 00       	callq  1009d39 <runtime.throw>
 1008f95:	8b 5c 24 74          	mov    0x74(%rsp),%ebx
 1008f99:	8b 74 24 70          	mov    0x70(%rsp),%esi
 1008f9d:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
	}
	if(argsize % sizeof(uintptr) != 0) {
 1008fa2:	89 f0                	mov    %esi,%eax
 1008fa4:	99                   	cltd   
 1008fa5:	83 e2 07             	and    $0x7,%edx
 1008fa8:	01 d0                	add    %edx,%eax
 1008faa:	83 e0 07             	and    $0x7,%eax
 1008fad:	29 d0                	sub    %edx,%eax
 1008faf:	83 f8 00             	cmp    $0x0,%eax
 1008fb2:	74 2d                	je     1008fe1 <runtime.newstack+0xef>
		runtime·printf("runtime: stack split with misaligned argsize %d\n", argsize);
 1008fb4:	b8 eb 47 02 01       	mov    $0x10247eb,%eax
 1008fb9:	48 89 04 24          	mov    %rax,(%rsp)
 1008fbd:	89 74 24 08          	mov    %esi,0x8(%rsp)
 1008fc1:	e8 78 e3 ff ff       	callq  100733e <runtime.printf>
		runtime·throw("runtime: stack split argsize");
 1008fc6:	b8 1c 48 02 01       	mov    $0x102481c,%eax
 1008fcb:	48 89 04 24          	mov    %rax,(%rsp)
 1008fcf:	e8 65 0d 00 00       	callq  1009d39 <runtime.throw>
 1008fd4:	8b 5c 24 74          	mov    0x74(%rsp),%ebx
 1008fd8:	8b 74 24 70          	mov    0x70(%rsp),%esi
 1008fdc:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
	}

	reflectcall = framesize==1;
 1008fe1:	83 fb 01             	cmp    $0x1,%ebx
 1008fe4:	0f 85 97 01 00 00    	jne    1009181 <runtime.newstack+0x28f>
 1008fea:	b8 01 00 00 00       	mov    $0x1,%eax
 1008fef:	88 c1                	mov    %al,%cl
	if(reflectcall)
 1008ff1:	80 f9 00             	cmp    $0x0,%cl
 1008ff4:	74 02                	je     1008ff8 <runtime.newstack+0x106>
		framesize = 0;
 1008ff6:	31 db                	xor    %ebx,%ebx

	if(reflectcall && m->morebuf.sp - sizeof(Stktop) - argsize - 32 > g1->stackguard) {
 1008ff8:	80 f9 00             	cmp    $0x0,%cl
 1008ffb:	74 24                	je     1009021 <runtime.newstack+0x12f>
 1008ffd:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1009004:	ff ff 
 1009006:	48 8b 40 18          	mov    0x18(%rax),%rax
 100900a:	48 63 ce             	movslq %esi,%rcx
 100900d:	48 29 c8             	sub    %rcx,%rax
 1009010:	48 83 c0 98          	add    $0xffffffffffffff98,%rax
 1009014:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 1009018:	48 39 c8             	cmp    %rcx,%rax
 100901b:	0f 87 3c 01 00 00    	ja     100915d <runtime.newstack+0x26b>
		top = (Stktop*)(m->morebuf.sp - sizeof(*top));
		stk = g1->stackguard - StackGuard;
		free = 0;
	} else {
		// allocate new segment.
		framesize += argsize;
 1009021:	01 f3                	add    %esi,%ebx
		framesize += StackExtra;	// room for more functions, Stktop.
 1009023:	81 c3 00 04 00 00    	add    $0x400,%ebx
		if(framesize < StackMin)
 1009029:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
 100902f:	7d 05                	jge    1009036 <runtime.newstack+0x144>
			framesize = StackMin;
 1009031:	bb 00 10 00 00       	mov    $0x1000,%ebx
		framesize += StackSystem;
 1009036:	83 c3 00             	add    $0x0,%ebx
		stk = runtime·stackalloc(framesize);
 1009039:	89 5c 24 74          	mov    %ebx,0x74(%rsp)
 100903d:	89 1c 24             	mov    %ebx,(%rsp)
 1009040:	e8 5d a1 ff ff       	callq  10031a2 <runtime.stackalloc>
 1009045:	44 8b 44 24 74       	mov    0x74(%rsp),%r8d
 100904a:	8b 74 24 70          	mov    0x70(%rsp),%esi
 100904e:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
 1009053:	48 89 c7             	mov    %rax,%rdi
		top = (Stktop*)(stk+framesize-sizeof(*top));
 1009056:	49 63 c8             	movslq %r8d,%rcx
 1009059:	48 8d 04 08          	lea    (%rax,%rcx,1),%rax
 100905d:	48 83 c0 b8          	add    $0xffffffffffffffb8,%rax
 1009061:	48 89 c3             	mov    %rax,%rbx
		free = framesize;
 1009064:	49 63 c0             	movslq %r8d,%rax
 1009067:	49 89 c0             	mov    %rax,%r8
	}

//runtime·printf("newstack framesize=%d argsize=%d morepc=%p moreargp=%p gobuf=%p, %p top=%p old=%p\n",
//framesize, argsize, m->morepc, m->moreargp, m->morebuf.pc, m->morebuf.sp, top, g1->stackbase);

	top->stackbase = g1->stackbase;
 100906a:	48 8b 4d 08          	mov    0x8(%rbp),%rcx
 100906e:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	top->stackguard = g1->stackguard;
 1009072:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 1009076:	48 89 0b             	mov    %rcx,(%rbx)
	top->gobuf = m->morebuf;
 1009079:	64 48 8b 14 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rdx
 1009080:	ff ff 
 1009082:	48 8b 42 18          	mov    0x18(%rdx),%rax
 1009086:	48 89 43 10          	mov    %rax,0x10(%rbx)
 100908a:	48 8b 42 20          	mov    0x20(%rdx),%rax
 100908e:	48 89 43 18          	mov    %rax,0x18(%rbx)
 1009092:	48 8b 42 28          	mov    0x28(%rdx),%rax
 1009096:	48 89 43 20          	mov    %rax,0x20(%rbx)
	top->argp = m->moreargp;
 100909a:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 10090a1:	ff ff 
 10090a3:	48 8b 49 10          	mov    0x10(%rcx),%rcx
 10090a7:	48 89 4b 30          	mov    %rcx,0x30(%rbx)
	top->argsize = argsize;
 10090ab:	89 73 28             	mov    %esi,0x28(%rbx)
	top->free = free;
 10090ae:	4c 89 43 38          	mov    %r8,0x38(%rbx)

	// copy flag from panic
	top->panic = g1->ispanic;
 10090b2:	0f b6 8d 89 00 00 00 	movzbl 0x89(%rbp),%ecx
 10090b9:	88 4b 40             	mov    %cl,0x40(%rbx)
	g1->ispanic = false;
 10090bc:	c6 85 89 00 00 00 00 	movb   $0x0,0x89(%rbp)

	g1->stackbase = (byte*)top;
 10090c3:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
	g1->stackguard = stk + StackGuard;
 10090c7:	48 89 f9             	mov    %rdi,%rcx
 10090ca:	48 81 c1 00 01 00 00 	add    $0x100,%rcx
 10090d1:	48 89 4d 00          	mov    %rcx,0x0(%rbp)

	sp = (byte*)top;
 10090d5:	48 89 d9             	mov    %rbx,%rcx
	if(argsize > 0) {
 10090d8:	83 fe 00             	cmp    $0x0,%esi
 10090db:	7e 2f                	jle    100910c <runtime.newstack+0x21a>
		sp -= argsize;
 10090dd:	48 63 c6             	movslq %esi,%rax
 10090e0:	48 29 c1             	sub    %rax,%rcx
		runtime·memmove(sp, m->moreargp, argsize);
 10090e3:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
 10090e8:	48 89 0c 24          	mov    %rcx,(%rsp)
 10090ec:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 10090f3:	ff ff 
 10090f5:	48 8b 40 10          	mov    0x10(%rax),%rax
 10090f9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10090fe:	89 74 24 10          	mov    %esi,0x10(%rsp)
 1009102:	e8 cb ad ff ff       	callq  1003ed2 <runtime.memmove>
 1009107:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
		*(void**)sp = nil;
	}

	// Continue as if lessstack had just called m->morepc
	// (the PC that decided to grow the stack).
	label.sp = sp;
 100910c:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
	label.pc = (byte*)runtime·lessstack;
 1009111:	b8 c4 18 00 01       	mov    $0x10018c4,%eax
 1009116:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
	label.g = m->curg;
 100911b:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1009122:	ff ff 
 1009124:	48 8b 40 70          	mov    0x70(%rax),%rax
 1009128:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
	runtime·gogocall(&label, m->morepc);
 100912d:	48 8d 44 24 38       	lea    0x38(%rsp),%rax
 1009132:	48 89 04 24          	mov    %rax,(%rsp)
 1009136:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100913d:	ff ff 
 100913f:	48 8b 40 08          	mov    0x8(%rax),%rax
 1009143:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009148:	e8 3d 86 ff ff       	callq  100178a <runtime.gogocall>

	*(int32*)345 = 123;	// never return
 100914d:	c7 04 25 59 01 00 00 	movl   $0x7b,0x159
 1009154:	7b 00 00 00 
 1009158:	48 83 c4 78          	add    $0x78,%rsp
 100915c:	c3                   	retq   
		// special case: called from reflect.call (framesize==1)
		// to call code with an arbitrary argument size,
		// and we have enough space on the current stack.
		// the new Stktop* is necessary to unwind, but
		// we don't need to create a new segment.
		top = (Stktop*)(m->morebuf.sp - sizeof(*top));
 100915d:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1009164:	ff ff 
 1009166:	48 8b 58 18          	mov    0x18(%rax),%rbx
 100916a:	48 83 c3 b8          	add    $0xffffffffffffffb8,%rbx
		stk = g1->stackguard - StackGuard;
 100916e:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
 1009172:	48 81 c7 00 ff ff ff 	add    $0xffffffffffffff00,%rdi
		free = 0;
 1009179:	4d 31 c0             	xor    %r8,%r8
	}

//runtime·printf("newstack framesize=%d argsize=%d morepc=%p moreargp=%p gobuf=%p, %p top=%p old=%p\n",
//framesize, argsize, m->morepc, m->moreargp, m->morebuf.pc, m->morebuf.sp, top, g1->stackbase);

	top->stackbase = g1->stackbase;
 100917c:	e9 e9 fe ff ff       	jmpq   100906a <runtime.newstack+0x178>
	if(argsize % sizeof(uintptr) != 0) {
		runtime·printf("runtime: stack split with misaligned argsize %d\n", argsize);
		runtime·throw("runtime: stack split argsize");
	}

	reflectcall = framesize==1;
 1009181:	31 c0                	xor    %eax,%eax
 1009183:	e9 67 fe ff ff       	jmpq   1008fef <runtime.newstack+0xfd>

0000000001009188 <mstackalloc>:

	*(int32*)345 = 123;	// never return
}

static void
mstackalloc(G *gp)
 1009188:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100918f:	ff ff 
 1009191:	48 3b 21             	cmp    (%rcx),%rsp
 1009194:	77 05                	ja     100919b <mstackalloc+0x13>
 1009196:	e8 b1 87 ff ff       	callq  100194c <runtime.morestack8>
 100919b:	48 83 ec 18          	sub    $0x18,%rsp
{
	gp->param = runtime·stackalloc((uintptr)gp->param);
 100919f:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 10091a4:	48 8b 49 68          	mov    0x68(%rcx),%rcx
 10091a8:	89 0c 24             	mov    %ecx,(%rsp)
 10091ab:	e8 f2 9f ff ff       	callq  10031a2 <runtime.stackalloc>
 10091b0:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
 10091b5:	48 89 42 68          	mov    %rax,0x68(%rdx)
	runtime·gogo(&gp->sched, 0);
 10091b9:	48 89 d0             	mov    %rdx,%rax
 10091bc:	48 83 c0 20          	add    $0x20,%rax
 10091c0:	48 89 04 24          	mov    %rax,(%rsp)
 10091c4:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
 10091cb:	00 00 
 10091cd:	e8 95 85 ff ff       	callq  1001767 <runtime.gogo>
 10091d2:	48 83 c4 18          	add    $0x18,%rsp
 10091d6:	c3                   	retq   

00000000010091d7 <runtime.malg>:
}

G*
runtime·malg(int32 stacksize)
 10091d7:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10091de:	ff ff 
 10091e0:	48 3b 21             	cmp    (%rcx),%rsp
 10091e3:	77 05                	ja     10091ea <runtime.malg+0x13>
 10091e5:	e8 62 87 ff ff       	callq  100194c <runtime.morestack8>
 10091ea:	48 83 ec 30          	sub    $0x30,%rsp
{
	G *newg;
	byte *stk;

	newg = runtime·malloc(sizeof(G));
 10091ee:	48 c7 c1 d0 00 00 00 	mov    $0xd0,%rcx
 10091f5:	48 89 0c 24          	mov    %rcx,(%rsp)
 10091f9:	e8 8d 98 ff ff       	callq  1002a8b <runtime.malloc>
 10091fe:	8b 54 24 38          	mov    0x38(%rsp),%edx
 1009202:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	if(stacksize >= 0) {
 1009207:	83 fa 00             	cmp    $0x0,%edx
 100920a:	7c 6a                	jl     1009276 <runtime.malg+0x9f>
		if(g == m->g0) {
 100920c:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009213:	ff ff 
 1009215:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 100921c:	ff ff 
 100921e:	48 8b 09             	mov    (%rcx),%rcx
 1009221:	48 39 c8             	cmp    %rcx,%rax
 1009224:	75 5a                	jne    1009280 <runtime.malg+0xa9>
			// running on scheduler stack already.
			stk = runtime·stackalloc(StackSystem + stacksize);
 1009226:	89 14 24             	mov    %edx,(%rsp)
 1009229:	e8 74 9f ff ff       	callq  10031a2 <runtime.stackalloc>
 100922e:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
 1009233:	48 89 c5             	mov    %rax,%rbp
			g->param = (void*)(StackSystem + stacksize);
			runtime·mcall(mstackalloc);
			stk = g->param;
			g->param = nil;
		}
		newg->stack0 = stk;
 1009236:	48 89 6e 50          	mov    %rbp,0x50(%rsi)
		newg->stackguard = stk + StackGuard;
 100923a:	48 89 e9             	mov    %rbp,%rcx
 100923d:	48 81 c1 00 01 00 00 	add    $0x100,%rcx
 1009244:	48 89 0e             	mov    %rcx,(%rsi)
		newg->stackbase = stk + StackSystem + stacksize - sizeof(Stktop);
 1009247:	8b 54 24 38          	mov    0x38(%rsp),%edx
 100924b:	48 63 d2             	movslq %edx,%rdx
 100924e:	48 89 eb             	mov    %rbp,%rbx
 1009251:	48 8d 0c 13          	lea    (%rbx,%rdx,1),%rcx
 1009255:	48 83 c1 b8          	add    $0xffffffffffffffb8,%rcx
 1009259:	48 89 4e 08          	mov    %rcx,0x8(%rsi)
		runtime·memclr(newg->stackbase, sizeof(Stktop));
 100925d:	48 8b 46 08          	mov    0x8(%rsi),%rax
 1009261:	48 89 04 24          	mov    %rax,(%rsp)
 1009265:	48 c7 c0 48 00 00 00 	mov    $0x48,%rax
 100926c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009271:	e8 31 88 ff ff       	callq  1001aa7 <runtime.memclr>
	}
	return newg;
 1009276:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100927b:	48 83 c4 30          	add    $0x30,%rsp
 100927f:	c3                   	retq   
		if(g == m->g0) {
			// running on scheduler stack already.
			stk = runtime·stackalloc(StackSystem + stacksize);
		} else {
			// have to call stackalloc on scheduler stack.
			g->param = (void*)(StackSystem + stacksize);
 1009280:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009287:	ff ff 
 1009289:	48 63 ca             	movslq %edx,%rcx
 100928c:	48 89 48 68          	mov    %rcx,0x68(%rax)
			runtime·mcall(mstackalloc);
 1009290:	b8 88 91 00 01       	mov    $0x1009188,%eax
 1009295:	48 89 04 24          	mov    %rax,(%rsp)
 1009299:	e8 10 85 ff ff       	callq  10017ae <runtime.mcall>
 100929e:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
			stk = g->param;
 10092a3:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10092aa:	ff ff 
 10092ac:	48 8b 68 68          	mov    0x68(%rax),%rbp
			g->param = nil;
 10092b0:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10092b7:	ff ff 
 10092b9:	48 c7 40 68 00 00 00 	movq   $0x0,0x68(%rax)
 10092c0:	00 
		}
		newg->stack0 = stk;
 10092c1:	e9 70 ff ff ff       	jmpq   1009236 <runtime.malg+0x5f>

00000000010092c6 <runtime.newproc>:
 * arg0 would be copied.  It's okay if any functions
 * they call split the stack below the newproc frame.
 */
#pragma textflag 7
void
runtime·newproc(int32 siz, byte* fn, ...)
 10092c6:	48 83 ec 40          	sub    $0x40,%rsp
	byte *argp;

	if(thechar == '5')
		argp = (byte*)(&fn+2);  // skip caller's saved LR
	else
		argp = (byte*)(&fn+1);
 10092ca:	48 8d 44 24 58       	lea    0x58(%rsp),%rax
 10092cf:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
	runtime·newproc1(fn, argp, siz, 0, runtime·getcallerpc(&siz));
 10092d4:	48 8d 4c 24 48       	lea    0x48(%rsp),%rcx
 10092d9:	48 89 0c 24          	mov    %rcx,(%rsp)
 10092dd:	e8 e7 87 ff ff       	callq  1001ac9 <runtime.getcallerpc>
 10092e2:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 10092e7:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 10092ec:	48 89 04 24          	mov    %rax,(%rsp)
 10092f0:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 10092f5:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10092fa:	8b 44 24 48          	mov    0x48(%rsp),%eax
 10092fe:	89 44 24 10          	mov    %eax,0x10(%rsp)
 1009302:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%rsp)
 1009309:	00 
 100930a:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100930f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1009314:	e8 05 00 00 00       	callq  100931e <runtime.newproc1>
 1009319:	48 83 c4 40          	add    $0x40,%rsp
 100931d:	c3                   	retq   

000000000100931e <runtime.newproc1>:
}

G*
runtime·newproc1(byte *fn, byte *argp, int32 narg, int32 nret, void *callerpc)
 100931e:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009325:	ff ff 
 1009327:	48 3b 21             	cmp    (%rcx),%rsp
 100932a:	77 05                	ja     1009331 <runtime.newproc1+0x13>
 100932c:	e8 36 86 ff ff       	callq  1001967 <runtime.morestack32>
 1009331:	48 83 ec 40          	sub    $0x40,%rsp
	byte *sp;
	G *newg;
	int32 siz;

//printf("newproc1 %p %p narg=%d nret=%d\n", fn, argp, narg, nret);
	siz = narg + nret;
 1009335:	8b 44 24 58          	mov    0x58(%rsp),%eax
 1009339:	03 44 24 5c          	add    0x5c(%rsp),%eax
	siz = (siz+7) & ~7;
 100933d:	83 c0 07             	add    $0x7,%eax
 1009340:	83 e0 f8             	and    $0xfffffffffffffff8,%eax
	
	// We could instead create a secondary stack frame
	// and make it look like goexit was on the original but
	// the call to the actual goroutine function was split.
	// Not worth it: this is almost always an error.
	if(siz > StackMin - 1024)
 1009343:	3d 00 0c 00 00       	cmp    $0xc00,%eax
 1009348:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
 100934c:	7e 0e                	jle    100935c <runtime.newproc1+0x3e>
		runtime·throw("runtime.newproc: function arguments too large for new goroutine");
 100934e:	b8 39 48 02 01       	mov    $0x1024839,%eax
 1009353:	48 89 04 24          	mov    %rax,(%rsp)
 1009357:	e8 dd 09 00 00       	callq  1009d39 <runtime.throw>

	schedlock();
 100935c:	e8 2b eb ff ff       	callq  1007e8c <schedlock>

	if((newg = gfget()) != nil){
 1009361:	e8 b2 05 00 00       	callq  1009918 <gfget>
 1009366:	48 89 c2             	mov    %rax,%rdx
 1009369:	48 83 f8 00          	cmp    $0x0,%rax
 100936d:	0f 84 c3 00 00 00    	je     1009436 <runtime.newproc1+0x118>
		newg->status = Gwaiting;
 1009373:	66 c7 40 70 04 00    	movw   $0x4,0x70(%rax)
		if(newg->stackguard - StackGuard != newg->stack0)
 1009379:	48 8b 00             	mov    (%rax),%rax
 100937c:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 1009382:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
 1009387:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
 100938b:	48 39 c8             	cmp    %rcx,%rax
 100938e:	74 13                	je     10093a3 <runtime.newproc1+0x85>
			runtime·throw("invalid stack in newg");
 1009390:	b8 79 48 02 01       	mov    $0x1024879,%eax
 1009395:	48 89 04 24          	mov    %rax,(%rsp)
 1009399:	e8 9b 09 00 00       	callq  1009d39 <runtime.throw>
 100939e:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
		newg->status = Gwaiting;
		newg->alllink = runtime·allg;
		runtime·allg = newg;
	}

	sp = newg->stackbase;
 10093a3:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
 10093a8:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
	sp -= siz;
 10093ac:	8b 44 24 2c          	mov    0x2c(%rsp),%eax
 10093b0:	48 63 c0             	movslq %eax,%rax
 10093b3:	48 29 c1             	sub    %rax,%rcx
	runtime·memmove(sp, argp, narg);
 10093b6:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
 10093bb:	48 89 0c 24          	mov    %rcx,(%rsp)
 10093bf:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 10093c4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10093c9:	8b 44 24 58          	mov    0x58(%rsp),%eax
 10093cd:	89 44 24 10          	mov    %eax,0x10(%rsp)
 10093d1:	e8 fc aa ff ff       	callq  1003ed2 <runtime.memmove>
 10093d6:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
		// caller's LR
		sp -= sizeof(void*);
		*(void**)sp = nil;
	}

	newg->sched.sp = sp;
 10093db:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 10093e0:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
	newg->sched.pc = (byte*)runtime·goexit;
 10093e4:	b9 4c 7f 00 01       	mov    $0x1007f4c,%ecx
 10093e9:	48 89 4a 28          	mov    %rcx,0x28(%rdx)
	newg->sched.g = newg;
 10093ed:	48 89 52 30          	mov    %rdx,0x30(%rdx)
	newg->entry = fn;
 10093f1:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 10093f6:	48 89 4a 58          	mov    %rcx,0x58(%rdx)
	newg->gopc = (uintptr)callerpc;
 10093fa:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
 10093ff:	48 89 8a c8 00 00 00 	mov    %rcx,0xc8(%rdx)

	runtime·sched.gcount++;
 1009406:	ff 04 25 dc 4f 02 01 	incl   0x1024fdc
	runtime·sched.goidgen++;
 100940d:	ff 04 25 c0 4f 02 01 	incl   0x1024fc0
	newg->goid = runtime·sched.goidgen;
 1009414:	8b 0c 25 c0 4f 02 01 	mov    0x1024fc0,%ecx
 100941b:	89 4a 74             	mov    %ecx,0x74(%rdx)

	newprocreadylocked(newg);
 100941e:	48 89 14 24          	mov    %rdx,(%rsp)
 1009422:	e8 b4 f0 ff ff       	callq  10084db <newprocreadylocked>
	schedunlock();
 1009427:	e8 8a ea ff ff       	callq  1007eb6 <schedunlock>

	return newg;
 100942c:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1009431:	48 83 c4 40          	add    $0x40,%rsp
 1009435:	c3                   	retq   
	if((newg = gfget()) != nil){
		newg->status = Gwaiting;
		if(newg->stackguard - StackGuard != newg->stack0)
			runtime·throw("invalid stack in newg");
	} else {
		newg = runtime·malg(StackMin);
 1009436:	b9 00 10 00 00       	mov    $0x1000,%ecx
 100943b:	89 0c 24             	mov    %ecx,(%rsp)
 100943e:	e8 94 fd ff ff       	callq  10091d7 <runtime.malg>
 1009443:	48 89 c2             	mov    %rax,%rdx
		newg->status = Gwaiting;
 1009446:	66 c7 40 70 04 00    	movw   $0x4,0x70(%rax)
		newg->alllink = runtime·allg;
 100944c:	48 8b 0c 25 d8 4e 02 	mov    0x1024ed8,%rcx
 1009453:	01 
 1009454:	48 89 48 60          	mov    %rcx,0x60(%rax)
		runtime·allg = newg;
 1009458:	48 89 04 25 d8 4e 02 	mov    %rax,0x1024ed8
 100945f:	01 
	}

	sp = newg->stackbase;
 1009460:	e9 3e ff ff ff       	jmpq   10093a3 <runtime.newproc1+0x85>

0000000001009465 <runtime.deferproc>:
//printf(" goid=%d\n", newg->goid);
}

#pragma textflag 7
uintptr
runtime·deferproc(int32 siz, byte* fn, ...)
 1009465:	48 83 ec 30          	sub    $0x30,%rsp
{
	Defer *d;

	d = runtime·malloc(sizeof(*d) + siz - sizeof(d->args));
 1009469:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
 100946d:	83 c1 28             	add    $0x28,%ecx
 1009470:	48 63 c9             	movslq %ecx,%rcx
 1009473:	48 89 0c 24          	mov    %rcx,(%rsp)
 1009477:	e8 0f 96 ff ff       	callq  1002a8b <runtime.malloc>
	d->fn = fn;
 100947c:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 1009481:	48 89 48 18          	mov    %rcx,0x18(%rax)
	d->siz = siz;
 1009485:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 100948a:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
 100948e:	89 08                	mov    %ecx,(%rax)
	d->pc = runtime·getcallerpc(&siz);
 1009490:	48 8d 4c 24 38       	lea    0x38(%rsp),%rcx
 1009495:	48 89 0c 24          	mov    %rcx,(%rsp)
 1009499:	e8 2b 86 ff ff       	callq  1001ac9 <runtime.getcallerpc>
 100949e:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 10094a3:	48 89 42 10          	mov    %rax,0x10(%rdx)
	if(thechar == '5')
		d->argp = (byte*)(&fn+2);  // skip caller's saved link register
	else
		d->argp = (byte*)(&fn+1);
 10094a7:	48 8d 4c 24 48       	lea    0x48(%rsp),%rcx
 10094ac:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	runtime·memmove(d->args, d->argp, d->siz);
 10094b0:	48 89 d0             	mov    %rdx,%rax
 10094b3:	48 83 c0 28          	add    $0x28,%rax
 10094b7:	48 89 04 24          	mov    %rax,(%rsp)
 10094bb:	48 8b 42 08          	mov    0x8(%rdx),%rax
 10094bf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10094c4:	8b 02                	mov    (%rdx),%eax
 10094c6:	89 44 24 10          	mov    %eax,0x10(%rsp)
 10094ca:	e8 03 aa ff ff       	callq  1003ed2 <runtime.memmove>
 10094cf:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx

	d->link = g->defer;
 10094d4:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10094db:	ff ff 
 10094dd:	48 8b 49 10          	mov    0x10(%rcx),%rcx
 10094e1:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
	g->defer = d;
 10094e5:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10094ec:	ff ff 
 10094ee:	48 89 50 10          	mov    %rdx,0x10(%rax)
	// a deferred func that stops a panic
	// makes the deferproc return 1.
	// the code the compiler generates always
	// checks the return value and jumps to the
	// end of the function if deferproc returns != 0.
	return 0;
 10094f2:	48 31 c0             	xor    %rax,%rax
 10094f5:	48 83 c4 30          	add    $0x30,%rsp
 10094f9:	c3                   	retq   

00000000010094fa <unwindstack>:
}

// Free stack frames until we hit the last one
// or until we find the one that contains the argp.
static void
unwindstack(G *gp, byte *sp)
 10094fa:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009501:	ff ff 
 1009503:	48 3b 21             	cmp    (%rcx),%rsp
 1009506:	77 05                	ja     100950d <unwindstack+0x13>
 1009508:	e8 48 84 ff ff       	callq  1001955 <runtime.morestack16>
 100950d:	48 83 ec 40          	sub    $0x40,%rsp
 1009511:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
 1009516:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
{
	Stktop *top;
	byte *stk;

	// Must be called from a different goroutine, usually m->g0.
	if(g == gp)
 100951b:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009522:	ff ff 
 1009524:	48 39 d8             	cmp    %rbx,%rax
 1009527:	75 18                	jne    1009541 <unwindstack+0x47>
		runtime·throw("unwindstack on self");
 1009529:	b8 8f 48 02 01       	mov    $0x102488f,%eax
 100952e:	48 89 04 24          	mov    %rax,(%rsp)
 1009532:	e8 02 08 00 00       	callq  1009d39 <runtime.throw>
 1009537:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
 100953c:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx

	while((top = (Stktop*)gp->stackbase) != nil && top->stackbase != nil) {
 1009541:	48 8b 53 08          	mov    0x8(%rbx),%rdx
 1009545:	48 83 fa 00          	cmp    $0x0,%rdx
 1009549:	74 0a                	je     1009555 <unwindstack+0x5b>
 100954b:	48 8b 42 08          	mov    0x8(%rdx),%rax
 100954f:	48 83 f8 00          	cmp    $0x0,%rax
 1009553:	75 5a                	jne    10095af <unwindstack+0xb5>
		gp->stackguard = top->stackguard;
		if(top->free != 0)
			runtime·stackfree(stk, top->free);
	}

	if(sp != nil && (sp < gp->stackguard - StackGuard || gp->stackbase < sp)) {
 1009555:	48 83 fe 00          	cmp    $0x0,%rsi
 1009559:	74 4f                	je     10095aa <unwindstack+0xb0>
 100955b:	48 8b 03             	mov    (%rbx),%rax
 100955e:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 1009564:	48 39 c6             	cmp    %rax,%rsi
 1009567:	72 09                	jb     1009572 <unwindstack+0x78>
 1009569:	48 8b 43 08          	mov    0x8(%rbx),%rax
 100956d:	48 39 f0             	cmp    %rsi,%rax
 1009570:	73 38                	jae    10095aa <unwindstack+0xb0>
		runtime·printf("recover: %p not in [%p, %p]\n", sp, gp->stackguard - StackGuard, gp->stackbase);
 1009572:	b8 a3 48 02 01       	mov    $0x10248a3,%eax
 1009577:	48 89 04 24          	mov    %rax,(%rsp)
 100957b:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
 1009580:	48 8b 03             	mov    (%rbx),%rax
 1009583:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 1009589:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100958e:	48 8b 43 08          	mov    0x8(%rbx),%rax
 1009592:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1009597:	e8 a2 dd ff ff       	callq  100733e <runtime.printf>
		runtime·throw("bad unwindstack");
 100959c:	b8 c0 48 02 01       	mov    $0x10248c0,%eax
 10095a1:	48 89 04 24          	mov    %rax,(%rsp)
 10095a5:	e8 8f 07 00 00       	callq  1009d39 <runtime.throw>
 10095aa:	48 83 c4 40          	add    $0x40,%rsp
 10095ae:	c3                   	retq   
	// Must be called from a different goroutine, usually m->g0.
	if(g == gp)
		runtime·throw("unwindstack on self");

	while((top = (Stktop*)gp->stackbase) != nil && top->stackbase != nil) {
		stk = gp->stackguard - StackGuard;
 10095af:	48 8b 2b             	mov    (%rbx),%rbp
 10095b2:	48 81 c5 00 ff ff ff 	add    $0xffffffffffffff00,%rbp
		if(stk <= sp && sp < gp->stackbase)
 10095b9:	48 39 f5             	cmp    %rsi,%rbp
 10095bc:	77 09                	ja     10095c7 <unwindstack+0xcd>
 10095be:	48 8b 43 08          	mov    0x8(%rbx),%rax
 10095c2:	48 39 c6             	cmp    %rax,%rsi
 10095c5:	72 8e                	jb     1009555 <unwindstack+0x5b>
			break;
		gp->stackbase = top->stackbase;
 10095c7:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 10095cb:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
		gp->stackguard = top->stackguard;
 10095cf:	48 8b 0a             	mov    (%rdx),%rcx
 10095d2:	48 89 0b             	mov    %rcx,(%rbx)
		if(top->free != 0)
 10095d5:	48 8b 42 38          	mov    0x38(%rdx),%rax
 10095d9:	48 83 f8 00          	cmp    $0x0,%rax
 10095dd:	0f 84 5e ff ff ff    	je     1009541 <unwindstack+0x47>
			runtime·stackfree(stk, top->free);
 10095e3:	48 89 2c 24          	mov    %rbp,(%rsp)
 10095e7:	48 8b 42 38          	mov    0x38(%rdx),%rax
 10095eb:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10095f0:	e8 97 9c ff ff       	callq  100328c <runtime.stackfree>
 10095f5:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
 10095fa:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx

	// Must be called from a different goroutine, usually m->g0.
	if(g == gp)
		runtime·throw("unwindstack on self");

	while((top = (Stktop*)gp->stackbase) != nil && top->stackbase != nil) {
 10095ff:	e9 3d ff ff ff       	jmpq   1009541 <unwindstack+0x47>

0000000001009604 <printpanics>:
		runtime·throw("bad unwindstack");
	}
}

static void
printpanics(Panic *p)
 1009604:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100960b:	ff ff 
 100960d:	48 3b 21             	cmp    (%rcx),%rsp
 1009610:	77 05                	ja     1009617 <printpanics+0x13>
 1009612:	e8 35 83 ff ff       	callq  100194c <runtime.morestack8>
 1009617:	48 83 ec 18          	sub    $0x18,%rsp
 100961b:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
{
	if(p->link) {
 1009620:	48 8b 41 18          	mov    0x18(%rcx),%rax
 1009624:	48 83 f8 00          	cmp    $0x0,%rax
 1009628:	74 1b                	je     1009645 <printpanics+0x41>
		printpanics(p->link);
 100962a:	48 8b 41 18          	mov    0x18(%rcx),%rax
 100962e:	48 89 04 24          	mov    %rax,(%rsp)
 1009632:	e8 cd ff ff ff       	callq  1009604 <printpanics>
		runtime·printf("\t");
 1009637:	b8 d0 48 02 01       	mov    $0x10248d0,%eax
 100963c:	48 89 04 24          	mov    %rax,(%rsp)
 1009640:	e8 f9 dc ff ff       	callq  100733e <runtime.printf>
	}
	runtime·printf("panic: ");
 1009645:	b8 d2 48 02 01       	mov    $0x10248d2,%eax
 100964a:	48 89 04 24          	mov    %rax,(%rsp)
 100964e:	e8 eb dc ff ff       	callq  100733e <runtime.printf>
	runtime·printany(p->arg);
 1009653:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 1009658:	48 8b 01             	mov    (%rcx),%rax
 100965b:	48 89 04 24          	mov    %rax,(%rsp)
 100965f:	48 8b 41 08          	mov    0x8(%rcx),%rax
 1009663:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009668:	e8 91 7b ff ff       	callq  10011fe <runtime.printany>
	if(p->recovered)
 100966d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1009672:	0f b6 40 20          	movzbl 0x20(%rax),%eax
 1009676:	80 f8 00             	cmp    $0x0,%al
 1009679:	74 0e                	je     1009689 <printpanics+0x85>
		runtime·printf(" [recovered]");
 100967b:	b8 da 48 02 01       	mov    $0x10248da,%eax
 1009680:	48 89 04 24          	mov    %rax,(%rsp)
 1009684:	e8 b5 dc ff ff       	callq  100733e <runtime.printf>
	runtime·printf("\n");
 1009689:	b8 e7 48 02 01       	mov    $0x10248e7,%eax
 100968e:	48 89 04 24          	mov    %rax,(%rsp)
 1009692:	e8 a7 dc ff ff       	callq  100733e <runtime.printf>
 1009697:	48 83 c4 18          	add    $0x18,%rsp
 100969b:	c3                   	retq   

000000000100969c <runtime.panic>:
}

static void recovery(G*);

void
runtime·panic(Eface e)
 100969c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10096a3:	ff ff 
 10096a5:	48 3b 21             	cmp    (%rcx),%rsp
 10096a8:	77 05                	ja     10096af <runtime.panic+0x13>
 10096aa:	e8 a6 82 ff ff       	callq  1001955 <runtime.morestack16>
 10096af:	48 83 ec 38          	sub    $0x38,%rsp
{
	Defer *d;
	Panic *p;

	p = runtime·mal(sizeof *p);
 10096b3:	48 c7 c1 28 00 00 00 	mov    $0x28,%rcx
 10096ba:	48 89 0c 24          	mov    %rcx,(%rsp)
 10096be:	e8 6d 9a ff ff       	callq  1003130 <runtime.mal>
 10096c3:	48 89 c2             	mov    %rax,%rdx
	p->arg = e;
 10096c6:	48 89 c1             	mov    %rax,%rcx
 10096c9:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 10096ce:	48 89 01             	mov    %rax,(%rcx)
 10096d1:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 10096d6:	48 89 41 08          	mov    %rax,0x8(%rcx)
	p->link = g->panic;
 10096da:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10096e1:	ff ff 
 10096e3:	48 8b 49 18          	mov    0x18(%rcx),%rcx
 10096e7:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
	p->stackbase = g->stackbase;
 10096eb:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10096f2:	ff ff 
 10096f4:	48 8b 49 08          	mov    0x8(%rcx),%rcx
 10096f8:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
	g->panic = p;
 10096fc:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009703:	ff ff 
 1009705:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
 100970a:	48 89 50 18          	mov    %rdx,0x18(%rax)

	for(;;) {
		d = g->defer;
 100970e:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009715:	ff ff 
 1009717:	48 8b 50 10          	mov    0x10(%rax),%rdx
		if(d == nil)
 100971b:	48 83 fa 00          	cmp    $0x0,%rdx
 100971f:	75 2c                	jne    100974d <runtime.panic+0xb1>
		}
		runtime·free(d);
	}

	// ran out of deferred calls - old-school panic now
	runtime·startpanic();
 1009721:	e8 c8 03 00 00       	callq  1009aee <runtime.startpanic>
	printpanics(g->panic);
 1009726:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100972d:	ff ff 
 100972f:	48 8b 40 18          	mov    0x18(%rax),%rax
 1009733:	48 89 04 24          	mov    %rax,(%rsp)
 1009737:	e8 c8 fe ff ff       	callq  1009604 <printpanics>
	runtime·dopanic(0);
 100973c:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
 1009743:	e8 29 04 00 00       	callq  1009b71 <runtime.dopanic>
 1009748:	48 83 c4 38          	add    $0x38,%rsp
 100974c:	c3                   	retq   
	for(;;) {
		d = g->defer;
		if(d == nil)
			break;
		// take defer off list in case of recursive panic
		g->defer = d->link;
 100974d:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009754:	ff ff 
 1009756:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 100975a:	48 89 48 10          	mov    %rcx,0x10(%rax)
		g->ispanic = true;	// rock for newstack, where reflect.call ends up
 100975e:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009765:	ff ff 
 1009767:	c6 80 89 00 00 00 01 	movb   $0x1,0x89(%rax)
		reflect·call(d->fn, d->args, d->siz);
 100976e:	48 8b 42 18          	mov    0x18(%rdx),%rax
 1009772:	48 89 04 24          	mov    %rax,(%rsp)
 1009776:	48 89 d0             	mov    %rdx,%rax
 1009779:	48 83 c0 28          	add    $0x28,%rax
 100977d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009782:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
 1009787:	8b 02                	mov    (%rdx),%eax
 1009789:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100978d:	e8 c9 80 ff ff       	callq  100185b <reflect.call>
 1009792:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
		if(p->recovered) {
 1009797:	0f b6 42 20          	movzbl 0x20(%rdx),%eax
 100979b:	80 f8 00             	cmp    $0x0,%al
 100979e:	74 7f                	je     100981f <runtime.panic+0x183>
			g->panic = p->link;
 10097a0:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10097a7:	ff ff 
 10097a9:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 10097ad:	48 89 48 18          	mov    %rcx,0x18(%rax)
			if(g->panic == nil)	// must be done with signal
 10097b1:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10097b8:	ff ff 
 10097ba:	48 8b 40 18          	mov    0x18(%rax),%rax
 10097be:	48 83 f8 00          	cmp    $0x0,%rax
 10097c2:	75 13                	jne    10097d7 <runtime.panic+0x13b>
				g->sig = 0;
 10097c4:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10097cb:	ff ff 
 10097cd:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%rax)
 10097d4:	00 00 00 
			runtime·free(p);
 10097d7:	48 89 14 24          	mov    %rdx,(%rsp)
 10097db:	e8 ee 92 ff ff       	callq  1002ace <runtime.free>
 10097e0:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
			// put recovering defer back on list
			// for scheduler to find.
			d->link = g->defer;
 10097e5:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10097ec:	ff ff 
 10097ee:	48 8b 49 10          	mov    0x10(%rcx),%rcx
 10097f2:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
			g->defer = d;
 10097f6:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 10097fd:	ff ff 
 10097ff:	48 89 50 10          	mov    %rdx,0x10(%rax)
			runtime·mcall(recovery);
 1009803:	b8 32 98 00 01       	mov    $0x1009832,%eax
 1009808:	48 89 04 24          	mov    %rax,(%rsp)
 100980c:	e8 9d 7f ff ff       	callq  10017ae <runtime.mcall>
			runtime·throw("recovery failed"); // mcall should not return
 1009811:	b8 e9 48 02 01       	mov    $0x10248e9,%eax
 1009816:	48 89 04 24          	mov    %rax,(%rsp)
 100981a:	e8 1a 05 00 00       	callq  1009d39 <runtime.throw>
		}
		runtime·free(d);
 100981f:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1009824:	48 89 04 24          	mov    %rax,(%rsp)
 1009828:	e8 a1 92 ff ff       	callq  1002ace <runtime.free>
	p->link = g->panic;
	p->stackbase = g->stackbase;
	g->panic = p;

	for(;;) {
		d = g->defer;
 100982d:	e9 dc fe ff ff       	jmpq   100970e <runtime.panic+0x72>

0000000001009832 <recovery>:
	printpanics(g->panic);
	runtime·dopanic(0);
}

static void
recovery(G *gp)
 1009832:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009839:	ff ff 
 100983b:	48 3b 21             	cmp    (%rcx),%rsp
 100983e:	77 05                	ja     1009845 <recovery+0x13>
 1009840:	e8 07 81 ff ff       	callq  100194c <runtime.morestack8>
 1009845:	48 83 ec 28          	sub    $0x28,%rsp
 1009849:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
{
	Defer *d;

	// Rewind gp's stack; we're running on m->g0's stack.
	d = gp->defer;
 100984e:	48 8b 53 10          	mov    0x10(%rbx),%rdx
	gp->defer = d->link;
 1009852:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 1009856:	48 89 4b 10          	mov    %rcx,0x10(%rbx)

	// Unwind to the stack frame with d's arguments in it.
	unwindstack(gp, d->argp);
 100985a:	48 89 1c 24          	mov    %rbx,(%rsp)
 100985e:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
 1009863:	48 8b 42 08          	mov    0x8(%rdx),%rax
 1009867:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100986c:	e8 89 fc ff ff       	callq  10094fa <unwindstack>
 1009871:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
 1009876:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
	// before it tests the return value.)
	// On the arm there are 2 saved LRs mixed in too.
	if(thechar == '5')
		gp->sched.sp = (byte*)d->argp - 4*sizeof(uintptr);
	else
		gp->sched.sp = (byte*)d->argp - 2*sizeof(uintptr);
 100987b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 100987f:	48 83 c1 f0          	add    $0xfffffffffffffff0,%rcx
 1009883:	48 89 4b 20          	mov    %rcx,0x20(%rbx)
	gp->sched.pc = d->pc;
 1009887:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
 100988b:	48 89 4b 28          	mov    %rcx,0x28(%rbx)
	runtime·free(d);
 100988f:	48 89 14 24          	mov    %rdx,(%rsp)
 1009893:	e8 36 92 ff ff       	callq  1002ace <runtime.free>
	runtime·gogo(&gp->sched, 1);
 1009898:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100989d:	48 83 c0 20          	add    $0x20,%rax
 10098a1:	48 89 04 24          	mov    %rax,(%rsp)
 10098a5:	48 c7 c0 01 00 00 00 	mov    $0x1,%rax
 10098ac:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 10098b1:	e8 b1 7e ff ff       	callq  1001767 <runtime.gogo>
 10098b6:	48 83 c4 28          	add    $0x28,%rsp
 10098ba:	c3                   	retq   

00000000010098bb <gfput>:
}


// Put on gfree list.  Sched must be locked.
static void
gfput(G *g)
 10098bb:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10098c2:	ff ff 
 10098c4:	48 3b 21             	cmp    (%rcx),%rsp
 10098c7:	77 05                	ja     10098ce <gfput+0x13>
 10098c9:	e8 7e 80 ff ff       	callq  100194c <runtime.morestack8>
 10098ce:	48 83 ec 10          	sub    $0x10,%rsp
 10098d2:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
{
	if(g->stackguard - StackGuard != g->stack0)
 10098d7:	48 8b 02             	mov    (%rdx),%rax
 10098da:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 10098e0:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
 10098e4:	48 39 c8             	cmp    %rcx,%rax
 10098e7:	74 13                	je     10098fc <gfput+0x41>
		runtime·throw("invalid stack in gfput");
 10098e9:	b8 f9 48 02 01       	mov    $0x10248f9,%eax
 10098ee:	48 89 04 24          	mov    %rax,(%rsp)
 10098f2:	e8 42 04 00 00       	callq  1009d39 <runtime.throw>
 10098f7:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
	g->schedlink = runtime·sched.gfree;
 10098fc:	48 8b 0c 25 b8 4f 02 	mov    0x1024fb8,%rcx
 1009903:	01 
 1009904:	48 89 8a 80 00 00 00 	mov    %rcx,0x80(%rdx)
	runtime·sched.gfree = g;
 100990b:	48 89 14 25 b8 4f 02 	mov    %rdx,0x1024fb8
 1009912:	01 
 1009913:	48 83 c4 10          	add    $0x10,%rsp
 1009917:	c3                   	retq   

0000000001009918 <gfget>:
}

// Get from gfree list.  Sched must be locked.
static G*
gfget(void)
 1009918:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100991f:	ff ff 
 1009921:	48 3b 21             	cmp    (%rcx),%rsp
 1009924:	77 05                	ja     100992b <gfget+0x13>
 1009926:	e8 c8 7f ff ff       	callq  10018f3 <runtime.morestack00>
 100992b:	48 83 ec 10          	sub    $0x10,%rsp
{
	G *g;

	g = runtime·sched.gfree;
 100992f:	48 8b 0c 25 b8 4f 02 	mov    0x1024fb8,%rcx
 1009936:	01 
	if(g)
 1009937:	48 83 f9 00          	cmp    $0x0,%rcx
 100993b:	74 0f                	je     100994c <gfget+0x34>
		runtime·sched.gfree = g->schedlink;
 100993d:	48 8b 81 80 00 00 00 	mov    0x80(%rcx),%rax
 1009944:	48 89 04 25 b8 4f 02 	mov    %rax,0x1024fb8
 100994b:	01 
	return g;
 100994c:	48 89 c8             	mov    %rcx,%rax
 100994f:	48 83 c4 10          	add    $0x10,%rsp
 1009953:	c3                   	retq   

0000000001009954 <runtime.mcount>:
	ret = runtime·sched.gcount;
	FLUSH(&ret);
}

int32
runtime·mcount(void)
 1009954:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100995b:	ff ff 
 100995d:	48 3b 21             	cmp    (%rcx),%rsp
 1009960:	77 05                	ja     1009967 <runtime.mcount+0x13>
 1009962:	e8 8c 7f ff ff       	callq  10018f3 <runtime.morestack00>
{
	return runtime·sched.mcount;
 1009967:	8b 04 25 f4 4f 02 01 	mov    0x1024ff4,%eax
 100996e:	c3                   	retq   

000000000100996f <runtime.badmcall>:
}

void
runtime·badmcall(void)  // called from assembly
 100996f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009976:	ff ff 
 1009978:	48 3b 21             	cmp    (%rcx),%rsp
 100997b:	77 05                	ja     1009982 <runtime.badmcall+0x13>
 100997d:	e8 71 7f ff ff       	callq  10018f3 <runtime.morestack00>
 1009982:	48 83 ec 10          	sub    $0x10,%rsp
{
	runtime·throw("runtime: mcall called on m->g0 stack");
 1009986:	b8 42 49 02 01       	mov    $0x1024942,%eax
 100998b:	48 89 04 24          	mov    %rax,(%rsp)
 100998f:	e8 a5 03 00 00       	callq  1009d39 <runtime.throw>
 1009994:	48 83 c4 10          	add    $0x10,%rsp
 1009998:	c3                   	retq   

0000000001009999 <runtime.badmcall2>:
}

void
runtime·badmcall2(void)  // called from assembly
 1009999:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10099a0:	ff ff 
 10099a2:	48 3b 21             	cmp    (%rcx),%rsp
 10099a5:	77 05                	ja     10099ac <runtime.badmcall2+0x13>
 10099a7:	e8 47 7f ff ff       	callq  10018f3 <runtime.morestack00>
 10099ac:	48 83 ec 10          	sub    $0x10,%rsp
{
	runtime·throw("runtime: mcall function returned");
 10099b0:	b8 67 49 02 01       	mov    $0x1024967,%eax
 10099b5:	48 89 04 24          	mov    %rax,(%rsp)
 10099b9:	e8 7b 03 00 00       	callq  1009d39 <runtime.throw>
 10099be:	48 83 c4 10          	add    $0x10,%rsp
 10099c2:	c3                   	retq   

00000000010099c3 <runtime.sigprof>:
	int32 hz;
	uintptr pcbuf[100];
} prof;

void
runtime·sigprof(uint8 *pc, uint8 *sp, uint8 *lr, G *gp)
 10099c3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 10099ca:	ff ff 
 10099cc:	48 3b 21             	cmp    (%rcx),%rsp
 10099cf:	77 05                	ja     10099d6 <runtime.sigprof+0x13>
 10099d1:	e8 91 7f ff ff       	callq  1001967 <runtime.morestack32>
 10099d6:	48 83 ec 50          	sub    $0x50,%rsp
{
	int32 n;

	if(prof.fn == nil || prof.hz == 0)
 10099da:	48 83 3c 25 58 57 02 	cmpq   $0x0,0x1025758
 10099e1:	01 00 
 10099e3:	0f 84 b2 00 00 00    	je     1009a9b <runtime.sigprof+0xd8>
 10099e9:	83 3c 25 60 57 02 01 	cmpl   $0x0,0x1025760
 10099f0:	00 
 10099f1:	0f 84 a4 00 00 00    	je     1009a9b <runtime.sigprof+0xd8>
		return;

	runtime·lock(&prof);
 10099f7:	b8 50 57 02 01       	mov    $0x1025750,%eax
 10099fc:	48 89 04 24          	mov    %rax,(%rsp)
 1009a00:	e8 2b 34 00 00       	callq  100ce30 <runtime.lock>
	if(prof.fn == nil) {
 1009a05:	48 83 3c 25 58 57 02 	cmpq   $0x0,0x1025758
 1009a0c:	01 00 
 1009a0e:	75 13                	jne    1009a23 <runtime.sigprof+0x60>
		runtime·unlock(&prof);
 1009a10:	b8 50 57 02 01       	mov    $0x1025750,%eax
 1009a15:	48 89 04 24          	mov    %rax,(%rsp)
 1009a19:	e8 64 34 00 00       	callq  100ce82 <runtime.unlock>
		return;
 1009a1e:	48 83 c4 50          	add    $0x50,%rsp
 1009a22:	c3                   	retq   
	}
	n = runtime·gentraceback(pc, sp, lr, gp, 0, prof.pcbuf, nelem(prof.pcbuf));
 1009a23:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 1009a28:	48 89 0c 24          	mov    %rcx,(%rsp)
 1009a2c:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
 1009a31:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 1009a36:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
 1009a3b:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 1009a40:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
 1009a45:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 1009a4a:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%rsp)
 1009a51:	00 
 1009a52:	b9 68 57 02 01       	mov    $0x1025768,%ecx
 1009a57:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
 1009a5c:	b9 64 00 00 00       	mov    $0x64,%ecx
 1009a61:	89 4c 24 30          	mov    %ecx,0x30(%rsp)
 1009a65:	e8 18 38 00 00       	callq  100d282 <runtime.gentraceback>
 1009a6a:	89 c1                	mov    %eax,%ecx
	if(n > 0)
 1009a6c:	83 f8 00             	cmp    $0x0,%eax
 1009a6f:	7e 17                	jle    1009a88 <runtime.sigprof+0xc5>
		prof.fn(prof.pcbuf, n);
 1009a71:	b8 68 57 02 01       	mov    $0x1025768,%eax
 1009a76:	48 89 04 24          	mov    %rax,(%rsp)
 1009a7a:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1009a7e:	48 8b 04 25 58 57 02 	mov    0x1025758,%rax
 1009a85:	01 
 1009a86:	ff d0                	callq  *%rax
	runtime·unlock(&prof);
 1009a88:	b8 50 57 02 01       	mov    $0x1025750,%eax
 1009a8d:	48 89 04 24          	mov    %rax,(%rsp)
 1009a91:	e8 ec 33 00 00       	callq  100ce82 <runtime.unlock>
 1009a96:	48 83 c4 50          	add    $0x50,%rsp
 1009a9a:	c3                   	retq   
 1009a9b:	48 83 c4 50          	add    $0x50,%rsp
 1009a9f:	c3                   	retq   

0000000001009aa0 <runtime.gotraceback>:
 * line number of the CALL instruction, because there is no CALL.
 */
void	runtime·sigpanic(void);

int32
runtime·gotraceback(void)
 1009aa0:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009aa7:	ff ff 
 1009aa9:	48 3b 21             	cmp    (%rcx),%rsp
 1009aac:	77 05                	ja     1009ab3 <runtime.gotraceback+0x13>
 1009aae:	e8 40 7e ff ff       	callq  10018f3 <runtime.morestack00>
 1009ab3:	48 83 ec 20          	sub    $0x20,%rsp
{
	byte *p;

	p = runtime·getenv("GOTRACEBACK");
 1009ab7:	b9 b0 35 02 01       	mov    $0x10235b0,%ecx
 1009abc:	48 89 0c 24          	mov    %rcx,(%rsp)
 1009ac0:	e8 0c 06 00 00       	callq  100a0d1 <runtime.getenv>
 1009ac5:	48 89 c2             	mov    %rax,%rdx
	if(p == nil || p[0] == '\0')
 1009ac8:	48 83 f8 00          	cmp    $0x0,%rax
 1009acc:	74 16                	je     1009ae4 <runtime.gotraceback+0x44>
 1009ace:	0f b6 00             	movzbl (%rax),%eax
 1009ad1:	83 f8 00             	cmp    $0x0,%eax
 1009ad4:	74 0e                	je     1009ae4 <runtime.gotraceback+0x44>
		return 1;	// default is on
	return runtime·atoi(p);
 1009ad6:	48 89 14 24          	mov    %rdx,(%rsp)
 1009ada:	e8 9d 06 00 00       	callq  100a17c <runtime.atoi>
 1009adf:	48 83 c4 20          	add    $0x20,%rsp
 1009ae3:	c3                   	retq   
{
	byte *p;

	p = runtime·getenv("GOTRACEBACK");
	if(p == nil || p[0] == '\0')
		return 1;	// default is on
 1009ae4:	b8 01 00 00 00       	mov    $0x1,%eax
 1009ae9:	48 83 c4 20          	add    $0x20,%rsp
 1009aed:	c3                   	retq   

0000000001009aee <runtime.startpanic>:
}

static Lock paniclk;

void
runtime·startpanic(void)
 1009aee:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009af5:	ff ff 
 1009af7:	48 3b 21             	cmp    (%rcx),%rsp
 1009afa:	77 05                	ja     1009b01 <runtime.startpanic+0x13>
 1009afc:	e8 f2 7d ff ff       	callq  10018f3 <runtime.morestack00>
 1009b01:	48 83 ec 18          	sub    $0x18,%rsp
{
	if(m->dying) {
 1009b05:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1009b0c:	ff ff 
 1009b0e:	8b 80 90 00 00 00    	mov    0x90(%rax),%eax
 1009b14:	83 f8 00             	cmp    $0x0,%eax
 1009b17:	74 1b                	je     1009b34 <runtime.startpanic+0x46>
		runtime·printf("panic during panic\n");
 1009b19:	b8 bc 35 02 01       	mov    $0x10235bc,%eax
 1009b1e:	48 89 04 24          	mov    %rax,(%rsp)
 1009b22:	e8 17 d8 ff ff       	callq  100733e <runtime.printf>
		runtime·exit(3);
 1009b27:	b8 03 00 00 00       	mov    $0x3,%eax
 1009b2c:	89 04 24             	mov    %eax,(%rsp)
 1009b2f:	e8 3d 2c 00 00       	callq  100c771 <runtime.exit>
	}
	m->dying = 1;
 1009b34:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1009b3b:	ff ff 
 1009b3d:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%rax)
 1009b44:	00 00 00 
	runtime·xadd(&runtime·panicking, 1);
 1009b47:	b8 20 4e 02 01       	mov    $0x1024e20,%eax
 1009b4c:	48 89 04 24          	mov    %rax,(%rsp)
 1009b50:	b8 01 00 00 00       	mov    $0x1,%eax
 1009b55:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1009b59:	e8 78 7e ff ff       	callq  10019d6 <runtime.xadd>
	runtime·lock(&paniclk);
 1009b5e:	b8 c8 4e 02 01       	mov    $0x1024ec8,%eax
 1009b63:	48 89 04 24          	mov    %rax,(%rsp)
 1009b67:	e8 c4 32 00 00       	callq  100ce30 <runtime.lock>
 1009b6c:	48 83 c4 18          	add    $0x18,%rsp
 1009b70:	c3                   	retq   

0000000001009b71 <runtime.dopanic>:
}

void
runtime·dopanic(int32 unused)
 1009b71:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009b78:	ff ff 
 1009b7a:	48 3b 21             	cmp    (%rcx),%rsp
 1009b7d:	77 05                	ja     1009b84 <runtime.dopanic+0x13>
 1009b7f:	e8 c8 7d ff ff       	callq  100194c <runtime.morestack8>
 1009b84:	48 83 ec 38          	sub    $0x38,%rsp
{
	static bool didothers;

	if(g->sig != 0)
 1009b88:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009b8f:	ff ff 
 1009b91:	8b 80 a8 00 00 00    	mov    0xa8(%rax),%eax
 1009b97:	83 f8 00             	cmp    $0x0,%eax
 1009b9a:	74 60                	je     1009bfc <runtime.dopanic+0x8b>
		runtime·printf("\n[signal %x code=%p addr=%p pc=%p]\n",
 1009b9c:	b8 d0 35 02 01       	mov    $0x10235d0,%eax
 1009ba1:	48 89 04 24          	mov    %rax,(%rsp)
 1009ba5:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009bac:	ff ff 
 1009bae:	8b 80 a8 00 00 00    	mov    0xa8(%rax),%eax
 1009bb4:	89 44 24 08          	mov    %eax,0x8(%rsp)
 1009bb8:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009bbf:	ff ff 
 1009bc1:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
 1009bc8:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1009bcd:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009bd4:	ff ff 
 1009bd6:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 1009bdd:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1009be2:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009be9:	ff ff 
 1009beb:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
 1009bf2:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 1009bf7:	e8 42 d7 ff ff       	callq  100733e <runtime.printf>
			g->sig, g->sigcode0, g->sigcode1, g->sigpc);

	runtime·printf("\n");
 1009bfc:	b8 f4 35 02 01       	mov    $0x10235f4,%eax
 1009c01:	48 89 04 24          	mov    %rax,(%rsp)
 1009c05:	e8 34 d7 ff ff       	callq  100733e <runtime.printf>
	if(runtime·gotraceback()){
 1009c0a:	e8 91 fe ff ff       	callq  1009aa0 <runtime.gotraceback>
 1009c0f:	83 f8 00             	cmp    $0x0,%eax
 1009c12:	74 79                	je     1009c8d <runtime.dopanic+0x11c>
		runtime·traceback(runtime·getcallerpc(&unused), runtime·getcallersp(&unused), 0, g);
 1009c14:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
 1009c19:	48 89 0c 24          	mov    %rcx,(%rsp)
 1009c1d:	e8 a7 7e ff ff       	callq  1001ac9 <runtime.getcallerpc>
 1009c22:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
 1009c27:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
 1009c2c:	48 89 0c 24          	mov    %rcx,(%rsp)
 1009c30:	e8 9e 7e ff ff       	callq  1001ad3 <runtime.getcallersp>
 1009c35:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 1009c3a:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 1009c3f:	48 89 04 24          	mov    %rax,(%rsp)
 1009c43:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1009c48:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009c4d:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 1009c54:	00 00 
 1009c56:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009c5d:	ff ff 
 1009c5f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 1009c64:	e8 7c 3d 00 00       	callq  100d9e5 <runtime.traceback>
		if(!didothers) {
 1009c69:	80 3c 25 e0 4d 02 01 	cmpb   $0x0,0x1024de0
 1009c70:	00 
 1009c71:	75 1a                	jne    1009c8d <runtime.dopanic+0x11c>
			didothers = true;
 1009c73:	c6 04 25 e0 4d 02 01 	movb   $0x1,0x1024de0
 1009c7a:	01 
			runtime·tracebackothers(g);
 1009c7b:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 1009c82:	ff ff 
 1009c84:	48 89 04 24          	mov    %rax,(%rsp)
 1009c88:	e8 e7 e2 ff ff       	callq  1007f74 <runtime.tracebackothers>
		}
	}
	runtime·unlock(&paniclk);
 1009c8d:	b8 c8 4e 02 01       	mov    $0x1024ec8,%eax
 1009c92:	48 89 04 24          	mov    %rax,(%rsp)
 1009c96:	e8 e7 31 00 00       	callq  100ce82 <runtime.unlock>
	if(runtime·xadd(&runtime·panicking, -1) != 0) {
 1009c9b:	b9 20 4e 02 01       	mov    $0x1024e20,%ecx
 1009ca0:	48 89 0c 24          	mov    %rcx,(%rsp)
 1009ca4:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 1009ca9:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 1009cad:	e8 24 7d ff ff       	callq  10019d6 <runtime.xadd>
 1009cb2:	83 f8 00             	cmp    $0x0,%eax
 1009cb5:	74 1c                	je     1009cd3 <runtime.dopanic+0x162>
		// Some other m is panicking too.
		// Let it print what it needs to print.
		// Wait forever without chewing up cpu.
		// It will exit when it's done.
		static Lock deadlock;
		runtime·lock(&deadlock);
 1009cb7:	b8 58 4e 02 01       	mov    $0x1024e58,%eax
 1009cbc:	48 89 04 24          	mov    %rax,(%rsp)
 1009cc0:	e8 6b 31 00 00       	callq  100ce30 <runtime.lock>
		runtime·lock(&deadlock);
 1009cc5:	b8 58 4e 02 01       	mov    $0x1024e58,%eax
 1009cca:	48 89 04 24          	mov    %rax,(%rsp)
 1009cce:	e8 5d 31 00 00       	callq  100ce30 <runtime.lock>
	}

	runtime·exit(2);
 1009cd3:	b8 02 00 00 00       	mov    $0x2,%eax
 1009cd8:	89 04 24             	mov    %eax,(%rsp)
 1009cdb:	e8 91 2a 00 00       	callq  100c771 <runtime.exit>
 1009ce0:	48 83 c4 38          	add    $0x38,%rsp
 1009ce4:	c3                   	retq   

0000000001009ce5 <runtime.throwreturn>:
{
	runtime·panicstring("slice bounds out of range");
}

void
runtime·throwreturn(void)
 1009ce5:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009cec:	ff ff 
 1009cee:	48 3b 21             	cmp    (%rcx),%rsp
 1009cf1:	77 05                	ja     1009cf8 <runtime.throwreturn+0x13>
 1009cf3:	e8 fb 7b ff ff       	callq  10018f3 <runtime.morestack00>
 1009cf8:	48 83 ec 10          	sub    $0x10,%rsp
{
	// can only happen if compiler is broken
	runtime·throw("no return at end of a typed function - compiler is broken");
 1009cfc:	b8 23 36 02 01       	mov    $0x1023623,%eax
 1009d01:	48 89 04 24          	mov    %rax,(%rsp)
 1009d05:	e8 2f 00 00 00       	callq  1009d39 <runtime.throw>
 1009d0a:	48 83 c4 10          	add    $0x10,%rsp
 1009d0e:	c3                   	retq   

0000000001009d0f <runtime.throwinit>:
}

void
runtime·throwinit(void)
 1009d0f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009d16:	ff ff 
 1009d18:	48 3b 21             	cmp    (%rcx),%rsp
 1009d1b:	77 05                	ja     1009d22 <runtime.throwinit+0x13>
 1009d1d:	e8 d1 7b ff ff       	callq  10018f3 <runtime.morestack00>
 1009d22:	48 83 ec 10          	sub    $0x10,%rsp
{
	// can only happen with linker skew
	runtime·throw("recursive call during initialization - linker skew");
 1009d26:	b8 5d 36 02 01       	mov    $0x102365d,%eax
 1009d2b:	48 89 04 24          	mov    %rax,(%rsp)
 1009d2f:	e8 05 00 00 00       	callq  1009d39 <runtime.throw>
 1009d34:	48 83 c4 10          	add    $0x10,%rsp
 1009d38:	c3                   	retq   

0000000001009d39 <runtime.throw>:
}

void
runtime·throw(int8 *s)
 1009d39:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009d40:	ff ff 
 1009d42:	48 3b 21             	cmp    (%rcx),%rsp
 1009d45:	77 05                	ja     1009d4c <runtime.throw+0x13>
 1009d47:	e8 00 7c ff ff       	callq  100194c <runtime.morestack8>
 1009d4c:	48 83 ec 18          	sub    $0x18,%rsp
{
	runtime·startpanic();
 1009d50:	e8 99 fd ff ff       	callq  1009aee <runtime.startpanic>
	runtime·printf("throw: %s\n", s);
 1009d55:	b8 90 36 02 01       	mov    $0x1023690,%eax
 1009d5a:	48 89 04 24          	mov    %rax,(%rsp)
 1009d5e:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1009d63:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009d68:	e8 d1 d5 ff ff       	callq  100733e <runtime.printf>
	runtime·dopanic(0);
 1009d6d:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
 1009d74:	e8 f8 fd ff ff       	callq  1009b71 <runtime.dopanic>
	*(int32*)0 = 0;	// not reached
 1009d79:	c7 04 25 00 00 00 00 	movl   $0x0,0x0
 1009d80:	00 00 00 00 
	runtime·exit(1);	// even more not reached
 1009d84:	b8 01 00 00 00       	mov    $0x1,%eax
 1009d89:	89 04 24             	mov    %eax,(%rsp)
 1009d8c:	e8 e0 29 00 00       	callq  100c771 <runtime.exit>
 1009d91:	48 83 c4 18          	add    $0x18,%rsp
 1009d95:	c3                   	retq   

0000000001009d96 <runtime.panicstring>:
}

void
runtime·panicstring(int8 *s)
 1009d96:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009d9d:	ff ff 
 1009d9f:	48 3b 21             	cmp    (%rcx),%rsp
 1009da2:	77 05                	ja     1009da9 <runtime.panicstring+0x13>
 1009da4:	e8 a3 7b ff ff       	callq  100194c <runtime.morestack8>
 1009da9:	48 83 ec 48          	sub    $0x48,%rsp
{
	Eface err;
	
	if(m->gcing) {
 1009dad:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 1009db4:	ff ff 
 1009db6:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
 1009dbc:	83 f8 00             	cmp    $0x0,%eax
 1009dbf:	74 26                	je     1009de7 <runtime.panicstring+0x51>
		runtime·printf("panic: %s\n", s);
 1009dc1:	b8 9b 36 02 01       	mov    $0x102369b,%eax
 1009dc6:	48 89 04 24          	mov    %rax,(%rsp)
 1009dca:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1009dcf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009dd4:	e8 65 d5 ff ff       	callq  100733e <runtime.printf>
		runtime·throw("panic during gc");
 1009dd9:	b8 a6 36 02 01       	mov    $0x10236a6,%eax
 1009dde:	48 89 04 24          	mov    %rax,(%rsp)
 1009de2:	e8 52 ff ff ff       	callq  1009d39 <runtime.throw>
	}
	runtime·newErrorString(runtime·gostringnocopy((byte*)s), &err);
 1009de7:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
 1009dec:	48 89 04 24          	mov    %rax,(%rsp)
 1009df0:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 1009df5:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009dfa:	e8 2c 1a 00 00       	callq  100b82b <runtime.gostringnocopy>
 1009dff:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 1009e04:	48 89 04 24          	mov    %rax,(%rsp)
 1009e08:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1009e0d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009e12:	48 8d 44 24 38       	lea    0x38(%rsp),%rax
 1009e17:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 1009e1c:	e8 92 73 ff ff       	callq  10011b3 <runtime.newErrorString>
	runtime·panic(err);
 1009e21:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 1009e26:	48 89 04 24          	mov    %rax,(%rsp)
 1009e2a:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 1009e2f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009e34:	e8 63 f8 ff ff       	callq  100969c <runtime.panic>
 1009e39:	48 83 c4 48          	add    $0x48,%rsp
 1009e3d:	c3                   	retq   

0000000001009e3e <runtime.mcmp>:
}

int32
runtime·mcmp(byte *s1, byte *s2, uint32 n)
 1009e3e:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009e45:	ff ff 
 1009e47:	48 3b 21             	cmp    (%rcx),%rsp
 1009e4a:	77 05                	ja     1009e51 <runtime.mcmp+0x13>
 1009e4c:	e8 0d 7b ff ff       	callq  100195e <runtime.morestack24>
 1009e51:	48 83 ec 10          	sub    $0x10,%rsp
 1009e55:	44 8b 44 24 28       	mov    0x28(%rsp),%r8d
 1009e5a:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
 1009e5f:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
{
	uint32 i;
	byte c1, c2;

	for(i=0; i<n; i++) {
 1009e64:	31 db                	xor    %ebx,%ebx
 1009e66:	44 39 c3             	cmp    %r8d,%ebx
 1009e69:	73 3a                	jae    1009ea5 <runtime.mcmp+0x67>
		c1 = s1[i];
 1009e6b:	0f b6 04 1f          	movzbl (%rdi,%rbx,1),%eax
 1009e6f:	40 88 c5             	mov    %al,%bpl
		c2 = s2[i];
 1009e72:	89 d9                	mov    %ebx,%ecx
 1009e74:	0f b6 04 1e          	movzbl (%rsi,%rbx,1),%eax
 1009e78:	88 c1                	mov    %al,%cl
		if(c1 < c2)
 1009e7a:	40 0f b6 c5          	movzbl %bpl,%eax
 1009e7e:	38 c8                	cmp    %cl,%al
 1009e80:	73 0a                	jae    1009e8c <runtime.mcmp+0x4e>
			return -1;
 1009e82:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 1009e87:	48 83 c4 10          	add    $0x10,%rsp
 1009e8b:	c3                   	retq   
		if(c1 > c2)
 1009e8c:	40 0f b6 c5          	movzbl %bpl,%eax
 1009e90:	38 c8                	cmp    %cl,%al
 1009e92:	76 0a                	jbe    1009e9e <runtime.mcmp+0x60>
			return +1;
 1009e94:	b8 01 00 00 00       	mov    $0x1,%eax
 1009e99:	48 83 c4 10          	add    $0x10,%rsp
 1009e9d:	c3                   	retq   
runtime·mcmp(byte *s1, byte *s2, uint32 n)
{
	uint32 i;
	byte c1, c2;

	for(i=0; i<n; i++) {
 1009e9e:	ff c3                	inc    %ebx
 1009ea0:	44 39 c3             	cmp    %r8d,%ebx
 1009ea3:	72 c6                	jb     1009e6b <runtime.mcmp+0x2d>
		if(c1 < c2)
			return -1;
		if(c1 > c2)
			return +1;
	}
	return 0;
 1009ea5:	31 c0                	xor    %eax,%eax
 1009ea7:	48 83 c4 10          	add    $0x10,%rsp
 1009eab:	c3                   	retq   

0000000001009eac <runtime.mchr>:
}


byte*
runtime·mchr(byte *p, byte c, byte *ep)
 1009eac:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009eb3:	ff ff 
 1009eb5:	48 3b 21             	cmp    (%rcx),%rsp
 1009eb8:	77 05                	ja     1009ebf <runtime.mchr+0x13>
 1009eba:	e8 9f 7a ff ff       	callq  100195e <runtime.morestack24>
 1009ebf:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
 1009ec4:	8a 54 24 10          	mov    0x10(%rsp),%dl
 1009ec8:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
{
	for(; p < ep; p++)
 1009ecd:	48 39 d9             	cmp    %rbx,%rcx
 1009ed0:	73 13                	jae    1009ee5 <runtime.mchr+0x39>
		if(*p == c)
 1009ed2:	0f b6 01             	movzbl (%rcx),%eax
 1009ed5:	38 d0                	cmp    %dl,%al
 1009ed7:	75 04                	jne    1009edd <runtime.mchr+0x31>
			return p;
 1009ed9:	48 89 c8             	mov    %rcx,%rax
 1009edc:	c3                   	retq   


byte*
runtime·mchr(byte *p, byte c, byte *ep)
{
	for(; p < ep; p++)
 1009edd:	48 ff c1             	inc    %rcx
 1009ee0:	48 39 d9             	cmp    %rbx,%rcx
 1009ee3:	72 ed                	jb     1009ed2 <runtime.mchr+0x26>
		if(*p == c)
			return p;
	return nil;
 1009ee5:	48 31 c0             	xor    %rax,%rax
 1009ee8:	c3                   	retq   

0000000001009ee9 <runtime.rnd>:
}

uint32
runtime·rnd(uint32 n, uint32 m)
 1009ee9:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009ef0:	ff ff 
 1009ef2:	48 3b 21             	cmp    (%rcx),%rsp
 1009ef5:	77 05                	ja     1009efc <runtime.rnd+0x13>
 1009ef7:	e8 50 7a ff ff       	callq  100194c <runtime.morestack8>
 1009efc:	48 83 ec 10          	sub    $0x10,%rsp
 1009f00:	8b 6c 24 18          	mov    0x18(%rsp),%ebp
 1009f04:	8b 5c 24 1c          	mov    0x1c(%rsp),%ebx
{
	uint32 r;

	if(m > maxround)
 1009f08:	83 fb 08             	cmp    $0x8,%ebx
 1009f0b:	76 05                	jbe    1009f12 <runtime.rnd+0x29>
		m = maxround;
 1009f0d:	bb 08 00 00 00       	mov    $0x8,%ebx
	r = n % m;
 1009f12:	89 e8                	mov    %ebp,%eax
 1009f14:	31 d2                	xor    %edx,%edx
 1009f16:	f7 f3                	div    %ebx
	if(r)
 1009f18:	83 fa 00             	cmp    $0x0,%edx
 1009f1b:	74 06                	je     1009f23 <runtime.rnd+0x3a>
		n += m-r;
 1009f1d:	89 d8                	mov    %ebx,%eax
 1009f1f:	29 d0                	sub    %edx,%eax
 1009f21:	01 c5                	add    %eax,%ebp
	return n;
 1009f23:	89 e8                	mov    %ebp,%eax
 1009f25:	48 83 c4 10          	add    $0x10,%rsp
 1009f29:	c3                   	retq   

0000000001009f2a <runtime.args>:

Slice os·Args;
Slice os·Envs;

void
runtime·args(int32 c, uint8 **v)
 1009f2a:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009f31:	ff ff 
 1009f33:	48 3b 21             	cmp    (%rcx),%rsp
 1009f36:	77 05                	ja     1009f3d <runtime.args+0x13>
 1009f38:	e8 18 7a ff ff       	callq  1001955 <runtime.morestack16>
{
	argc = c;
 1009f3d:	8b 44 24 08          	mov    0x8(%rsp),%eax
 1009f41:	89 04 25 e4 4d 02 01 	mov    %eax,0x1024de4
	argv = v;
 1009f48:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
 1009f4d:	48 89 04 25 38 4e 02 	mov    %rax,0x1024e38
 1009f54:	01 
 1009f55:	c3                   	retq   

0000000001009f56 <runtime.goargs>:

int32 runtime·isplan9;
int32 runtime·iswindows;

void
runtime·goargs(void)
 1009f56:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009f5d:	ff ff 
 1009f5f:	48 3b 21             	cmp    (%rcx),%rsp
 1009f62:	77 05                	ja     1009f69 <runtime.goargs+0x13>
 1009f64:	e8 8a 79 ff ff       	callq  10018f3 <runtime.morestack00>
 1009f69:	48 83 ec 30          	sub    $0x30,%rsp
	
	// for windows implementation see "os" package
	if(Windows)
		return;

	s = runtime·malloc(argc*sizeof s[0]);
 1009f6d:	8b 0c 25 e4 4d 02 01 	mov    0x1024de4,%ecx
 1009f74:	c1 e1 04             	shl    $0x4,%ecx
 1009f77:	48 63 c9             	movslq %ecx,%rcx
 1009f7a:	48 89 0c 24          	mov    %rcx,(%rsp)
 1009f7e:	e8 08 8b ff ff       	callq  1002a8b <runtime.malloc>
 1009f83:	8b 0c 25 e4 4d 02 01 	mov    0x1024de4,%ecx
 1009f8a:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	for(i=0; i<argc; i++)
 1009f8f:	31 db                	xor    %ebx,%ebx
 1009f91:	39 cb                	cmp    %ecx,%ebx
 1009f93:	7d 42                	jge    1009fd7 <runtime.goargs+0x81>
		s[i] = runtime·gostringnocopy(argv[i]);
 1009f95:	48 63 cb             	movslq %ebx,%rcx
 1009f98:	48 c1 e1 04          	shl    $0x4,%rcx
 1009f9c:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 1009fa1:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 1009fa5:	48 89 04 24          	mov    %rax,(%rsp)
 1009fa9:	89 5c 24 24          	mov    %ebx,0x24(%rsp)
 1009fad:	48 63 cb             	movslq %ebx,%rcx
 1009fb0:	48 8b 14 25 38 4e 02 	mov    0x1024e38,%rdx
 1009fb7:	01 
 1009fb8:	48 8b 04 ca          	mov    (%rdx,%rcx,8),%rax
 1009fbc:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 1009fc1:	e8 65 18 00 00       	callq  100b82b <runtime.gostringnocopy>
 1009fc6:	8b 0c 25 e4 4d 02 01 	mov    0x1024de4,%ecx
 1009fcd:	8b 5c 24 24          	mov    0x24(%rsp),%ebx
	// for windows implementation see "os" package
	if(Windows)
		return;

	s = runtime·malloc(argc*sizeof s[0]);
	for(i=0; i<argc; i++)
 1009fd1:	ff c3                	inc    %ebx
 1009fd3:	39 cb                	cmp    %ecx,%ebx
 1009fd5:	7c be                	jl     1009f95 <runtime.goargs+0x3f>
		s[i] = runtime·gostringnocopy(argv[i]);
	os·Args.array = (byte*)s;
 1009fd7:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 1009fdc:	48 89 04 25 e8 4e 02 	mov    %rax,0x1024ee8
 1009fe3:	01 
	os·Args.len = argc;
 1009fe4:	89 0c 25 f0 4e 02 01 	mov    %ecx,0x1024ef0
	os·Args.cap = argc;
 1009feb:	89 0c 25 f4 4e 02 01 	mov    %ecx,0x1024ef4
 1009ff2:	48 83 c4 30          	add    $0x30,%rsp
 1009ff6:	c3                   	retq   

0000000001009ff7 <runtime.goenvs_unix>:
}

void
runtime·goenvs_unix(void)
 1009ff7:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 1009ffe:	ff ff 
 100a000:	48 3b 21             	cmp    (%rcx),%rsp
 100a003:	77 05                	ja     100a00a <runtime.goenvs_unix+0x13>
 100a005:	e8 e9 78 ff ff       	callq  10018f3 <runtime.morestack00>
 100a00a:	48 83 ec 30          	sub    $0x30,%rsp
 100a00e:	8b 34 25 e4 4d 02 01 	mov    0x1024de4,%esi
 100a015:	48 8b 2c 25 38 4e 02 	mov    0x1024e38,%rbp
 100a01c:	01 
{
	String *s;
	int32 i, n;
	
	for(n=0; argv[argc+1+n] != 0; n++)
 100a01d:	31 db                	xor    %ebx,%ebx
 100a01f:	48 63 cb             	movslq %ebx,%rcx
 100a022:	48 63 d6             	movslq %esi,%rdx
 100a025:	48 01 d1             	add    %rdx,%rcx
 100a028:	48 89 ea             	mov    %rbp,%rdx
 100a02b:	48 8d 04 ca          	lea    (%rdx,%rcx,8),%rax
 100a02f:	48 8b 40 08          	mov    0x8(%rax),%rax
 100a033:	48 83 f8 00          	cmp    $0x0,%rax
 100a037:	74 04                	je     100a03d <runtime.goenvs_unix+0x46>
 100a039:	ff c3                	inc    %ebx
 100a03b:	eb e2                	jmp    100a01f <runtime.goenvs_unix+0x28>
		;

	s = runtime·malloc(n*sizeof s[0]);
 100a03d:	89 d9                	mov    %ebx,%ecx
 100a03f:	89 5c 24 20          	mov    %ebx,0x20(%rsp)
 100a043:	c1 e1 04             	shl    $0x4,%ecx
 100a046:	48 63 c9             	movslq %ecx,%rcx
 100a049:	48 89 0c 24          	mov    %rcx,(%rsp)
 100a04d:	e8 39 8a ff ff       	callq  1002a8b <runtime.malloc>
 100a052:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
 100a056:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	for(i=0; i<n; i++)
 100a05b:	31 db                	xor    %ebx,%ebx
 100a05d:	39 cb                	cmp    %ecx,%ebx
 100a05f:	7d 50                	jge    100a0b1 <runtime.goenvs_unix+0xba>
		s[i] = runtime·gostringnocopy(argv[argc+1+i]);
 100a061:	48 63 cb             	movslq %ebx,%rcx
 100a064:	48 c1 e1 04          	shl    $0x4,%rcx
 100a068:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 100a06d:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100a071:	48 89 04 24          	mov    %rax,(%rsp)
 100a075:	89 5c 24 24          	mov    %ebx,0x24(%rsp)
 100a079:	48 63 cb             	movslq %ebx,%rcx
 100a07c:	8b 14 25 e4 4d 02 01 	mov    0x1024de4,%edx
 100a083:	48 63 d2             	movslq %edx,%rdx
 100a086:	48 01 d1             	add    %rdx,%rcx
 100a089:	48 8b 14 25 38 4e 02 	mov    0x1024e38,%rdx
 100a090:	01 
 100a091:	48 8d 04 ca          	lea    (%rdx,%rcx,8),%rax
 100a095:	48 8b 40 08          	mov    0x8(%rax),%rax
 100a099:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100a09e:	e8 88 17 00 00       	callq  100b82b <runtime.gostringnocopy>
 100a0a3:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
 100a0a7:	8b 5c 24 24          	mov    0x24(%rsp),%ebx
	
	for(n=0; argv[argc+1+n] != 0; n++)
		;

	s = runtime·malloc(n*sizeof s[0]);
	for(i=0; i<n; i++)
 100a0ab:	ff c3                	inc    %ebx
 100a0ad:	39 cb                	cmp    %ecx,%ebx
 100a0af:	7c b0                	jl     100a061 <runtime.goenvs_unix+0x6a>
		s[i] = runtime·gostringnocopy(argv[argc+1+i]);
	os·Envs.array = (byte*)s;
 100a0b1:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100a0b6:	48 89 04 25 f8 4e 02 	mov    %rax,0x1024ef8
 100a0bd:	01 
	os·Envs.len = n;
 100a0be:	89 0c 25 00 4f 02 01 	mov    %ecx,0x1024f00
	os·Envs.cap = n;
 100a0c5:	89 0c 25 04 4f 02 01 	mov    %ecx,0x1024f04
 100a0cc:	48 83 c4 30          	add    $0x30,%rsp
 100a0d0:	c3                   	retq   

000000000100a0d1 <runtime.getenv>:
}

byte*
runtime·getenv(int8 *s)
 100a0d1:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a0d8:	ff ff 
 100a0da:	48 3b 21             	cmp    (%rcx),%rsp
 100a0dd:	77 05                	ja     100a0e4 <runtime.getenv+0x13>
 100a0df:	e8 68 78 ff ff       	callq  100194c <runtime.morestack8>
 100a0e4:	48 83 ec 48          	sub    $0x48,%rsp
	int32 i, j, len;
	byte *v, *bs;
	String* envv;
	int32 envc;

	bs = (byte*)s;
 100a0e8:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
	len = runtime·findnull(bs);
 100a0ed:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 100a0f2:	48 89 04 24          	mov    %rax,(%rsp)
 100a0f6:	e8 d1 15 00 00       	callq  100b6cc <runtime.findnull>
 100a0fb:	4c 8b 4c 24 28       	mov    0x28(%rsp),%r9
 100a100:	89 c6                	mov    %eax,%esi
	envv = (String*)os·Envs.array;
 100a102:	4c 8b 04 25 f8 4e 02 	mov    0x1024ef8,%r8
 100a109:	01 
	envc = os·Envs.len;
 100a10a:	44 8b 14 25 00 4f 02 	mov    0x1024f00,%r10d
 100a111:	01 
	for(i=0; i<envc; i++){
 100a112:	31 ed                	xor    %ebp,%ebp
 100a114:	44 39 d5             	cmp    %r10d,%ebp
 100a117:	7d 19                	jge    100a132 <runtime.getenv+0x61>
		if(envv[i].len <= len)
 100a119:	48 63 cd             	movslq %ebp,%rcx
 100a11c:	48 c1 e1 04          	shl    $0x4,%rcx
 100a120:	49 8d 04 08          	lea    (%r8,%rcx,1),%rax
 100a124:	8b 40 08             	mov    0x8(%rax),%eax
 100a127:	39 f0                	cmp    %esi,%eax
 100a129:	7f 0f                	jg     100a13a <runtime.getenv+0x69>

	bs = (byte*)s;
	len = runtime·findnull(bs);
	envv = (String*)os·Envs.array;
	envc = os·Envs.len;
	for(i=0; i<envc; i++){
 100a12b:	ff c5                	inc    %ebp
 100a12d:	44 39 d5             	cmp    %r10d,%ebp
 100a130:	7c e7                	jl     100a119 <runtime.getenv+0x48>
		if(v[len] != '=')
			goto nomatch;
		return v+len+1;
	nomatch:;
	}
	return nil;
 100a132:	48 31 c0             	xor    %rax,%rax
 100a135:	48 83 c4 48          	add    $0x48,%rsp
 100a139:	c3                   	retq   
	envv = (String*)os·Envs.array;
	envc = os·Envs.len;
	for(i=0; i<envc; i++){
		if(envv[i].len <= len)
			continue;
		v = envv[i].str;
 100a13a:	48 63 cd             	movslq %ebp,%rcx
 100a13d:	48 c1 e1 04          	shl    $0x4,%rcx
 100a141:	49 8b 3c 08          	mov    (%r8,%rcx,1),%rdi
		for(j=0; j<len; j++)
 100a145:	31 db                	xor    %ebx,%ebx
 100a147:	39 f3                	cmp    %esi,%ebx
 100a149:	7d 16                	jge    100a161 <runtime.getenv+0x90>
			if(bs[j] != v[j])
 100a14b:	48 63 cb             	movslq %ebx,%rcx
 100a14e:	41 0f b6 04 09       	movzbl (%r9,%rcx,1),%eax
 100a153:	48 63 cb             	movslq %ebx,%rcx
 100a156:	3a 04 0f             	cmp    (%rdi,%rcx,1),%al
 100a159:	75 d0                	jne    100a12b <runtime.getenv+0x5a>
	envc = os·Envs.len;
	for(i=0; i<envc; i++){
		if(envv[i].len <= len)
			continue;
		v = envv[i].str;
		for(j=0; j<len; j++)
 100a15b:	ff c3                	inc    %ebx
 100a15d:	39 f3                	cmp    %esi,%ebx
 100a15f:	7c ea                	jl     100a14b <runtime.getenv+0x7a>
			if(bs[j] != v[j])
				goto nomatch;
		if(v[len] != '=')
 100a161:	48 63 ce             	movslq %esi,%rcx
 100a164:	0f b6 04 0f          	movzbl (%rdi,%rcx,1),%eax
 100a168:	83 f8 3d             	cmp    $0x3d,%eax
 100a16b:	75 be                	jne    100a12b <runtime.getenv+0x5a>
			goto nomatch;
		return v+len+1;
 100a16d:	48 63 ce             	movslq %esi,%rcx
 100a170:	48 8d 04 0f          	lea    (%rdi,%rcx,1),%rax
 100a174:	48 ff c0             	inc    %rax
 100a177:	48 83 c4 48          	add    $0x48,%rsp
 100a17b:	c3                   	retq   

000000000100a17c <runtime.atoi>:
	out = runtime·gostringnocopy(p);
	FLUSH(&out);
}

int32
runtime·atoi(byte *p)
 100a17c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a183:	ff ff 
 100a185:	48 3b 21             	cmp    (%rcx),%rsp
 100a188:	77 05                	ja     100a18f <runtime.atoi+0x13>
 100a18a:	e8 bd 77 ff ff       	callq  100194c <runtime.morestack8>
 100a18f:	48 83 ec 10          	sub    $0x10,%rsp
 100a193:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
{
	int32 n;

	n = 0;
 100a198:	31 c9                	xor    %ecx,%ecx
	while('0' <= *p && *p <= '9')
 100a19a:	0f b6 02             	movzbl (%rdx),%eax
 100a19d:	83 f8 30             	cmp    $0x30,%eax
 100a1a0:	72 08                	jb     100a1aa <runtime.atoi+0x2e>
 100a1a2:	0f b6 02             	movzbl (%rdx),%eax
 100a1a5:	83 f8 39             	cmp    $0x39,%eax
 100a1a8:	76 07                	jbe    100a1b1 <runtime.atoi+0x35>
		n = n*10 + *p++ - '0';
	return n;
 100a1aa:	89 c8                	mov    %ecx,%eax
 100a1ac:	48 83 c4 10          	add    $0x10,%rsp
 100a1b0:	c3                   	retq   
{
	int32 n;

	n = 0;
	while('0' <= *p && *p <= '9')
		n = n*10 + *p++ - '0';
 100a1b1:	89 c8                	mov    %ecx,%eax
 100a1b3:	48 63 c9             	movslq %ecx,%rcx
 100a1b6:	48 8d 04 88          	lea    (%rax,%rcx,4),%rax
 100a1ba:	01 c0                	add    %eax,%eax
 100a1bc:	48 89 d1             	mov    %rdx,%rcx
 100a1bf:	48 ff c2             	inc    %rdx
 100a1c2:	0f b6 09             	movzbl (%rcx),%ecx
 100a1c5:	01 c8                	add    %ecx,%eax
 100a1c7:	83 c0 d0             	add    $0xffffffffffffffd0,%eax
 100a1ca:	89 c1                	mov    %eax,%ecx
runtime·atoi(byte *p)
{
	int32 n;

	n = 0;
	while('0' <= *p && *p <= '9')
 100a1cc:	eb cc                	jmp    100a19a <runtime.atoi+0x1e>

000000000100a1ce <runtime.check>:
		n = n*10 + *p++ - '0';
	return n;
}

void
runtime·check(void)
 100a1ce:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a1d5:	ff ff 
 100a1d7:	48 3b 21             	cmp    (%rcx),%rsp
 100a1da:	77 05                	ja     100a1e1 <runtime.check+0x13>
 100a1dc:	e8 12 77 ff ff       	callq  10018f3 <runtime.morestack00>
 100a1e1:	48 83 ec 68          	sub    $0x68,%rsp
	if(sizeof(struct x1) != 1) runtime·throw("bad sizeof x1");
	if(offsetof(struct y1, y) != 1) runtime·throw("bad offsetof y1.y");
	if(sizeof(struct y1) != 2) runtime·throw("bad sizeof y1");

	uint32 z;
	z = 1;
 100a1e5:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%rsp)
 100a1ec:	00 
	if(!runtime·cas(&z, 1, 2))
 100a1ed:	48 8d 4c 24 24       	lea    0x24(%rsp),%rcx
 100a1f2:	48 89 0c 24          	mov    %rcx,(%rsp)
 100a1f6:	b9 01 00 00 00       	mov    $0x1,%ecx
 100a1fb:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 100a1ff:	b9 02 00 00 00       	mov    $0x2,%ecx
 100a204:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 100a208:	e8 8e 77 ff ff       	callq  100199b <runtime.cas>
 100a20d:	80 f8 00             	cmp    $0x0,%al
 100a210:	75 0e                	jne    100a220 <runtime.check+0x52>
		runtime·throw("cas1");
 100a212:	b8 bd 36 02 01       	mov    $0x10236bd,%eax
 100a217:	48 89 04 24          	mov    %rax,(%rsp)
 100a21b:	e8 19 fb ff ff       	callq  1009d39 <runtime.throw>
	if(z != 2)
 100a220:	83 7c 24 24 02       	cmpl   $0x2,0x24(%rsp)
 100a225:	74 0e                	je     100a235 <runtime.check+0x67>
		runtime·throw("cas2");
 100a227:	b8 c2 36 02 01       	mov    $0x10236c2,%eax
 100a22c:	48 89 04 24          	mov    %rax,(%rsp)
 100a230:	e8 04 fb ff ff       	callq  1009d39 <runtime.throw>

	z = 4;
 100a235:	c7 44 24 24 04 00 00 	movl   $0x4,0x24(%rsp)
 100a23c:	00 
	if(runtime·cas(&z, 5, 6))
 100a23d:	48 8d 4c 24 24       	lea    0x24(%rsp),%rcx
 100a242:	48 89 0c 24          	mov    %rcx,(%rsp)
 100a246:	b9 05 00 00 00       	mov    $0x5,%ecx
 100a24b:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 100a24f:	b9 06 00 00 00       	mov    $0x6,%ecx
 100a254:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 100a258:	e8 3e 77 ff ff       	callq  100199b <runtime.cas>
 100a25d:	80 f8 00             	cmp    $0x0,%al
 100a260:	74 0e                	je     100a270 <runtime.check+0xa2>
		runtime·throw("cas3");
 100a262:	b8 c7 36 02 01       	mov    $0x10236c7,%eax
 100a267:	48 89 04 24          	mov    %rax,(%rsp)
 100a26b:	e8 c9 fa ff ff       	callq  1009d39 <runtime.throw>
	if(z != 4)
 100a270:	83 7c 24 24 04       	cmpl   $0x4,0x24(%rsp)
 100a275:	74 0e                	je     100a285 <runtime.check+0xb7>
		runtime·throw("cas4");
 100a277:	b8 cc 36 02 01       	mov    $0x10236cc,%eax
 100a27c:	48 89 04 24          	mov    %rax,(%rsp)
 100a280:	e8 b4 fa ff ff       	callq  1009d39 <runtime.throw>

	runtime·initsig(0);
 100a285:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
 100a28c:	e8 59 11 00 00       	callq  100b3ea <runtime.initsig>
 100a291:	48 83 c4 68          	add    $0x68,%rsp
 100a295:	c3                   	retq   

000000000100a296 <memhash>:
/*
 * map and chan helpers for
 * dealing with unknown types
 */
static uintptr
memhash(uint32 s, void *a)
 100a296:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a29d:	ff ff 
 100a29f:	48 3b 21             	cmp    (%rcx),%rsp
 100a2a2:	77 05                	ja     100a2a9 <memhash+0x13>
 100a2a4:	e8 ac 76 ff ff       	callq  1001955 <runtime.morestack16>
 100a2a9:	48 83 ec 28          	sub    $0x28,%rsp
 100a2ad:	8b 74 24 30          	mov    0x30(%rsp),%esi
{
	byte *b;
	uintptr hash;

	b = a;
 100a2b1:	48 8b 6c 24 38       	mov    0x38(%rsp),%rbp
	if(sizeof(hash) == 4)
		hash = 2860486313U;
	else
		hash = 33054211828000289ULL;
 100a2b6:	48 bb 21 a6 56 6a a1 	movabs $0x756ea16a56a621,%rbx
 100a2bd:	6e 75 00 
	while(s > 0) {
 100a2c0:	83 fe 00             	cmp    $0x0,%esi
 100a2c3:	76 32                	jbe    100a2f7 <memhash+0x61>
		if(sizeof(hash) == 4)
			hash = (hash ^ *b) * 3267000013UL;
		else
			hash = (hash ^ *b) * 23344194077549503ULL;
 100a2c5:	0f b6 45 00          	movzbl 0x0(%rbp),%eax
 100a2c9:	48 0f b6 c0          	movzbq %al,%rax
 100a2cd:	48 89 d9             	mov    %rbx,%rcx
 100a2d0:	48 31 c1             	xor    %rax,%rcx
 100a2d3:	48 89 c8             	mov    %rcx,%rax
 100a2d6:	48 b9 bf 63 8f bb 6b 	movabs $0x52ef6bbb8f63bf,%rcx
 100a2dd:	ef 52 00 
 100a2e0:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100a2e5:	48 f7 64 24 08       	mulq   0x8(%rsp)
 100a2ea:	48 89 c3             	mov    %rax,%rbx
		b++;
 100a2ed:	48 ff c5             	inc    %rbp
		s--;
 100a2f0:	ff ce                	dec    %esi
	b = a;
	if(sizeof(hash) == 4)
		hash = 2860486313U;
	else
		hash = 33054211828000289ULL;
	while(s > 0) {
 100a2f2:	83 fe 00             	cmp    $0x0,%esi
 100a2f5:	77 ce                	ja     100a2c5 <memhash+0x2f>
		else
			hash = (hash ^ *b) * 23344194077549503ULL;
		b++;
		s--;
	}
	return hash;
 100a2f7:	48 89 d8             	mov    %rbx,%rax
 100a2fa:	48 83 c4 28          	add    $0x28,%rsp
 100a2fe:	c3                   	retq   

000000000100a2ff <memequal>:
}

static uint32
memequal(uint32 s, void *a, void *b)
 100a2ff:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a306:	ff ff 
 100a308:	48 3b 21             	cmp    (%rcx),%rsp
 100a30b:	77 05                	ja     100a312 <memequal+0x13>
 100a30d:	e8 4c 76 ff ff       	callq  100195e <runtime.morestack24>
 100a312:	48 83 ec 20          	sub    $0x20,%rsp
 100a316:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
 100a31b:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
{
	byte *ba, *bb, *aend;

	if(a == b)
 100a320:	48 39 ca             	cmp    %rcx,%rdx
 100a323:	75 0a                	jne    100a32f <memequal+0x30>
	  return 1;
 100a325:	b8 01 00 00 00       	mov    $0x1,%eax
 100a32a:	48 83 c4 20          	add    $0x20,%rsp
 100a32e:	c3                   	retq   
	ba = a;
 100a32f:	48 89 d3             	mov    %rdx,%rbx
	bb = b;
 100a332:	48 89 cd             	mov    %rcx,%rbp
	aend = ba+s;
 100a335:	8b 4c 24 28          	mov    0x28(%rsp),%ecx
 100a339:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100a33d:	48 89 c2             	mov    %rax,%rdx
	while(ba != aend) {
 100a340:	48 39 d3             	cmp    %rdx,%rbx
 100a343:	74 1d                	je     100a362 <memequal+0x63>
		if(*ba != *bb)
 100a345:	0f b6 03             	movzbl (%rbx),%eax
 100a348:	0f b6 4d 00          	movzbl 0x0(%rbp),%ecx
 100a34c:	38 c8                	cmp    %cl,%al
 100a34e:	74 07                	je     100a357 <memequal+0x58>
			return 0;
 100a350:	31 c0                	xor    %eax,%eax
 100a352:	48 83 c4 20          	add    $0x20,%rsp
 100a356:	c3                   	retq   
		ba++;
 100a357:	48 ff c3             	inc    %rbx
		bb++;
 100a35a:	48 ff c5             	inc    %rbp
	if(a == b)
	  return 1;
	ba = a;
	bb = b;
	aend = ba+s;
	while(ba != aend) {
 100a35d:	48 39 d3             	cmp    %rdx,%rbx
 100a360:	75 e3                	jne    100a345 <memequal+0x46>
		if(*ba != *bb)
			return 0;
		ba++;
		bb++;
	}
	return 1;
 100a362:	b8 01 00 00 00       	mov    $0x1,%eax
 100a367:	48 83 c4 20          	add    $0x20,%rsp
 100a36b:	c3                   	retq   

000000000100a36c <memprint>:
}

static void
memprint(uint32 s, void *a)
 100a36c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a373:	ff ff 
 100a375:	48 3b 21             	cmp    (%rcx),%rsp
 100a378:	77 05                	ja     100a37f <memprint+0x13>
 100a37a:	e8 d6 75 ff ff       	callq  1001955 <runtime.morestack16>
 100a37f:	48 83 ec 20          	sub    $0x20,%rsp
 100a383:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
{
	uint64 v;

	v = 0xbadb00b;
 100a388:	48 c7 c1 0b b0 ad 0b 	mov    $0xbadb00b,%rcx
	case 4:
		v = *(uint32*)a;
		break;
	case 8:
		v = *(uint64*)a;
		break;
 100a38f:	8b 44 24 28          	mov    0x28(%rsp),%eax
 100a393:	83 f8 01             	cmp    $0x1,%eax
 100a396:	74 32                	je     100a3ca <memprint+0x5e>
 100a398:	83 f8 02             	cmp    $0x2,%eax
 100a39b:	74 21                	je     100a3be <memprint+0x52>
 100a39d:	83 f8 04             	cmp    $0x4,%eax
 100a3a0:	74 18                	je     100a3ba <memprint+0x4e>
 100a3a2:	83 f8 08             	cmp    $0x8,%eax
 100a3a5:	74 0e                	je     100a3b5 <memprint+0x49>
	}
	runtime·printint(v);
 100a3a7:	48 89 0c 24          	mov    %rcx,(%rsp)
 100a3ab:	e8 d6 d7 ff ff       	callq  1007b86 <runtime.printint>
 100a3b0:	48 83 c4 20          	add    $0x20,%rsp
 100a3b4:	c3                   	retq   
		break;
	case 4:
		v = *(uint32*)a;
		break;
	case 8:
		v = *(uint64*)a;
 100a3b5:	48 8b 0a             	mov    (%rdx),%rcx
		break;
	}
	runtime·printint(v);
 100a3b8:	eb ed                	jmp    100a3a7 <memprint+0x3b>
		break;
	case 2:
		v = *(uint16*)a;
		break;
	case 4:
		v = *(uint32*)a;
 100a3ba:	8b 0a                	mov    (%rdx),%ecx
		break;
	case 8:
		v = *(uint64*)a;
		break;
	}
	runtime·printint(v);
 100a3bc:	eb e9                	jmp    100a3a7 <memprint+0x3b>
	switch(s) {
	case 1:
		v = *(uint8*)a;
		break;
	case 2:
		v = *(uint16*)a;
 100a3be:	0f b7 02             	movzwl (%rdx),%eax
 100a3c1:	48 0f b7 c0          	movzwq %ax,%rax
 100a3c5:	48 89 c1             	mov    %rax,%rcx
		break;
	case 8:
		v = *(uint64*)a;
		break;
	}
	runtime·printint(v);
 100a3c8:	eb dd                	jmp    100a3a7 <memprint+0x3b>
	uint64 v;

	v = 0xbadb00b;
	switch(s) {
	case 1:
		v = *(uint8*)a;
 100a3ca:	0f b6 02             	movzbl (%rdx),%eax
 100a3cd:	48 0f b6 c0          	movzbq %al,%rax
 100a3d1:	48 89 c1             	mov    %rax,%rcx
		break;
	case 8:
		v = *(uint64*)a;
		break;
	}
	runtime·printint(v);
 100a3d4:	eb d1                	jmp    100a3a7 <memprint+0x3b>

000000000100a3d6 <memcopy>:
}

static void
memcopy(uint32 s, void *a, void *b)
 100a3d6:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a3dd:	ff ff 
 100a3df:	48 3b 21             	cmp    (%rcx),%rsp
 100a3e2:	77 05                	ja     100a3e9 <memcopy+0x13>
 100a3e4:	e8 75 75 ff ff       	callq  100195e <runtime.morestack24>
 100a3e9:	48 83 ec 20          	sub    $0x20,%rsp
 100a3ed:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
 100a3f2:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
 100a3f7:	8b 4c 24 28          	mov    0x28(%rsp),%ecx
{
	if(b == nil) {
 100a3fb:	48 83 fb 00          	cmp    $0x0,%rbx
 100a3ff:	75 13                	jne    100a414 <memcopy+0x3e>
		runtime·memclr(a,s);
 100a401:	48 89 14 24          	mov    %rdx,(%rsp)
 100a405:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100a40a:	e8 98 76 ff ff       	callq  1001aa7 <runtime.memclr>
		return;
 100a40f:	48 83 c4 20          	add    $0x20,%rsp
 100a413:	c3                   	retq   
	}
	runtime·memmove(a,b,s);
 100a414:	48 89 14 24          	mov    %rdx,(%rsp)
 100a418:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
 100a41d:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 100a421:	e8 ac 9a ff ff       	callq  1003ed2 <runtime.memmove>
 100a426:	48 83 c4 20          	add    $0x20,%rsp
 100a42a:	c3                   	retq   

000000000100a42b <memequal8>:
}

static uint32
memequal8(uint32 s, uint8 *a, uint8 *b)
 100a42b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a432:	ff ff 
 100a434:	48 3b 21             	cmp    (%rcx),%rsp
 100a437:	77 05                	ja     100a43e <memequal8+0x13>
 100a439:	e8 20 75 ff ff       	callq  100195e <runtime.morestack24>
{
	USED(s);
	return *a == *b;
 100a43e:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
 100a443:	0f b6 00             	movzbl (%rax),%eax
 100a446:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
 100a44b:	0f b6 09             	movzbl (%rcx),%ecx
 100a44e:	38 c8                	cmp    %cl,%al
 100a450:	75 06                	jne    100a458 <memequal8+0x2d>
 100a452:	b8 01 00 00 00       	mov    $0x1,%eax
 100a457:	c3                   	retq   
 100a458:	31 c0                	xor    %eax,%eax
 100a45a:	eb fb                	jmp    100a457 <memequal8+0x2c>

000000000100a45c <memcopy8>:
}

static void
memcopy8(uint32 s, uint8 *a, uint8 *b)
 100a45c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a463:	ff ff 
 100a465:	48 3b 21             	cmp    (%rcx),%rsp
 100a468:	77 05                	ja     100a46f <memcopy8+0x13>
 100a46a:	e8 ef 74 ff ff       	callq  100195e <runtime.morestack24>
 100a46f:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
 100a474:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
{
	USED(s);
	if(b == nil) {
 100a479:	48 83 fa 00          	cmp    $0x0,%rdx
 100a47d:	75 04                	jne    100a483 <memcopy8+0x27>
		*a = 0;
 100a47f:	c6 01 00             	movb   $0x0,(%rcx)
		return;
 100a482:	c3                   	retq   
	}
	*a = *b;
 100a483:	48 89 c8             	mov    %rcx,%rax
 100a486:	0f b6 0a             	movzbl (%rdx),%ecx
 100a489:	88 08                	mov    %cl,(%rax)
 100a48b:	c3                   	retq   

000000000100a48c <memequal16>:
}

static uint32
memequal16(uint32 s, uint16 *a, uint16 *b)
 100a48c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a493:	ff ff 
 100a495:	48 3b 21             	cmp    (%rcx),%rsp
 100a498:	77 05                	ja     100a49f <memequal16+0x13>
 100a49a:	e8 bf 74 ff ff       	callq  100195e <runtime.morestack24>
{
	USED(s);
	return *a == *b;
 100a49f:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
 100a4a4:	0f b7 00             	movzwl (%rax),%eax
 100a4a7:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
 100a4ac:	0f b7 09             	movzwl (%rcx),%ecx
 100a4af:	66 39 c8             	cmp    %cx,%ax
 100a4b2:	75 06                	jne    100a4ba <memequal16+0x2e>
 100a4b4:	b8 01 00 00 00       	mov    $0x1,%eax
 100a4b9:	c3                   	retq   
 100a4ba:	31 c0                	xor    %eax,%eax
 100a4bc:	eb fb                	jmp    100a4b9 <memequal16+0x2d>

000000000100a4be <memcopy16>:
}

static void
memcopy16(uint32 s, uint16 *a, uint16 *b)
 100a4be:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a4c5:	ff ff 
 100a4c7:	48 3b 21             	cmp    (%rcx),%rsp
 100a4ca:	77 05                	ja     100a4d1 <memcopy16+0x13>
 100a4cc:	e8 8d 74 ff ff       	callq  100195e <runtime.morestack24>
 100a4d1:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
 100a4d6:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
{
	USED(s);
	if(b == nil) {
 100a4db:	48 83 fa 00          	cmp    $0x0,%rdx
 100a4df:	75 06                	jne    100a4e7 <memcopy16+0x29>
		*a = 0;
 100a4e1:	66 c7 01 00 00       	movw   $0x0,(%rcx)
		return;
 100a4e6:	c3                   	retq   
	}
	*a = *b;
 100a4e7:	48 89 c8             	mov    %rcx,%rax
 100a4ea:	0f b7 0a             	movzwl (%rdx),%ecx
 100a4ed:	66 89 08             	mov    %cx,(%rax)
 100a4f0:	c3                   	retq   

000000000100a4f1 <memequal32>:
}

static uint32
memequal32(uint32 s, uint32 *a, uint32 *b)
 100a4f1:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a4f8:	ff ff 
 100a4fa:	48 3b 21             	cmp    (%rcx),%rsp
 100a4fd:	77 05                	ja     100a504 <memequal32+0x13>
 100a4ff:	e8 5a 74 ff ff       	callq  100195e <runtime.morestack24>
{
	USED(s);
	return *a == *b;
 100a504:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
 100a509:	8b 00                	mov    (%rax),%eax
 100a50b:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
 100a510:	8b 09                	mov    (%rcx),%ecx
 100a512:	39 c8                	cmp    %ecx,%eax
 100a514:	75 06                	jne    100a51c <memequal32+0x2b>
 100a516:	b8 01 00 00 00       	mov    $0x1,%eax
 100a51b:	c3                   	retq   
 100a51c:	31 c0                	xor    %eax,%eax
 100a51e:	eb fb                	jmp    100a51b <memequal32+0x2a>

000000000100a520 <memcopy32>:
}

static void
memcopy32(uint32 s, uint32 *a, uint32 *b)
 100a520:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a527:	ff ff 
 100a529:	48 3b 21             	cmp    (%rcx),%rsp
 100a52c:	77 05                	ja     100a533 <memcopy32+0x13>
 100a52e:	e8 2b 74 ff ff       	callq  100195e <runtime.morestack24>
 100a533:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
 100a538:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
{
	USED(s);
	if(b == nil) {
 100a53d:	48 83 fa 00          	cmp    $0x0,%rdx
 100a541:	75 07                	jne    100a54a <memcopy32+0x2a>
		*a = 0;
 100a543:	c7 01 00 00 00 00    	movl   $0x0,(%rcx)
		return;
 100a549:	c3                   	retq   
	}
	*a = *b;
 100a54a:	48 89 c8             	mov    %rcx,%rax
 100a54d:	8b 0a                	mov    (%rdx),%ecx
 100a54f:	89 08                	mov    %ecx,(%rax)
 100a551:	c3                   	retq   

000000000100a552 <memequal64>:
}

static uint32
memequal64(uint32 s, uint64 *a, uint64 *b)
 100a552:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a559:	ff ff 
 100a55b:	48 3b 21             	cmp    (%rcx),%rsp
 100a55e:	77 05                	ja     100a565 <memequal64+0x13>
 100a560:	e8 f9 73 ff ff       	callq  100195e <runtime.morestack24>
{
	USED(s);
	return *a == *b;
 100a565:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
 100a56a:	48 8b 00             	mov    (%rax),%rax
 100a56d:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
 100a572:	48 8b 09             	mov    (%rcx),%rcx
 100a575:	48 39 c8             	cmp    %rcx,%rax
 100a578:	75 06                	jne    100a580 <memequal64+0x2e>
 100a57a:	b8 01 00 00 00       	mov    $0x1,%eax
 100a57f:	c3                   	retq   
 100a580:	31 c0                	xor    %eax,%eax
 100a582:	eb fb                	jmp    100a57f <memequal64+0x2d>

000000000100a584 <memcopy64>:
}

static void
memcopy64(uint32 s, uint64 *a, uint64 *b)
 100a584:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a58b:	ff ff 
 100a58d:	48 3b 21             	cmp    (%rcx),%rsp
 100a590:	77 05                	ja     100a597 <memcopy64+0x13>
 100a592:	e8 c7 73 ff ff       	callq  100195e <runtime.morestack24>
 100a597:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
 100a59c:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
{
	USED(s);
	if(b == nil) {
 100a5a1:	48 83 fa 00          	cmp    $0x0,%rdx
 100a5a5:	75 08                	jne    100a5af <memcopy64+0x2b>
		*a = 0;
 100a5a7:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
		return;
 100a5ae:	c3                   	retq   
	}
	*a = *b;
 100a5af:	48 89 c8             	mov    %rcx,%rax
 100a5b2:	48 8b 0a             	mov    (%rdx),%rcx
 100a5b5:	48 89 08             	mov    %rcx,(%rax)
 100a5b8:	c3                   	retq   

000000000100a5b9 <memequal128>:
}

static uint32
memequal128(uint32 s, uint64 *a, uint64 *b)
 100a5b9:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a5c0:	ff ff 
 100a5c2:	48 3b 21             	cmp    (%rcx),%rsp
 100a5c5:	77 05                	ja     100a5cc <memequal128+0x13>
 100a5c7:	e8 92 73 ff ff       	callq  100195e <runtime.morestack24>
 100a5cc:	48 8b 6c 24 10       	mov    0x10(%rsp),%rbp
 100a5d1:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
{
	USED(s);
	return a[0] == b[0] && a[1] == b[1];
 100a5d6:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 100a5da:	48 8b 13             	mov    (%rbx),%rdx
 100a5dd:	48 39 d1             	cmp    %rdx,%rcx
 100a5e0:	75 0d                	jne    100a5ef <memequal128+0x36>
 100a5e2:	48 8b 4d 08          	mov    0x8(%rbp),%rcx
 100a5e6:	48 8b 53 08          	mov    0x8(%rbx),%rdx
 100a5ea:	48 39 d1             	cmp    %rdx,%rcx
 100a5ed:	74 03                	je     100a5f2 <memequal128+0x39>
 100a5ef:	31 c0                	xor    %eax,%eax
 100a5f1:	c3                   	retq   
 100a5f2:	b8 01 00 00 00       	mov    $0x1,%eax
 100a5f7:	eb f8                	jmp    100a5f1 <memequal128+0x38>

000000000100a5f9 <memcopy128>:
}

static void
memcopy128(uint32 s, uint64 *a, uint64 *b)
 100a5f9:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a600:	ff ff 
 100a602:	48 3b 21             	cmp    (%rcx),%rsp
 100a605:	77 05                	ja     100a60c <memcopy128+0x13>
 100a607:	e8 52 73 ff ff       	callq  100195e <runtime.morestack24>
 100a60c:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
 100a611:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
{
	USED(s);
	if(b == nil) {
 100a616:	48 83 fb 00          	cmp    $0x0,%rbx
 100a61a:	75 10                	jne    100a62c <memcopy128+0x33>
		a[0] = 0;
 100a61c:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
		a[1] = 0;
 100a623:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
 100a62a:	00 
		return;
 100a62b:	c3                   	retq   
	}
	a[0] = b[0];
 100a62c:	48 8b 0b             	mov    (%rbx),%rcx
 100a62f:	48 89 0a             	mov    %rcx,(%rdx)
	a[1] = b[1];
 100a632:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
 100a636:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
 100a63a:	c3                   	retq   

000000000100a63b <slicecopy>:
}

static void
slicecopy(uint32 s, Slice *a, Slice *b)
 100a63b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a642:	ff ff 
 100a644:	48 3b 21             	cmp    (%rcx),%rsp
 100a647:	77 05                	ja     100a64e <slicecopy+0x13>
 100a649:	e8 10 73 ff ff       	callq  100195e <runtime.morestack24>
 100a64e:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
 100a653:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
{
	USED(s);
	if(b == nil) {
 100a658:	48 83 fb 00          	cmp    $0x0,%rbx
 100a65c:	75 16                	jne    100a674 <slicecopy+0x39>
		a->array = 0;
 100a65e:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
		a->len = 0;
 100a665:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%rdx)
		a->cap = 0;
 100a66c:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%rdx)
		return;
 100a673:	c3                   	retq   
	}
	a->array = b->array;
 100a674:	48 8b 0b             	mov    (%rbx),%rcx
 100a677:	48 89 0a             	mov    %rcx,(%rdx)
	a->len = b->len;
 100a67a:	8b 4b 08             	mov    0x8(%rbx),%ecx
 100a67d:	89 4a 08             	mov    %ecx,0x8(%rdx)
	a->cap = b->cap;
 100a680:	8b 4b 0c             	mov    0xc(%rbx),%ecx
 100a683:	89 4a 0c             	mov    %ecx,0xc(%rdx)
 100a686:	c3                   	retq   

000000000100a687 <strhash>:
}

static uintptr
strhash(uint32 s, String *a)
 100a687:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a68e:	ff ff 
 100a690:	48 3b 21             	cmp    (%rcx),%rsp
 100a693:	77 05                	ja     100a69a <strhash+0x13>
 100a695:	e8 bb 72 ff ff       	callq  1001955 <runtime.morestack16>
 100a69a:	48 83 ec 18          	sub    $0x18,%rsp
 100a69e:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
{
	USED(s);
	return memhash((*a).len, (*a).str);
 100a6a3:	8b 4a 08             	mov    0x8(%rdx),%ecx
 100a6a6:	89 0c 24             	mov    %ecx,(%rsp)
 100a6a9:	48 8b 0a             	mov    (%rdx),%rcx
 100a6ac:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100a6b1:	e8 e0 fb ff ff       	callq  100a296 <memhash>
 100a6b6:	48 83 c4 18          	add    $0x18,%rsp
 100a6ba:	c3                   	retq   

000000000100a6bb <strequal>:
}

static uint32
strequal(uint32 s, String *a, String *b)
 100a6bb:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a6c2:	ff ff 
 100a6c4:	48 3b 21             	cmp    (%rcx),%rsp
 100a6c7:	77 05                	ja     100a6ce <strequal+0x13>
 100a6c9:	e8 90 72 ff ff       	callq  100195e <runtime.morestack24>
 100a6ce:	48 83 ec 30          	sub    $0x30,%rsp
 100a6d2:	48 8b 6c 24 40       	mov    0x40(%rsp),%rbp
 100a6d7:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
{
	int32 alen;

	USED(s);
	alen = a->len;
 100a6dc:	8b 55 08             	mov    0x8(%rbp),%edx
	if(alen != b->len)
 100a6df:	8b 43 08             	mov    0x8(%rbx),%eax
 100a6e2:	39 c2                	cmp    %eax,%edx
 100a6e4:	74 07                	je     100a6ed <strequal+0x32>
		return false;
 100a6e6:	31 c0                	xor    %eax,%eax
 100a6e8:	48 83 c4 30          	add    $0x30,%rsp
 100a6ec:	c3                   	retq   
	return memequal(alen, a->str, b->str);
 100a6ed:	89 14 24             	mov    %edx,(%rsp)
 100a6f0:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
 100a6f4:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100a6f9:	48 8b 0b             	mov    (%rbx),%rcx
 100a6fc:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100a701:	e8 f9 fb ff ff       	callq  100a2ff <memequal>
 100a706:	48 83 c4 30          	add    $0x30,%rsp
 100a70a:	c3                   	retq   

000000000100a70b <strprint>:
}

static void
strprint(uint32 s, String *a)
 100a70b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a712:	ff ff 
 100a714:	48 3b 21             	cmp    (%rcx),%rsp
 100a717:	77 05                	ja     100a71e <strprint+0x13>
 100a719:	e8 37 72 ff ff       	callq  1001955 <runtime.morestack16>
 100a71e:	48 83 ec 18          	sub    $0x18,%rsp
{
	USED(s);
	runtime·printstring(*a);
 100a722:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100a727:	48 8b 01             	mov    (%rcx),%rax
 100a72a:	48 89 04 24          	mov    %rax,(%rsp)
 100a72e:	48 8b 41 08          	mov    0x8(%rcx),%rax
 100a732:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100a737:	e8 8c d5 ff ff       	callq  1007cc8 <runtime.printstring>
 100a73c:	48 83 c4 18          	add    $0x18,%rsp
 100a740:	c3                   	retq   

000000000100a741 <strcopy>:
}

static void
strcopy(uint32 s, String *a, String *b)
 100a741:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a748:	ff ff 
 100a74a:	48 3b 21             	cmp    (%rcx),%rsp
 100a74d:	77 05                	ja     100a754 <strcopy+0x13>
 100a74f:	e8 0a 72 ff ff       	callq  100195e <runtime.morestack24>
 100a754:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
 100a759:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
{
	USED(s);
	if(b == nil) {
 100a75e:	48 83 fb 00          	cmp    $0x0,%rbx
 100a762:	75 0f                	jne    100a773 <strcopy+0x32>
		a->str = 0;
 100a764:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
		a->len = 0;
 100a76b:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%rdx)
		return;
 100a772:	c3                   	retq   
	}
	a->str = b->str;
 100a773:	48 8b 0b             	mov    (%rbx),%rcx
 100a776:	48 89 0a             	mov    %rcx,(%rdx)
	a->len = b->len;
 100a779:	8b 4b 08             	mov    0x8(%rbx),%ecx
 100a77c:	89 4a 08             	mov    %ecx,0x8(%rdx)
 100a77f:	c3                   	retq   

000000000100a780 <interhash>:
}

static uintptr
interhash(uint32 s, Iface *a)
 100a780:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a787:	ff ff 
 100a789:	48 3b 21             	cmp    (%rcx),%rsp
 100a78c:	77 05                	ja     100a793 <interhash+0x13>
 100a78e:	e8 c2 71 ff ff       	callq  1001955 <runtime.morestack16>
 100a793:	48 83 ec 18          	sub    $0x18,%rsp
{
	USED(s);
	return runtime·ifacehash(*a);
 100a797:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 100a79c:	48 8b 0a             	mov    (%rdx),%rcx
 100a79f:	48 89 0c 24          	mov    %rcx,(%rsp)
 100a7a3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 100a7a7:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100a7ac:	e8 36 7c ff ff       	callq  10023e7 <runtime.ifacehash>
 100a7b1:	48 83 c4 18          	add    $0x18,%rsp
 100a7b5:	c3                   	retq   

000000000100a7b6 <interprint>:
}

static void
interprint(uint32 s, Iface *a)
 100a7b6:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a7bd:	ff ff 
 100a7bf:	48 3b 21             	cmp    (%rcx),%rsp
 100a7c2:	77 05                	ja     100a7c9 <interprint+0x13>
 100a7c4:	e8 8c 71 ff ff       	callq  1001955 <runtime.morestack16>
 100a7c9:	48 83 ec 18          	sub    $0x18,%rsp
{
	USED(s);
	runtime·printiface(*a);
 100a7cd:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100a7d2:	48 8b 01             	mov    (%rcx),%rax
 100a7d5:	48 89 04 24          	mov    %rax,(%rsp)
 100a7d9:	48 8b 41 08          	mov    0x8(%rcx),%rax
 100a7dd:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100a7e2:	e8 1a 74 ff ff       	callq  1001c01 <runtime.printiface>
 100a7e7:	48 83 c4 18          	add    $0x18,%rsp
 100a7eb:	c3                   	retq   

000000000100a7ec <interequal>:
}

static uint32
interequal(uint32 s, Iface *a, Iface *b)
 100a7ec:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a7f3:	ff ff 
 100a7f5:	48 3b 21             	cmp    (%rcx),%rsp
 100a7f8:	77 05                	ja     100a7ff <interequal+0x13>
 100a7fa:	e8 5f 71 ff ff       	callq  100195e <runtime.morestack24>
 100a7ff:	48 83 ec 28          	sub    $0x28,%rsp
{
	USED(s);
	return runtime·ifaceeq_c(*a, *b);
 100a803:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 100a808:	48 8b 0a             	mov    (%rdx),%rcx
 100a80b:	48 89 0c 24          	mov    %rcx,(%rsp)
 100a80f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 100a813:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100a818:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
 100a81d:	48 8b 0a             	mov    (%rdx),%rcx
 100a820:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100a825:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 100a829:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 100a82e:	e8 7d 7d ff ff       	callq  10025b0 <runtime.ifaceeq_c>
 100a833:	0f b6 c0             	movzbl %al,%eax
 100a836:	48 83 c4 28          	add    $0x28,%rsp
 100a83a:	c3                   	retq   

000000000100a83b <intercopy>:
}

static void
intercopy(uint32 s, Iface *a, Iface *b)
 100a83b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a842:	ff ff 
 100a844:	48 3b 21             	cmp    (%rcx),%rsp
 100a847:	77 05                	ja     100a84e <intercopy+0x13>
 100a849:	e8 10 71 ff ff       	callq  100195e <runtime.morestack24>
 100a84e:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
 100a853:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
{
	USED(s);
	if(b == nil) {
 100a858:	48 83 fb 00          	cmp    $0x0,%rbx
 100a85c:	75 10                	jne    100a86e <intercopy+0x33>
		a->tab = 0;
 100a85e:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
		a->data = 0;
 100a865:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
 100a86c:	00 
		return;
 100a86d:	c3                   	retq   
	}
	a->tab = b->tab;
 100a86e:	48 8b 0b             	mov    (%rbx),%rcx
 100a871:	48 89 0a             	mov    %rcx,(%rdx)
	a->data = b->data;
 100a874:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
 100a878:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
 100a87c:	c3                   	retq   

000000000100a87d <nilinterhash>:
}

static uintptr
nilinterhash(uint32 s, Eface *a)
 100a87d:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a884:	ff ff 
 100a886:	48 3b 21             	cmp    (%rcx),%rsp
 100a889:	77 05                	ja     100a890 <nilinterhash+0x13>
 100a88b:	e8 c5 70 ff ff       	callq  1001955 <runtime.morestack16>
 100a890:	48 83 ec 18          	sub    $0x18,%rsp
{
	USED(s);
	return runtime·efacehash(*a);
 100a894:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 100a899:	48 8b 0a             	mov    (%rdx),%rcx
 100a89c:	48 89 0c 24          	mov    %rcx,(%rsp)
 100a8a0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 100a8a4:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100a8a9:	e8 81 7b ff ff       	callq  100242f <runtime.efacehash>
 100a8ae:	48 83 c4 18          	add    $0x18,%rsp
 100a8b2:	c3                   	retq   

000000000100a8b3 <nilinterprint>:
}

static void
nilinterprint(uint32 s, Eface *a)
 100a8b3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a8ba:	ff ff 
 100a8bc:	48 3b 21             	cmp    (%rcx),%rsp
 100a8bf:	77 05                	ja     100a8c6 <nilinterprint+0x13>
 100a8c1:	e8 8f 70 ff ff       	callq  1001955 <runtime.morestack16>
 100a8c6:	48 83 ec 18          	sub    $0x18,%rsp
{
	USED(s);
	runtime·printeface(*a);
 100a8ca:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100a8cf:	48 8b 01             	mov    (%rcx),%rax
 100a8d2:	48 89 04 24          	mov    %rax,(%rsp)
 100a8d6:	48 8b 41 08          	mov    0x8(%rcx),%rax
 100a8da:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100a8df:	e8 5b 73 ff ff       	callq  1001c3f <runtime.printeface>
 100a8e4:	48 83 c4 18          	add    $0x18,%rsp
 100a8e8:	c3                   	retq   

000000000100a8e9 <nilinterequal>:
}

static uint32
nilinterequal(uint32 s, Eface *a, Eface *b)
 100a8e9:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a8f0:	ff ff 
 100a8f2:	48 3b 21             	cmp    (%rcx),%rsp
 100a8f5:	77 05                	ja     100a8fc <nilinterequal+0x13>
 100a8f7:	e8 62 70 ff ff       	callq  100195e <runtime.morestack24>
 100a8fc:	48 83 ec 28          	sub    $0x28,%rsp
{
	USED(s);
	return runtime·efaceeq_c(*a, *b);
 100a900:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 100a905:	48 8b 0a             	mov    (%rdx),%rcx
 100a908:	48 89 0c 24          	mov    %rcx,(%rsp)
 100a90c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 100a910:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100a915:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
 100a91a:	48 8b 0a             	mov    (%rdx),%rcx
 100a91d:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100a922:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 100a926:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 100a92b:	e8 e7 7c ff ff       	callq  1002617 <runtime.efaceeq_c>
 100a930:	0f b6 c0             	movzbl %al,%eax
 100a933:	48 83 c4 28          	add    $0x28,%rsp
 100a937:	c3                   	retq   

000000000100a938 <nilintercopy>:
}

static void
nilintercopy(uint32 s, Eface *a, Eface *b)
 100a938:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a93f:	ff ff 
 100a941:	48 3b 21             	cmp    (%rcx),%rsp
 100a944:	77 05                	ja     100a94b <nilintercopy+0x13>
 100a946:	e8 13 70 ff ff       	callq  100195e <runtime.morestack24>
 100a94b:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
 100a950:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
{
	USED(s);
	if(b == nil) {
 100a955:	48 83 fb 00          	cmp    $0x0,%rbx
 100a959:	75 10                	jne    100a96b <nilintercopy+0x33>
		a->type = 0;
 100a95b:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
		a->data = 0;
 100a962:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
 100a969:	00 
		return;
 100a96a:	c3                   	retq   
	}
	a->type = b->type;
 100a96b:	48 8b 0b             	mov    (%rbx),%rcx
 100a96e:	48 89 0a             	mov    %rcx,(%rdx)
	a->data = b->data;
 100a971:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
 100a975:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
 100a979:	c3                   	retq   

000000000100a97a <runtime.nohash>:
}

uintptr
runtime·nohash(uint32 s, void *a)
 100a97a:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a981:	ff ff 
 100a983:	48 3b 21             	cmp    (%rcx),%rsp
 100a986:	77 05                	ja     100a98d <runtime.nohash+0x13>
 100a988:	e8 c8 6f ff ff       	callq  1001955 <runtime.morestack16>
 100a98d:	48 83 ec 10          	sub    $0x10,%rsp
{
	USED(s);
	USED(a);
	runtime·panicstring("hash of unhashable type");
 100a991:	b8 d1 36 02 01       	mov    $0x10236d1,%eax
 100a996:	48 89 04 24          	mov    %rax,(%rsp)
 100a99a:	e8 f7 f3 ff ff       	callq  1009d96 <runtime.panicstring>
	return 0;
 100a99f:	48 31 c0             	xor    %rax,%rax
 100a9a2:	48 83 c4 10          	add    $0x10,%rsp
 100a9a6:	c3                   	retq   

000000000100a9a7 <runtime.noequal>:
}

uint32
runtime·noequal(uint32 s, void *a, void *b)
 100a9a7:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a9ae:	ff ff 
 100a9b0:	48 3b 21             	cmp    (%rcx),%rsp
 100a9b3:	77 05                	ja     100a9ba <runtime.noequal+0x13>
 100a9b5:	e8 a4 6f ff ff       	callq  100195e <runtime.morestack24>
 100a9ba:	48 83 ec 10          	sub    $0x10,%rsp
{
	USED(s);
	USED(a);
	USED(b);
	runtime·panicstring("comparing uncomparable types");
 100a9be:	b8 e9 36 02 01       	mov    $0x10236e9,%eax
 100a9c3:	48 89 04 24          	mov    %rax,(%rsp)
 100a9c7:	e8 ca f3 ff ff       	callq  1009d96 <runtime.panicstring>
	return 0;
 100a9cc:	31 c0                	xor    %eax,%eax
 100a9ce:	48 83 c4 10          	add    $0x10,%rsp
 100a9d2:	c3                   	retq   

000000000100a9d3 <runtime.nanotime>:
[ANOEQ64]	{ runtime·nohash, runtime·noequal, memprint, memcopy64 },
[ANOEQ128]	{ runtime·nohash, runtime·noequal, memprint, memcopy128 },
};

int64
runtime·nanotime(void)
 100a9d3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100a9da:	ff ff 
 100a9dc:	48 3b 21             	cmp    (%rcx),%rsp
 100a9df:	77 05                	ja     100a9e6 <runtime.nanotime+0x13>
 100a9e1:	e8 0d 6f ff ff       	callq  10018f3 <runtime.morestack00>
 100a9e6:	48 83 ec 30          	sub    $0x30,%rsp
{
	int64 sec;
	int32 usec;

	sec = 0;
 100a9ea:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
 100a9f1:	00 00 
	usec = 0;
 100a9f3:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%rsp)
 100a9fa:	00 
	runtime·gettime(&sec, &usec);
 100a9fb:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100aa00:	48 89 04 24          	mov    %rax,(%rsp)
 100aa04:	48 8d 44 24 24       	lea    0x24(%rsp),%rax
 100aa09:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100aa0e:	e8 df 1d 00 00       	callq  100c7f2 <runtime.gettime>
	return sec*1000000000 + (int64)usec*1000;
 100aa13:	48 c7 c0 40 42 0f 00 	mov    $0xf4240,%rax
 100aa1a:	48 0f af 44 24 28    	imul   0x28(%rsp),%rax
 100aa20:	8b 4c 24 24          	mov    0x24(%rsp),%ecx
 100aa24:	48 63 c9             	movslq %ecx,%rcx
 100aa27:	48 01 c1             	add    %rax,%rcx
 100aa2a:	48 89 c8             	mov    %rcx,%rax
 100aa2d:	48 69 c0 e8 03 00 00 	imul   $0x3e8,%rax,%rax
 100aa34:	48 83 c4 30          	add    $0x30,%rsp
 100aa38:	c3                   	retq   

000000000100aa39 <runtime.fastrand1>:
	retf = runtime·findfunc(pc);
	FLUSH(&retf);
}

uint32
runtime·fastrand1(void)
 100aa39:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100aa40:	ff ff 
 100aa42:	48 3b 21             	cmp    (%rcx),%rsp
 100aa45:	77 05                	ja     100aa4c <runtime.fastrand1+0x13>
 100aa47:	e8 a7 6e ff ff       	callq  10018f3 <runtime.morestack00>
 100aa4c:	48 83 ec 10          	sub    $0x10,%rsp
{
	uint32 x;

	x = m->fastrand;
 100aa50:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100aa57:	ff ff 
 100aa59:	8b 90 98 00 00 00    	mov    0x98(%rax),%edx
	x += x;
 100aa5f:	01 d2                	add    %edx,%edx
	if(x & 0x80000000L)
 100aa61:	89 d0                	mov    %edx,%eax
 100aa63:	25 00 00 00 80       	and    $0x80000000,%eax
 100aa68:	83 f8 00             	cmp    $0x0,%eax
 100aa6b:	74 06                	je     100aa73 <runtime.fastrand1+0x3a>
		x ^= 0x88888eefUL;
 100aa6d:	81 f2 ef 8e 88 88    	xor    $0x88888eef,%edx
	m->fastrand = x;
 100aa73:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100aa7a:	ff ff 
 100aa7c:	89 90 98 00 00 00    	mov    %edx,0x98(%rax)
 100aa82:	89 d0                	mov    %edx,%eax
 100aa84:	48 83 c4 10          	add    $0x10,%rsp
 100aa88:	c3                   	retq   

000000000100aa89 <_rt0_amd64_ucoresmp>:
// license that can be found in the LICENSE file.

// Darwin and Linux use the same linkage to main

TEXT _rt0_amd64_ucoresmp(SB),7,$-8
	MOVQ	$_rt0_amd64(SB), AX
 100aa89:	b8 51 16 00 01       	mov    $0x1001651,%eax
	MOVQ	SP, DI
 100aa8e:	48 89 e7             	mov    %rsp,%rdi
 100aa91:	ff e0                	jmpq   *%rax

000000000100aa93 <semroot>:
	// with 16-4096 byte cache lines, 128 looks like a good compromise.
	uint8 pad[128];
} semtable[SEMTABLESZ];

static SemaRoot*
semroot(uint32 *addr)
 100aa93:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100aa9a:	ff ff 
 100aa9c:	48 3b 21             	cmp    (%rcx),%rsp
 100aa9f:	77 05                	ja     100aaa6 <semroot+0x13>
 100aaa1:	e8 a6 6e ff ff       	callq  100194c <runtime.morestack8>
 100aaa6:	48 83 ec 18          	sub    $0x18,%rsp
{
	return &semtable[((uintptr)addr >> 3) % SEMTABLESZ];
 100aaaa:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100aaaf:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100aab4:	48 c1 e8 03          	shr    $0x3,%rax
 100aab8:	31 d2                	xor    %edx,%edx
 100aaba:	48 c7 44 24 08 fb 00 	movq   $0xfb,0x8(%rsp)
 100aac1:	00 00 
 100aac3:	48 f7 74 24 08       	divq   0x8(%rsp)
 100aac8:	48 89 d1             	mov    %rdx,%rcx
 100aacb:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
 100aad0:	48 c1 e1 07          	shl    $0x7,%rcx
 100aad4:	48 8d 04 0d 00 a3 02 	lea    0x102a300(,%rcx,1),%rax
 100aadb:	01 
 100aadc:	48 83 c4 18          	add    $0x18,%rsp
 100aae0:	c3                   	retq   

000000000100aae1 <semqueue>:
}

static void
semqueue(SemaRoot *root, uint32 volatile *addr, Sema *s)
 100aae1:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100aae8:	ff ff 
 100aaea:	48 3b 21             	cmp    (%rcx),%rsp
 100aaed:	77 05                	ja     100aaf4 <semqueue+0x13>
 100aaef:	e8 6a 6e ff ff       	callq  100195e <runtime.morestack24>
 100aaf4:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
 100aaf9:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
{
	s->g = g;
 100aafe:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100ab05:	ff ff 
 100ab07:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	s->addr = addr;
 100ab0b:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
 100ab10:	48 89 0a             	mov    %rcx,(%rdx)
	s->next = nil;
 100ab13:	48 c7 42 18 00 00 00 	movq   $0x0,0x18(%rdx)
 100ab1a:	00 
	s->prev = root->tail;
 100ab1b:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
 100ab1f:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
	if(root->tail)
 100ab23:	48 8b 43 10          	mov    0x10(%rbx),%rax
 100ab27:	48 83 f8 00          	cmp    $0x0,%rax
 100ab2b:	74 0d                	je     100ab3a <semqueue+0x59>
		root->tail->next = s;
 100ab2d:	48 8b 43 10          	mov    0x10(%rbx),%rax
 100ab31:	48 89 50 18          	mov    %rdx,0x18(%rax)
	else
		root->head = s;
	root->tail = s;
 100ab35:	48 89 53 10          	mov    %rdx,0x10(%rbx)
 100ab39:	c3                   	retq   
	s->next = nil;
	s->prev = root->tail;
	if(root->tail)
		root->tail->next = s;
	else
		root->head = s;
 100ab3a:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	root->tail = s;
 100ab3e:	eb f5                	jmp    100ab35 <semqueue+0x54>

000000000100ab40 <semdequeue>:
}

static void
semdequeue(SemaRoot *root, Sema *s)
 100ab40:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100ab47:	ff ff 
 100ab49:	48 3b 21             	cmp    (%rcx),%rsp
 100ab4c:	77 05                	ja     100ab53 <semdequeue+0x13>
 100ab4e:	e8 02 6e ff ff       	callq  1001955 <runtime.morestack16>
 100ab53:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
 100ab58:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
{
	if(s->next)
 100ab5d:	48 8b 42 18          	mov    0x18(%rdx),%rax
 100ab61:	48 83 f8 00          	cmp    $0x0,%rax
 100ab65:	74 3d                	je     100aba4 <semdequeue+0x64>
		s->next->prev = s->prev;
 100ab67:	48 8b 42 18          	mov    0x18(%rdx),%rax
 100ab6b:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
 100ab6f:	48 89 48 10          	mov    %rcx,0x10(%rax)
	else
		root->tail = s->prev;
	if(s->prev)
 100ab73:	48 8b 42 10          	mov    0x10(%rdx),%rax
 100ab77:	48 83 f8 00          	cmp    $0x0,%rax
 100ab7b:	74 1d                	je     100ab9a <semdequeue+0x5a>
		s->prev->next = s->next;
 100ab7d:	48 8b 42 10          	mov    0x10(%rdx),%rax
 100ab81:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 100ab85:	48 89 48 18          	mov    %rcx,0x18(%rax)
	else
		root->head = s->next;
	s->prev = nil;
 100ab89:	48 c7 42 10 00 00 00 	movq   $0x0,0x10(%rdx)
 100ab90:	00 
	s->next = nil;
 100ab91:	48 c7 42 18 00 00 00 	movq   $0x0,0x18(%rdx)
 100ab98:	00 
 100ab99:	c3                   	retq   
	else
		root->tail = s->prev;
	if(s->prev)
		s->prev->next = s->next;
	else
		root->head = s->next;
 100ab9a:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 100ab9e:	48 89 4b 08          	mov    %rcx,0x8(%rbx)
	s->prev = nil;
 100aba2:	eb e5                	jmp    100ab89 <semdequeue+0x49>
semdequeue(SemaRoot *root, Sema *s)
{
	if(s->next)
		s->next->prev = s->prev;
	else
		root->tail = s->prev;
 100aba4:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
 100aba8:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
	if(s->prev)
 100abac:	eb c5                	jmp    100ab73 <semdequeue+0x33>

000000000100abae <cansemacquire>:
	s->prev = nil;
	s->next = nil;
}

static int32
cansemacquire(uint32 *addr)
 100abae:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100abb5:	ff ff 
 100abb7:	48 3b 21             	cmp    (%rcx),%rsp
 100abba:	77 05                	ja     100abc1 <cansemacquire+0x13>
 100abbc:	e8 8b 6d ff ff       	callq  100194c <runtime.morestack8>
 100abc1:	48 83 ec 28          	sub    $0x28,%rsp
{
	uint32 v;

	while((v = runtime·atomicload(addr)) > 0)
 100abc5:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 100abca:	48 89 0c 24          	mov    %rcx,(%rsp)
 100abce:	e8 06 6f ff ff       	callq  1001ad9 <runtime.atomicload>
 100abd3:	83 f8 00             	cmp    $0x0,%eax
 100abd6:	76 2d                	jbe    100ac05 <cansemacquire+0x57>
		if(runtime·cas(addr, v, v-1))
 100abd8:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 100abdd:	48 89 0c 24          	mov    %rcx,(%rsp)
 100abe1:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100abe5:	89 c1                	mov    %eax,%ecx
 100abe7:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
 100abed:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 100abf1:	e8 a5 6d ff ff       	callq  100199b <runtime.cas>
 100abf6:	80 f8 00             	cmp    $0x0,%al
 100abf9:	74 ca                	je     100abc5 <cansemacquire+0x17>
			return 1;
 100abfb:	b8 01 00 00 00       	mov    $0x1,%eax
 100ac00:	48 83 c4 28          	add    $0x28,%rsp
 100ac04:	c3                   	retq   
	return 0;
 100ac05:	31 c0                	xor    %eax,%eax
 100ac07:	48 83 c4 28          	add    $0x28,%rsp
 100ac0b:	c3                   	retq   

000000000100ac0c <runtime.semacquire>:
}

void
runtime·semacquire(uint32 volatile *addr)
 100ac0c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100ac13:	ff ff 
 100ac15:	48 3b 21             	cmp    (%rcx),%rsp
 100ac18:	77 05                	ja     100ac1f <runtime.semacquire+0x13>
 100ac1a:	e8 2d 6d ff ff       	callq  100194c <runtime.morestack8>
 100ac1f:	48 83 ec 50          	sub    $0x50,%rsp
{
	Sema s;
	SemaRoot *root;

	// Easy case.
	if(cansemacquire(addr))
 100ac23:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 100ac28:	48 89 0c 24          	mov    %rcx,(%rsp)
 100ac2c:	e8 7d ff ff ff       	callq  100abae <cansemacquire>
 100ac31:	83 f8 00             	cmp    $0x0,%eax
 100ac34:	74 05                	je     100ac3b <runtime.semacquire+0x2f>
		return;
 100ac36:	48 83 c4 50          	add    $0x50,%rsp
 100ac3a:	c3                   	retq   
	//	increment waiter count
	//	try cansemacquire one more time, return if succeeded
	//	enqueue itself as a waiter
	//	sleep
	//	(waiter descriptor is dequeued by signaler)
	root = semroot(addr);
 100ac3b:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 100ac40:	48 89 0c 24          	mov    %rcx,(%rsp)
 100ac44:	e8 4a fe ff ff       	callq  100aa93 <semroot>
 100ac49:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	for(;;) {
		runtime·lock(root);
 100ac4e:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100ac53:	48 89 04 24          	mov    %rax,(%rsp)
 100ac57:	e8 d4 21 00 00       	callq  100ce30 <runtime.lock>
		// Add ourselves to nwait to disable "easy case" in semrelease.
		runtime·xadd(&root->nwait, 1);
 100ac5c:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100ac61:	48 83 c0 18          	add    $0x18,%rax
 100ac65:	48 89 04 24          	mov    %rax,(%rsp)
 100ac69:	b8 01 00 00 00       	mov    $0x1,%eax
 100ac6e:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100ac72:	e8 5f 6d ff ff       	callq  10019d6 <runtime.xadd>
		// Check cansemacquire to avoid missed wakeup.
		if(cansemacquire(addr)) {
 100ac77:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 100ac7c:	48 89 0c 24          	mov    %rcx,(%rsp)
 100ac80:	e8 29 ff ff ff       	callq  100abae <cansemacquire>
 100ac85:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
 100ac8a:	83 f8 00             	cmp    $0x0,%eax
 100ac8d:	74 2c                	je     100acbb <runtime.semacquire+0xaf>
			runtime·xadd(&root->nwait, -1);
 100ac8f:	48 89 c8             	mov    %rcx,%rax
 100ac92:	48 83 c0 18          	add    $0x18,%rax
 100ac96:	48 89 04 24          	mov    %rax,(%rsp)
 100ac9a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 100ac9f:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100aca3:	e8 2e 6d ff ff       	callq  10019d6 <runtime.xadd>
			runtime·unlock(root);
 100aca8:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100acad:	48 89 04 24          	mov    %rax,(%rsp)
 100acb1:	e8 cc 21 00 00       	callq  100ce82 <runtime.unlock>
			return;
 100acb6:	48 83 c4 50          	add    $0x50,%rsp
 100acba:	c3                   	retq   
		}
		// Any semrelease after the cansemacquire knows we're waiting
		// (we set nwait above), so go to sleep.
		semqueue(root, addr, &s);
 100acbb:	48 89 0c 24          	mov    %rcx,(%rsp)
 100acbf:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 100acc4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100acc9:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
 100acce:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100acd3:	e8 09 fe ff ff       	callq  100aae1 <semqueue>
		g->status = Gwaiting;
 100acd8:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100acdf:	ff ff 
 100ace1:	66 c7 40 70 04 00    	movw   $0x4,0x70(%rax)
		runtime·unlock(root);
 100ace7:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100acec:	48 89 04 24          	mov    %rax,(%rsp)
 100acf0:	e8 8d 21 00 00       	callq  100ce82 <runtime.unlock>
		runtime·gosched();
 100acf5:	e8 b6 e0 ff ff       	callq  1008db0 <runtime.gosched>
		if(cansemacquire(addr))
 100acfa:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
 100acff:	48 89 0c 24          	mov    %rcx,(%rsp)
 100ad03:	e8 a6 fe ff ff       	callq  100abae <cansemacquire>
 100ad08:	83 f8 00             	cmp    $0x0,%eax
 100ad0b:	0f 84 3d ff ff ff    	je     100ac4e <runtime.semacquire+0x42>
			return;
 100ad11:	48 83 c4 50          	add    $0x50,%rsp
 100ad15:	c3                   	retq   

000000000100ad16 <runtime.semrelease>:
	}
}

void
runtime·semrelease(uint32 volatile *addr)
 100ad16:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100ad1d:	ff ff 
 100ad1f:	48 3b 21             	cmp    (%rcx),%rsp
 100ad22:	77 05                	ja     100ad29 <runtime.semrelease+0x13>
 100ad24:	e8 23 6c ff ff       	callq  100194c <runtime.morestack8>
 100ad29:	48 83 ec 30          	sub    $0x30,%rsp
{
	Sema *s;
	SemaRoot *root;

	root = semroot(addr);
 100ad2d:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 100ad32:	48 89 0c 24          	mov    %rcx,(%rsp)
 100ad36:	e8 58 fd ff ff       	callq  100aa93 <semroot>
 100ad3b:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
	runtime·xadd(addr, 1);
 100ad40:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100ad45:	48 89 04 24          	mov    %rax,(%rsp)
 100ad49:	b8 01 00 00 00       	mov    $0x1,%eax
 100ad4e:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100ad52:	e8 7f 6c ff ff       	callq  10019d6 <runtime.xadd>

	// Easy case: no waiters?
	// This check must happen after the xadd, to avoid a missed wakeup
	// (see loop in semacquire).
	if(runtime·atomicload(&root->nwait) == 0)
 100ad57:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 100ad5c:	48 83 c1 18          	add    $0x18,%rcx
 100ad60:	48 89 0c 24          	mov    %rcx,(%rsp)
 100ad64:	e8 70 6d ff ff       	callq  1001ad9 <runtime.atomicload>
 100ad69:	83 f8 00             	cmp    $0x0,%eax
 100ad6c:	75 05                	jne    100ad73 <runtime.semrelease+0x5d>
		return;
 100ad6e:	48 83 c4 30          	add    $0x30,%rsp
 100ad72:	c3                   	retq   

	// Harder case: search for a waiter and wake it.
	runtime·lock(root);
 100ad73:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100ad78:	48 89 04 24          	mov    %rax,(%rsp)
 100ad7c:	e8 af 20 00 00       	callq  100ce30 <runtime.lock>
	if(runtime·atomicload(&root->nwait) == 0) {
 100ad81:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 100ad86:	48 83 c1 18          	add    $0x18,%rcx
 100ad8a:	48 89 0c 24          	mov    %rcx,(%rsp)
 100ad8e:	e8 46 6d ff ff       	callq  1001ad9 <runtime.atomicload>
 100ad93:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
 100ad98:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 100ad9d:	83 f8 00             	cmp    $0x0,%eax
 100ada0:	75 0e                	jne    100adb0 <runtime.semrelease+0x9a>
		// The count is already consumed by another goroutine,
		// so no need to wake up another goroutine.
		runtime·unlock(root);
 100ada2:	48 89 1c 24          	mov    %rbx,(%rsp)
 100ada6:	e8 d7 20 00 00       	callq  100ce82 <runtime.unlock>
		return;
 100adab:	48 83 c4 30          	add    $0x30,%rsp
 100adaf:	c3                   	retq   
	}
	for(s = root->head; s; s = s->next) {
 100adb0:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
 100adb4:	48 83 f9 00          	cmp    $0x0,%rcx
 100adb8:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
 100adbd:	74 3e                	je     100adfd <runtime.semrelease+0xe7>
		if(s->addr == addr) {
 100adbf:	48 8b 01             	mov    (%rcx),%rax
 100adc2:	48 39 d0             	cmp    %rdx,%rax
 100adc5:	75 5c                	jne    100ae23 <runtime.semrelease+0x10d>
			runtime·xadd(&root->nwait, -1);
 100adc7:	48 89 d8             	mov    %rbx,%rax
 100adca:	48 83 c0 18          	add    $0x18,%rax
 100adce:	48 89 04 24          	mov    %rax,(%rsp)
 100add2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 100add7:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100addb:	e8 f6 6b ff ff       	callq  10019d6 <runtime.xadd>
			semdequeue(root, s);
 100ade0:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100ade5:	48 89 04 24          	mov    %rax,(%rsp)
 100ade9:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100adee:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100adf3:	e8 48 fd ff ff       	callq  100ab40 <semdequeue>
 100adf8:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
			break;
		}
	}
	runtime·unlock(root);
 100adfd:	48 89 1c 24          	mov    %rbx,(%rsp)
 100ae01:	e8 7c 20 00 00       	callq  100ce82 <runtime.unlock>
 100ae06:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
	if(s)
 100ae0b:	48 83 f9 00          	cmp    $0x0,%rcx
 100ae0f:	74 0d                	je     100ae1e <runtime.semrelease+0x108>
		runtime·ready(s->g);
 100ae11:	48 8b 41 08          	mov    0x8(%rcx),%rax
 100ae15:	48 89 04 24          	mov    %rax,(%rsp)
 100ae19:	e8 d9 d5 ff ff       	callq  10083f7 <runtime.ready>
 100ae1e:	48 83 c4 30          	add    $0x30,%rsp
 100ae22:	c3                   	retq   
 100ae23:	48 8b 49 18          	mov    0x18(%rcx),%rcx
 100ae27:	eb 8b                	jmp    100adb4 <runtime.semrelease+0x9e>

000000000100ae29 <runtime.dumpregs>:
#include "defs.h"
#include "signals.h"
#include "os.h"

void
runtime·dumpregs(Sigcontext *r)
 100ae29:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100ae30:	ff ff 
 100ae32:	48 3b 21             	cmp    (%rcx),%rsp
 100ae35:	77 05                	ja     100ae3c <runtime.dumpregs+0x13>
 100ae37:	e8 10 6b ff ff       	callq  100194c <runtime.morestack8>
 100ae3c:	48 83 ec 18          	sub    $0x18,%rsp
{
	runtime·printf("rax     %X\n", r->rax);
 100ae40:	b8 c6 4c 02 01       	mov    $0x1024cc6,%eax
 100ae45:	48 89 04 24          	mov    %rax,(%rsp)
 100ae49:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100ae4e:	48 8b 40 68          	mov    0x68(%rax),%rax
 100ae52:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100ae57:	e8 e2 c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rbx     %X\n", r->rbx);
 100ae5c:	b8 d2 4c 02 01       	mov    $0x1024cd2,%eax
 100ae61:	48 89 04 24          	mov    %rax,(%rsp)
 100ae65:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100ae6a:	48 8b 40 58          	mov    0x58(%rax),%rax
 100ae6e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100ae73:	e8 c6 c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rcx     %X\n", r->rcx);
 100ae78:	b8 de 4c 02 01       	mov    $0x1024cde,%eax
 100ae7d:	48 89 04 24          	mov    %rax,(%rsp)
 100ae81:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100ae86:	48 8b 40 70          	mov    0x70(%rax),%rax
 100ae8a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100ae8f:	e8 aa c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rdx     %X\n", r->rdx);
 100ae94:	b8 ea 4c 02 01       	mov    $0x1024cea,%eax
 100ae99:	48 89 04 24          	mov    %rax,(%rsp)
 100ae9d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100aea2:	48 8b 40 60          	mov    0x60(%rax),%rax
 100aea6:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100aeab:	e8 8e c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rdi     %X\n", r->rdi);
 100aeb0:	b8 f6 4c 02 01       	mov    $0x1024cf6,%eax
 100aeb5:	48 89 04 24          	mov    %rax,(%rsp)
 100aeb9:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100aebe:	48 8b 40 40          	mov    0x40(%rax),%rax
 100aec2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100aec7:	e8 72 c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rsi     %X\n", r->rsi);
 100aecc:	b8 02 4d 02 01       	mov    $0x1024d02,%eax
 100aed1:	48 89 04 24          	mov    %rax,(%rsp)
 100aed5:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100aeda:	48 8b 40 48          	mov    0x48(%rax),%rax
 100aede:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100aee3:	e8 56 c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rbp     %X\n", r->rbp);
 100aee8:	b8 0e 4d 02 01       	mov    $0x1024d0e,%eax
 100aeed:	48 89 04 24          	mov    %rax,(%rsp)
 100aef1:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100aef6:	48 8b 40 50          	mov    0x50(%rax),%rax
 100aefa:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100aeff:	e8 3a c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rsp     %X\n", r->rsp);
 100af04:	b8 1a 4d 02 01       	mov    $0x1024d1a,%eax
 100af09:	48 89 04 24          	mov    %rax,(%rsp)
 100af0d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100af12:	48 8b 40 78          	mov    0x78(%rax),%rax
 100af16:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100af1b:	e8 1e c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("r8      %X\n", r->r8 );
 100af20:	b8 26 4d 02 01       	mov    $0x1024d26,%eax
 100af25:	48 89 04 24          	mov    %rax,(%rsp)
 100af29:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100af2e:	48 8b 00             	mov    (%rax),%rax
 100af31:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100af36:	e8 03 c4 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("r9      %X\n", r->r9 );
 100af3b:	b8 32 4d 02 01       	mov    $0x1024d32,%eax
 100af40:	48 89 04 24          	mov    %rax,(%rsp)
 100af44:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100af49:	48 8b 40 08          	mov    0x8(%rax),%rax
 100af4d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100af52:	e8 e7 c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("r10     %X\n", r->r10);
 100af57:	b8 3e 4d 02 01       	mov    $0x1024d3e,%eax
 100af5c:	48 89 04 24          	mov    %rax,(%rsp)
 100af60:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100af65:	48 8b 40 10          	mov    0x10(%rax),%rax
 100af69:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100af6e:	e8 cb c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("r11     %X\n", r->r11);
 100af73:	b8 4a 4d 02 01       	mov    $0x1024d4a,%eax
 100af78:	48 89 04 24          	mov    %rax,(%rsp)
 100af7c:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100af81:	48 8b 40 18          	mov    0x18(%rax),%rax
 100af85:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100af8a:	e8 af c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("r12     %X\n", r->r12);
 100af8f:	b8 56 4d 02 01       	mov    $0x1024d56,%eax
 100af94:	48 89 04 24          	mov    %rax,(%rsp)
 100af98:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100af9d:	48 8b 40 20          	mov    0x20(%rax),%rax
 100afa1:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100afa6:	e8 93 c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("r13     %X\n", r->r13);
 100afab:	b8 62 4d 02 01       	mov    $0x1024d62,%eax
 100afb0:	48 89 04 24          	mov    %rax,(%rsp)
 100afb4:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100afb9:	48 8b 40 28          	mov    0x28(%rax),%rax
 100afbd:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100afc2:	e8 77 c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("r14     %X\n", r->r14);
 100afc7:	b8 6e 4d 02 01       	mov    $0x1024d6e,%eax
 100afcc:	48 89 04 24          	mov    %rax,(%rsp)
 100afd0:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100afd5:	48 8b 40 30          	mov    0x30(%rax),%rax
 100afd9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100afde:	e8 5b c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("r15     %X\n", r->r15);
 100afe3:	b8 7a 4d 02 01       	mov    $0x1024d7a,%eax
 100afe8:	48 89 04 24          	mov    %rax,(%rsp)
 100afec:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100aff1:	48 8b 40 38          	mov    0x38(%rax),%rax
 100aff5:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100affa:	e8 3f c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rip     %X\n", r->rip);
 100afff:	b8 86 4d 02 01       	mov    $0x1024d86,%eax
 100b004:	48 89 04 24          	mov    %rax,(%rsp)
 100b008:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100b00d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
 100b014:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b019:	e8 20 c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("rflags  %X\n", r->eflags);
 100b01e:	b8 92 4d 02 01       	mov    $0x1024d92,%eax
 100b023:	48 89 04 24          	mov    %rax,(%rsp)
 100b027:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100b02c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
 100b033:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b038:	e8 01 c3 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("cs      %X\n", (uint64)r->cs);
 100b03d:	b8 9e 4d 02 01       	mov    $0x1024d9e,%eax
 100b042:	48 89 04 24          	mov    %rax,(%rsp)
 100b046:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100b04b:	0f b7 80 90 00 00 00 	movzwl 0x90(%rax),%eax
 100b052:	48 0f b7 c0          	movzwq %ax,%rax
 100b056:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b05b:	e8 de c2 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("fs      %X\n", (uint64)r->fs);
 100b060:	b8 aa 4d 02 01       	mov    $0x1024daa,%eax
 100b065:	48 89 04 24          	mov    %rax,(%rsp)
 100b069:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100b06e:	0f b7 80 94 00 00 00 	movzwl 0x94(%rax),%eax
 100b075:	48 0f b7 c0          	movzwq %ax,%rax
 100b079:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b07e:	e8 bb c2 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("gs      %X\n", (uint64)r->gs);
 100b083:	b8 b6 4d 02 01       	mov    $0x1024db6,%eax
 100b088:	48 89 04 24          	mov    %rax,(%rsp)
 100b08c:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100b091:	0f b7 80 92 00 00 00 	movzwl 0x92(%rax),%eax
 100b098:	48 0f b7 c0          	movzwq %ax,%rax
 100b09c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b0a1:	e8 98 c2 ff ff       	callq  100733e <runtime.printf>
 100b0a6:	48 83 c4 18          	add    $0x18,%rsp
 100b0aa:	c3                   	retq   

000000000100b0ab <runtime.sighandler>:
		return runtime·emptystring;
	return runtime·gostringnocopy((byte*)runtime·sigtab[sig].name);
}

void
runtime·sighandler(int32 sig, Siginfo *info, void *context, G *gp)
 100b0ab:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b0b2:	ff ff 
 100b0b4:	48 3b 21             	cmp    (%rcx),%rsp
 100b0b7:	77 05                	ja     100b0be <runtime.sighandler+0x13>
 100b0b9:	e8 a9 68 ff ff       	callq  1001967 <runtime.morestack32>
 100b0be:	48 83 ec 50          	sub    $0x50,%rsp
 100b0c2:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
 100b0c7:	48 8b 6c 24 70       	mov    0x70(%rsp),%rbp
 100b0cc:	8b 5c 24 58          	mov    0x58(%rsp),%ebx
	Ucontext *uc;
	Mcontext *mc;
	Sigcontext *r;
	uintptr *sp;

	uc = context;
 100b0d0:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
	mc = &uc->uc_mcontext;
 100b0d5:	48 83 c2 28          	add    $0x28,%rdx
	r = (Sigcontext*)mc;	// same layout, more conveient names
 100b0d9:	48 89 54 24 38       	mov    %rdx,0x38(%rsp)

	if(sig == SIGPROF) {
 100b0de:	83 fb 1b             	cmp    $0x1b,%ebx
 100b0e1:	75 2c                	jne    100b10f <runtime.sighandler+0x64>
		runtime·sigprof((uint8*)r->rip, (uint8*)r->rsp, nil, gp);
 100b0e3:	48 8b 82 80 00 00 00 	mov    0x80(%rdx),%rax
 100b0ea:	48 89 04 24          	mov    %rax,(%rsp)
 100b0ee:	48 8b 42 78          	mov    0x78(%rdx),%rax
 100b0f2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b0f7:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 100b0fe:	00 00 
 100b100:	48 89 6c 24 18       	mov    %rbp,0x18(%rsp)
 100b105:	e8 b9 e8 ff ff       	callq  10099c3 <runtime.sigprof>
		return;
 100b10a:	48 83 c4 50          	add    $0x50,%rsp
 100b10e:	c3                   	retq   
	}

	if(gp != nil && (runtime·sigtab[sig].flags & SigPanic)) {
 100b10f:	48 83 fd 00          	cmp    $0x0,%rbp
 100b113:	74 1a                	je     100b12f <runtime.sighandler+0x84>
 100b115:	48 63 cb             	movslq %ebx,%rcx
 100b118:	48 c1 e1 04          	shl    $0x4,%rcx
 100b11c:	8b 04 0d b0 3c 02 01 	mov    0x1023cb0(,%rcx,1),%eax
 100b123:	83 e0 10             	and    $0x10,%eax
 100b126:	83 f8 00             	cmp    $0x0,%eax
 100b129:	0f 85 61 01 00 00    	jne    100b290 <runtime.sighandler+0x1e5>
		}
		r->rip = (uintptr)runtime·sigpanic;
		return;
	}

	if(runtime·sigtab[sig].flags & SigQueue) {
 100b12f:	48 63 cb             	movslq %ebx,%rcx
 100b132:	48 c1 e1 04          	shl    $0x4,%rcx
 100b136:	8b 04 0d b0 3c 02 01 	mov    0x1023cb0(,%rcx,1),%eax
 100b13d:	83 e0 08             	and    $0x8,%eax
 100b140:	83 f8 00             	cmp    $0x0,%eax
 100b143:	74 3f                	je     100b184 <runtime.sighandler+0xd9>
		if(runtime·sigsend(sig) || (runtime·sigtab[sig].flags & SigIgnore))
 100b145:	89 1c 24             	mov    %ebx,(%rsp)
 100b148:	e8 80 04 00 00       	callq  100b5cd <runtime.sigsend>
 100b14d:	3c 00                	cmp    $0x0,%al
 100b14f:	0f 85 36 01 00 00    	jne    100b28b <runtime.sighandler+0x1e0>
 100b155:	8b 4c 24 58          	mov    0x58(%rsp),%ecx
 100b159:	48 63 c9             	movslq %ecx,%rcx
 100b15c:	48 c1 e1 04          	shl    $0x4,%rcx
 100b160:	8b 04 0d b0 3c 02 01 	mov    0x1023cb0(,%rcx,1),%eax
 100b167:	83 e0 02             	and    $0x2,%eax
 100b16a:	83 f8 00             	cmp    $0x0,%eax
 100b16d:	0f 85 18 01 00 00    	jne    100b28b <runtime.sighandler+0x1e0>
			return;
		runtime·exit(2);	// SIGINT, SIGTERM, etc
 100b173:	b8 02 00 00 00       	mov    $0x2,%eax
 100b178:	89 04 24             	mov    %eax,(%rsp)
 100b17b:	e8 f1 15 00 00       	callq  100c771 <runtime.exit>
 100b180:	8b 5c 24 58          	mov    0x58(%rsp),%ebx
	}

	if(runtime·panicking)	// traceback already printed
 100b184:	83 3c 25 20 4e 02 01 	cmpl   $0x0,0x1024e20
 100b18b:	00 
 100b18c:	74 11                	je     100b19f <runtime.sighandler+0xf4>
		runtime·exit(2);
 100b18e:	b8 02 00 00 00       	mov    $0x2,%eax
 100b193:	89 04 24             	mov    %eax,(%rsp)
 100b196:	e8 d6 15 00 00       	callq  100c771 <runtime.exit>
 100b19b:	8b 5c 24 58          	mov    0x58(%rsp),%ebx
	runtime·panicking = 1;
 100b19f:	c7 04 25 20 4e 02 01 	movl   $0x1,0x1024e20
 100b1a6:	01 00 00 00 

	if(sig < 0 || sig >= NSIG)
 100b1aa:	83 fb 00             	cmp    $0x0,%ebx
 100b1ad:	0f 8c c1 00 00 00    	jl     100b274 <runtime.sighandler+0x1c9>
 100b1b3:	83 fb 20             	cmp    $0x20,%ebx
 100b1b6:	0f 8d b8 00 00 00    	jge    100b274 <runtime.sighandler+0x1c9>
		runtime·printf("Signal %d\n", sig);
	else
		runtime·printf("%s\n", runtime·sigtab[sig].name);
 100b1bc:	b8 cd 4d 02 01       	mov    $0x1024dcd,%eax
 100b1c1:	48 89 04 24          	mov    %rax,(%rsp)
 100b1c5:	48 63 cb             	movslq %ebx,%rcx
 100b1c8:	48 c1 e1 04          	shl    $0x4,%rcx
 100b1cc:	48 8b 04 0d b8 3c 02 	mov    0x1023cb8(,%rcx,1),%rax
 100b1d3:	01 
 100b1d4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b1d9:	e8 60 c1 ff ff       	callq  100733e <runtime.printf>

	runtime·printf("PC=%X\n", r->rip);
 100b1de:	b8 d1 4d 02 01       	mov    $0x1024dd1,%eax
 100b1e3:	48 89 04 24          	mov    %rax,(%rsp)
 100b1e7:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100b1ec:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
 100b1f3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b1f8:	e8 41 c1 ff ff       	callq  100733e <runtime.printf>
	runtime·printf("\n");
 100b1fd:	b8 d8 4d 02 01       	mov    $0x1024dd8,%eax
 100b202:	48 89 04 24          	mov    %rax,(%rsp)
 100b206:	e8 33 c1 ff ff       	callq  100733e <runtime.printf>

	if(runtime·gotraceback()){
 100b20b:	e8 90 e8 ff ff       	callq  1009aa0 <runtime.gotraceback>
 100b210:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 100b215:	83 f8 00             	cmp    $0x0,%eax
 100b218:	74 48                	je     100b262 <runtime.sighandler+0x1b7>
		runtime·traceback((void*)r->rip, (void*)r->rsp, 0, gp);
 100b21a:	48 8b 81 80 00 00 00 	mov    0x80(%rcx),%rax
 100b221:	48 89 04 24          	mov    %rax,(%rsp)
 100b225:	48 8b 41 78          	mov    0x78(%rcx),%rax
 100b229:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b22e:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 100b235:	00 00 
 100b237:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
 100b23c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 100b241:	e8 9f 27 00 00       	callq  100d9e5 <runtime.traceback>
		runtime·tracebackothers(gp);
 100b246:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
 100b24b:	48 89 04 24          	mov    %rax,(%rsp)
 100b24f:	e8 20 cd ff ff       	callq  1007f74 <runtime.tracebackothers>
		runtime·dumpregs(r);
 100b254:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100b259:	48 89 04 24          	mov    %rax,(%rsp)
 100b25d:	e8 c7 fb ff ff       	callq  100ae29 <runtime.dumpregs>
	}

	runtime·exit(2);
 100b262:	b8 02 00 00 00       	mov    $0x2,%eax
 100b267:	89 04 24             	mov    %eax,(%rsp)
 100b26a:	e8 02 15 00 00       	callq  100c771 <runtime.exit>
 100b26f:	48 83 c4 50          	add    $0x50,%rsp
 100b273:	c3                   	retq   
	if(runtime·panicking)	// traceback already printed
		runtime·exit(2);
	runtime·panicking = 1;

	if(sig < 0 || sig >= NSIG)
		runtime·printf("Signal %d\n", sig);
 100b274:	b8 c2 4d 02 01       	mov    $0x1024dc2,%eax
 100b279:	48 89 04 24          	mov    %rax,(%rsp)
 100b27d:	89 5c 24 08          	mov    %ebx,0x8(%rsp)
 100b281:	e8 b8 c0 ff ff       	callq  100733e <runtime.printf>
	else
		runtime·printf("%s\n", runtime·sigtab[sig].name);

	runtime·printf("PC=%X\n", r->rip);
 100b286:	e9 53 ff ff ff       	jmpq   100b1de <runtime.sighandler+0x133>
		return;
	}

	if(runtime·sigtab[sig].flags & SigQueue) {
		if(runtime·sigsend(sig) || (runtime·sigtab[sig].flags & SigIgnore))
			return;
 100b28b:	48 83 c4 50          	add    $0x50,%rsp
 100b28f:	c3                   	retq   
	if(gp != nil && (runtime·sigtab[sig].flags & SigPanic)) {
		// Make it look like a call to the signal func.
		// Have to pass arguments out of band since
		// augmenting the stack frame would break
		// the unwinding code.
		gp->sig = sig;
 100b290:	89 9d a8 00 00 00    	mov    %ebx,0xa8(%rbp)
		gp->sigcode0 = info->si_code;
 100b296:	8b 4e 08             	mov    0x8(%rsi),%ecx
 100b299:	48 63 c9             	movslq %ecx,%rcx
 100b29c:	48 89 8d b0 00 00 00 	mov    %rcx,0xb0(%rbp)
		gp->sigcode1 = ((uintptr*)info)[2];
 100b2a3:	48 8b 4e 10          	mov    0x10(%rsi),%rcx
 100b2a7:	48 89 8d b8 00 00 00 	mov    %rcx,0xb8(%rbp)
		gp->sigpc = r->rip;
 100b2ae:	48 8b 8a 80 00 00 00 	mov    0x80(%rdx),%rcx
 100b2b5:	48 89 8d c0 00 00 00 	mov    %rcx,0xc0(%rbp)
		// If r->rip == 0, probably panicked because of a
		// call to a nil func.  Not pushing that onto sp will
		// make the trace look like a call to runtime·sigpanic instead.
		// (Otherwise the trace will end at runtime·sigpanic and we
		// won't get to see who faulted.)
		if(r->rip != 0) {
 100b2bc:	48 8b 82 80 00 00 00 	mov    0x80(%rdx),%rax
 100b2c3:	48 83 f8 00          	cmp    $0x0,%rax
 100b2c7:	74 16                	je     100b2df <runtime.sighandler+0x234>
			sp = (uintptr*)r->rsp;
 100b2c9:	48 8b 5a 78          	mov    0x78(%rdx),%rbx
			*--sp = r->rip;
 100b2cd:	48 83 c3 f8          	add    $0xfffffffffffffff8,%rbx
 100b2d1:	48 8b 8a 80 00 00 00 	mov    0x80(%rdx),%rcx
 100b2d8:	48 89 0b             	mov    %rcx,(%rbx)
			r->rsp = (uintptr)sp;
 100b2db:	48 89 5a 78          	mov    %rbx,0x78(%rdx)
		}
		r->rip = (uintptr)runtime·sigpanic;
 100b2df:	b9 a6 d0 00 01       	mov    $0x100d0a6,%ecx
 100b2e4:	48 89 8a 80 00 00 00 	mov    %rcx,0x80(%rdx)
		return;
 100b2eb:	48 83 c4 50          	add    $0x50,%rsp
 100b2ef:	c3                   	retq   

000000000100b2f0 <runtime.signalstack>:

	runtime·exit(2);
}

void
runtime·signalstack(byte *p, int32 n)
 100b2f0:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b2f7:	ff ff 
 100b2f9:	48 3b 21             	cmp    (%rcx),%rsp
 100b2fc:	77 05                	ja     100b303 <runtime.signalstack+0x13>
 100b2fe:	e8 52 66 ff ff       	callq  1001955 <runtime.morestack16>
 100b303:	48 83 ec 38          	sub    $0x38,%rsp
{
	Sigaltstack st;

	st.ss_sp = p;
 100b307:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
 100b30c:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
	st.ss_size = n;
 100b311:	8b 44 24 48          	mov    0x48(%rsp),%eax
 100b315:	48 63 c0             	movslq %eax,%rax
 100b318:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
	st.ss_flags = 0;
 100b31d:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%rsp)
 100b324:	00 
	runtime·sigaltstack(&st, nil);
 100b325:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
 100b32a:	48 89 04 24          	mov    %rax,(%rsp)
 100b32e:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
 100b335:	00 00 
 100b337:	e8 4c 16 00 00       	callq  100c988 <runtime.sigaltstack>
 100b33c:	48 83 c4 38          	add    $0x38,%rsp
 100b340:	c3                   	retq   

000000000100b341 <sigaction>:
}

static void
sigaction(int32 i, void (*fn)(int32, Siginfo*, void*, G*), bool restart)
 100b341:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b348:	ff ff 
 100b34a:	48 3b 21             	cmp    (%rcx),%rsp
 100b34d:	77 05                	ja     100b354 <sigaction+0x13>
 100b34f:	e8 0a 66 ff ff       	callq  100195e <runtime.morestack24>
 100b354:	48 83 ec 50          	sub    $0x50,%rsp
{
	Sigaction sa;

	runtime·memclr((byte*)&sa, sizeof sa);
 100b358:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
 100b35d:	48 89 04 24          	mov    %rax,(%rsp)
 100b361:	48 c7 c0 20 00 00 00 	mov    $0x20,%rax
 100b368:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b36d:	e8 35 67 ff ff       	callq  1001aa7 <runtime.memclr>
 100b372:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
	sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTORER;
 100b377:	48 c7 44 24 38 04 00 	movq   $0xc000004,0x38(%rsp)
 100b37e:	00 0c 
	if(restart)
 100b380:	80 7c 24 68 00       	cmpb   $0x0,0x68(%rsp)
 100b385:	74 09                	je     100b390 <sigaction+0x4f>
		sa.sa_flags |= SA_RESTART;
 100b387:	48 81 4c 24 38 00 00 	orq    $0x10000000,0x38(%rsp)
 100b38e:	00 10 
	sa.sa_mask = ~0ULL;
 100b390:	48 c7 44 24 48 ff ff 	movq   $0xffffffffffffffff,0x48(%rsp)
 100b397:	ff ff 
	sa.sa_restorer = (void*)runtime·sigreturn;
 100b399:	b8 93 c8 00 01       	mov    $0x100c893,%eax
 100b39e:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
	if(fn == runtime·sighandler)
 100b3a3:	48 81 f9 ab b0 00 01 	cmp    $0x100b0ab,%rcx
 100b3aa:	75 05                	jne    100b3b1 <sigaction+0x70>
		fn = (void*)runtime·sigtramp;
 100b3ac:	b9 3f c8 00 01       	mov    $0x100c83f,%ecx
	sa.sa_handler = fn;
 100b3b1:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
	runtime·rt_sigaction(i, &sa, nil, 8);
 100b3b6:	8b 44 24 58          	mov    0x58(%rsp),%eax
 100b3ba:	48 63 c0             	movslq %eax,%rax
 100b3bd:	48 89 04 24          	mov    %rax,(%rsp)
 100b3c1:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
 100b3c6:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b3cb:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 100b3d2:	00 00 
 100b3d4:	48 c7 c0 08 00 00 00 	mov    $0x8,%rax
 100b3db:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 100b3e0:	e8 3f 14 00 00       	callq  100c824 <runtime.rt_sigaction>
 100b3e5:	48 83 c4 50          	add    $0x50,%rsp
 100b3e9:	c3                   	retq   

000000000100b3ea <runtime.initsig>:
}

void
runtime·initsig(int32 queue)
 100b3ea:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b3f1:	ff ff 
 100b3f3:	48 3b 21             	cmp    (%rcx),%rsp
 100b3f6:	77 05                	ja     100b3fd <runtime.initsig+0x13>
 100b3f8:	e8 4f 65 ff ff       	callq  100194c <runtime.morestack8>
 100b3fd:	48 83 ec 30          	sub    $0x30,%rsp
{
	int32 i;
	void *fn;

	runtime·siginit();
 100b401:	e8 9d 01 00 00       	callq  100b5a3 <runtime.siginit>

	for(i = 0; i<NSIG; i++) {
 100b406:	31 d2                	xor    %edx,%edx
 100b408:	83 fa 20             	cmp    $0x20,%edx
 100b40b:	7d 2f                	jge    100b43c <runtime.initsig+0x52>
		if(runtime·sigtab[i].flags) {
 100b40d:	48 63 c2             	movslq %edx,%rax
 100b410:	48 c1 e0 04          	shl    $0x4,%rax
 100b414:	83 3c 05 b0 3c 02 01 	cmpl   $0x0,0x1023cb0(,%rax,1)
 100b41b:	00 
 100b41c:	74 17                	je     100b435 <runtime.initsig+0x4b>
			if((runtime·sigtab[i].flags & SigQueue) != queue)
 100b41e:	48 63 ca             	movslq %edx,%rcx
 100b421:	48 c1 e1 04          	shl    $0x4,%rcx
 100b425:	8b 04 0d b0 3c 02 01 	mov    0x1023cb0(,%rcx,1),%eax
 100b42c:	83 e0 08             	and    $0x8,%eax
 100b42f:	3b 44 24 38          	cmp    0x38(%rsp),%eax
 100b433:	74 0c                	je     100b441 <runtime.initsig+0x57>
	int32 i;
	void *fn;

	runtime·siginit();

	for(i = 0; i<NSIG; i++) {
 100b435:	ff c2                	inc    %edx
 100b437:	83 fa 20             	cmp    $0x20,%edx
 100b43a:	7c d1                	jl     100b40d <runtime.initsig+0x23>
				continue;
			if(runtime·sigtab[i].flags & (SigCatch | SigQueue))
				fn = runtime·sighandler;
			else
				fn = runtime·sigignore;
			sigaction(i, fn, (runtime·sigtab[i].flags & SigRestart) != 0);
 100b43c:	48 83 c4 30          	add    $0x30,%rsp
 100b440:	c3                   	retq   

	for(i = 0; i<NSIG; i++) {
		if(runtime·sigtab[i].flags) {
			if((runtime·sigtab[i].flags & SigQueue) != queue)
				continue;
			if(runtime·sigtab[i].flags & (SigCatch | SigQueue))
 100b441:	48 63 ca             	movslq %edx,%rcx
 100b444:	48 c1 e1 04          	shl    $0x4,%rcx
 100b448:	8b 04 0d b0 3c 02 01 	mov    0x1023cb0(,%rcx,1),%eax
 100b44f:	83 e0 09             	and    $0x9,%eax
 100b452:	83 f8 00             	cmp    $0x0,%eax
 100b455:	74 3f                	je     100b496 <runtime.initsig+0xac>
				fn = runtime·sighandler;
 100b457:	b9 ab b0 00 01       	mov    $0x100b0ab,%ecx
			else
				fn = runtime·sigignore;
			sigaction(i, fn, (runtime·sigtab[i].flags & SigRestart) != 0);
 100b45c:	89 14 24             	mov    %edx,(%rsp)
 100b45f:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100b464:	89 54 24 2c          	mov    %edx,0x2c(%rsp)
 100b468:	48 63 ca             	movslq %edx,%rcx
 100b46b:	48 c1 e1 04          	shl    $0x4,%rcx
 100b46f:	8b 04 0d b0 3c 02 01 	mov    0x1023cb0(,%rcx,1),%eax
 100b476:	83 e0 04             	and    $0x4,%eax
 100b479:	83 f8 00             	cmp    $0x0,%eax
 100b47c:	74 14                	je     100b492 <runtime.initsig+0xa8>
 100b47e:	b8 01 00 00 00       	mov    $0x1,%eax
 100b483:	88 44 24 10          	mov    %al,0x10(%rsp)
 100b487:	e8 b5 fe ff ff       	callq  100b341 <sigaction>
 100b48c:	8b 54 24 2c          	mov    0x2c(%rsp),%edx
	int32 i;
	void *fn;

	runtime·siginit();

	for(i = 0; i<NSIG; i++) {
 100b490:	eb a3                	jmp    100b435 <runtime.initsig+0x4b>
				continue;
			if(runtime·sigtab[i].flags & (SigCatch | SigQueue))
				fn = runtime·sighandler;
			else
				fn = runtime·sigignore;
			sigaction(i, fn, (runtime·sigtab[i].flags & SigRestart) != 0);
 100b492:	31 c0                	xor    %eax,%eax
 100b494:	eb ed                	jmp    100b483 <runtime.initsig+0x99>
			if((runtime·sigtab[i].flags & SigQueue) != queue)
				continue;
			if(runtime·sigtab[i].flags & (SigCatch | SigQueue))
				fn = runtime·sighandler;
			else
				fn = runtime·sigignore;
 100b496:	b9 92 c8 00 01       	mov    $0x100c892,%ecx
			sigaction(i, fn, (runtime·sigtab[i].flags & SigRestart) != 0);
 100b49b:	eb bf                	jmp    100b45c <runtime.initsig+0x72>

000000000100b49d <runtime.resetcpuprofiler>:
		}
	}
}

void
runtime·resetcpuprofiler(int32 hz)
 100b49d:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b4a4:	ff ff 
 100b4a6:	48 3b 21             	cmp    (%rcx),%rsp
 100b4a9:	77 05                	ja     100b4b0 <runtime.resetcpuprofiler+0x13>
 100b4ab:	e8 9c 64 ff ff       	callq  100194c <runtime.morestack8>
 100b4b0:	48 83 ec 48          	sub    $0x48,%rsp
{
	Itimerval it;
	
	runtime·memclr((byte*)&it, sizeof it);
 100b4b4:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100b4b9:	48 89 04 24          	mov    %rax,(%rsp)
 100b4bd:	48 c7 c0 20 00 00 00 	mov    $0x20,%rax
 100b4c4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b4c9:	e8 d9 65 ff ff       	callq  1001aa7 <runtime.memclr>
	if(hz == 0) {
 100b4ce:	83 7c 24 50 00       	cmpl   $0x0,0x50(%rsp)
 100b4d3:	75 5a                	jne    100b52f <runtime.resetcpuprofiler+0x92>
		runtime·setitimer(ITIMER_PROF, &it, nil);
 100b4d5:	b8 02 00 00 00       	mov    $0x2,%eax
 100b4da:	89 04 24             	mov    %eax,(%rsp)
 100b4dd:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100b4e2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b4e7:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 100b4ee:	00 00 
 100b4f0:	e8 d0 12 00 00       	callq  100c7c5 <runtime.setitimer>
		sigaction(SIGPROF, SIG_IGN, true);
 100b4f5:	b8 1b 00 00 00       	mov    $0x1b,%eax
 100b4fa:	89 04 24             	mov    %eax,(%rsp)
 100b4fd:	48 c7 c0 01 00 00 00 	mov    $0x1,%rax
 100b504:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b509:	b8 01 00 00 00       	mov    $0x1,%eax
 100b50e:	88 44 24 10          	mov    %al,0x10(%rsp)
 100b512:	e8 2a fe ff ff       	callq  100b341 <sigaction>
		it.it_interval.tv_sec = 0;
		it.it_interval.tv_usec = 1000000 / hz;
		it.it_value = it.it_interval;
		runtime·setitimer(ITIMER_PROF, &it, nil);
	}
	m->profilehz = hz;
 100b517:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100b51e:	ff ff 
 100b520:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
 100b524:	89 88 94 00 00 00    	mov    %ecx,0x94(%rax)
 100b52a:	48 83 c4 48          	add    $0x48,%rsp
 100b52e:	c3                   	retq   
	runtime·memclr((byte*)&it, sizeof it);
	if(hz == 0) {
		runtime·setitimer(ITIMER_PROF, &it, nil);
		sigaction(SIGPROF, SIG_IGN, true);
	} else {
		sigaction(SIGPROF, runtime·sighandler, true);
 100b52f:	b8 1b 00 00 00       	mov    $0x1b,%eax
 100b534:	89 04 24             	mov    %eax,(%rsp)
 100b537:	b8 ab b0 00 01       	mov    $0x100b0ab,%eax
 100b53c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b541:	b8 01 00 00 00       	mov    $0x1,%eax
 100b546:	88 44 24 10          	mov    %al,0x10(%rsp)
 100b54a:	e8 f2 fd ff ff       	callq  100b341 <sigaction>
		it.it_interval.tv_sec = 0;
 100b54f:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
 100b556:	00 00 
		it.it_interval.tv_usec = 1000000 / hz;
 100b558:	b8 40 42 0f 00       	mov    $0xf4240,%eax
 100b55d:	99                   	cltd   
 100b55e:	f7 7c 24 50          	idivl  0x50(%rsp)
 100b562:	48 63 c0             	movslq %eax,%rax
 100b565:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
		it.it_value = it.it_interval;
 100b56a:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100b56f:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
 100b574:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100b579:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
		runtime·setitimer(ITIMER_PROF, &it, nil);
 100b57e:	b8 02 00 00 00       	mov    $0x2,%eax
 100b583:	89 04 24             	mov    %eax,(%rsp)
 100b586:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100b58b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b590:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 100b597:	00 00 
 100b599:	e8 27 12 00 00       	callq  100c7c5 <runtime.setitimer>
 100b59e:	e9 74 ff ff ff       	jmpq   100b517 <runtime.resetcpuprofiler+0x7a>

000000000100b5a3 <runtime.siginit>:
	uint32 mask;
	bool inuse;
} sig;

void
runtime·siginit(void)
 100b5a3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b5aa:	ff ff 
 100b5ac:	48 3b 21             	cmp    (%rcx),%rsp
 100b5af:	77 05                	ja     100b5b6 <runtime.siginit+0x13>
 100b5b1:	e8 3d 63 ff ff       	callq  10018f3 <runtime.morestack00>
 100b5b6:	48 83 ec 10          	sub    $0x10,%rsp
{
	runtime·noteclear(&sig);
 100b5ba:	b8 18 4f 02 01       	mov    $0x1024f18,%eax
 100b5bf:	48 89 04 24          	mov    %rax,(%rsp)
 100b5c3:	e8 0c 19 00 00       	callq  100ced4 <runtime.noteclear>
 100b5c8:	48 83 c4 10          	add    $0x10,%rsp
 100b5cc:	c3                   	retq   

000000000100b5cd <runtime.sigsend>:
}

// Called from sighandler to send a signal back out of the signal handling thread.
bool
runtime·sigsend(int32 s)
 100b5cd:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b5d4:	ff ff 
 100b5d6:	48 3b 21             	cmp    (%rcx),%rsp
 100b5d9:	77 05                	ja     100b5e0 <runtime.sigsend+0x13>
 100b5db:	e8 6c 63 ff ff       	callq  100194c <runtime.morestack8>
 100b5e0:	48 83 ec 28          	sub    $0x28,%rsp
{
	uint32 bit, mask;

	if(!sig.inuse)
 100b5e4:	80 3c 25 28 4f 02 01 	cmpb   $0x0,0x1024f28
 100b5eb:	00 
 100b5ec:	75 07                	jne    100b5f5 <runtime.sigsend+0x28>
		return false;
 100b5ee:	31 c0                	xor    %eax,%eax
 100b5f0:	48 83 c4 28          	add    $0x28,%rsp
 100b5f4:	c3                   	retq   
	bit = 1 << s;
 100b5f5:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
 100b5f9:	b8 01 00 00 00       	mov    $0x1,%eax
 100b5fe:	d3 e0                	shl    %cl,%eax
 100b600:	89 c3                	mov    %eax,%ebx
	for(;;) {
		mask = sig.mask;
 100b602:	8b 14 25 24 4f 02 01 	mov    0x1024f24,%edx
		if(mask & bit)
 100b609:	89 d0                	mov    %edx,%eax
 100b60b:	21 d8                	and    %ebx,%eax
 100b60d:	83 f8 00             	cmp    $0x0,%eax
 100b610:	74 0a                	je     100b61c <runtime.sigsend+0x4f>
			if(mask == 0)
				runtime·notewakeup(&sig);
			break;
		}
	}
	return true;
 100b612:	b8 01 00 00 00       	mov    $0x1,%eax
 100b617:	48 83 c4 28          	add    $0x28,%rsp
 100b61b:	c3                   	retq   
	bit = 1 << s;
	for(;;) {
		mask = sig.mask;
		if(mask & bit)
			break;		// signal already in queue
		if(runtime·cas(&sig.mask, mask, mask|bit)) {
 100b61c:	b9 24 4f 02 01       	mov    $0x1024f24,%ecx
 100b621:	48 89 0c 24          	mov    %rcx,(%rsp)
 100b625:	89 54 24 08          	mov    %edx,0x8(%rsp)
 100b629:	89 d1                	mov    %edx,%ecx
 100b62b:	89 54 24 20          	mov    %edx,0x20(%rsp)
 100b62f:	09 d9                	or     %ebx,%ecx
 100b631:	89 5c 24 24          	mov    %ebx,0x24(%rsp)
 100b635:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 100b639:	e8 5d 63 ff ff       	callq  100199b <runtime.cas>
 100b63e:	8b 5c 24 24          	mov    0x24(%rsp),%ebx
 100b642:	80 f8 00             	cmp    $0x0,%al
 100b645:	74 bb                	je     100b602 <runtime.sigsend+0x35>
			// Added to queue.
			// Only send a wakeup for the first signal in each round.
			if(mask == 0)
 100b647:	83 7c 24 20 00       	cmpl   $0x0,0x20(%rsp)
 100b64c:	75 c4                	jne    100b612 <runtime.sigsend+0x45>
				runtime·notewakeup(&sig);
 100b64e:	b8 18 4f 02 01       	mov    $0x1024f18,%eax
 100b653:	48 89 04 24          	mov    %rax,(%rsp)
 100b657:	e8 97 18 00 00       	callq  100cef3 <runtime.notewakeup>
 100b65c:	eb b4                	jmp    100b612 <runtime.sigsend+0x45>

000000000100b65e <runtime.printslice>:
out:
	FLUSH(&ret);
}

void
runtime·printslice(Slice a)
 100b65e:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b665:	ff ff 
 100b667:	48 3b 21             	cmp    (%rcx),%rsp
 100b66a:	77 05                	ja     100b671 <runtime.printslice+0x13>
 100b66c:	e8 e4 62 ff ff       	callq  1001955 <runtime.morestack16>
 100b671:	48 83 ec 10          	sub    $0x10,%rsp
{
	runtime·prints("[");
 100b675:	b8 29 43 02 01       	mov    $0x1024329,%eax
 100b67a:	48 89 04 24          	mov    %rax,(%rsp)
 100b67e:	e8 6e bc ff ff       	callq  10072f1 <runtime.prints>
	runtime·printint(a.len);
 100b683:	8b 44 24 20          	mov    0x20(%rsp),%eax
 100b687:	48 89 04 24          	mov    %rax,(%rsp)
 100b68b:	e8 f6 c4 ff ff       	callq  1007b86 <runtime.printint>
	runtime·prints("/");
 100b690:	b8 2b 43 02 01       	mov    $0x102432b,%eax
 100b695:	48 89 04 24          	mov    %rax,(%rsp)
 100b699:	e8 53 bc ff ff       	callq  10072f1 <runtime.prints>
	runtime·printint(a.cap);
 100b69e:	8b 44 24 24          	mov    0x24(%rsp),%eax
 100b6a2:	48 89 04 24          	mov    %rax,(%rsp)
 100b6a6:	e8 db c4 ff ff       	callq  1007b86 <runtime.printint>
	runtime·prints("]");
 100b6ab:	b8 2d 43 02 01       	mov    $0x102432d,%eax
 100b6b0:	48 89 04 24          	mov    %rax,(%rsp)
 100b6b4:	e8 38 bc ff ff       	callq  10072f1 <runtime.prints>
 100b6b9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 100b6be:	48 89 04 24          	mov    %rax,(%rsp)
 100b6c2:	e8 d7 c5 ff ff       	callq  1007c9e <runtime.printpointer>
 100b6c7:	48 83 c4 10          	add    $0x10,%rsp
 100b6cb:	c3                   	retq   

000000000100b6cc <runtime.findnull>:
#include "malloc.h"

String	runtime·emptystring;

int32
runtime·findnull(byte *s)
 100b6cc:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b6d3:	ff ff 
 100b6d5:	48 3b 21             	cmp    (%rcx),%rsp
 100b6d8:	77 05                	ja     100b6df <runtime.findnull+0x13>
 100b6da:	e8 6d 62 ff ff       	callq  100194c <runtime.morestack8>
 100b6df:	48 83 ec 10          	sub    $0x10,%rsp
 100b6e3:	48 8b 6c 24 18       	mov    0x18(%rsp),%rbp
{
	int32 l;

	if(s == nil)
 100b6e8:	48 83 fd 00          	cmp    $0x0,%rbp
 100b6ec:	75 07                	jne    100b6f5 <runtime.findnull+0x29>
		return 0;
 100b6ee:	31 c0                	xor    %eax,%eax
 100b6f0:	48 83 c4 10          	add    $0x10,%rsp
 100b6f4:	c3                   	retq   
	for(l=0; s[l]!=0; l++)
 100b6f5:	31 db                	xor    %ebx,%ebx
 100b6f7:	48 63 cb             	movslq %ebx,%rcx
 100b6fa:	48 89 ea             	mov    %rbp,%rdx
 100b6fd:	0f b6 04 0a          	movzbl (%rdx,%rcx,1),%eax
 100b701:	83 f8 00             	cmp    $0x0,%eax
 100b704:	74 04                	je     100b70a <runtime.findnull+0x3e>
 100b706:	ff c3                	inc    %ebx
 100b708:	eb ed                	jmp    100b6f7 <runtime.findnull+0x2b>
		;
	return l;
 100b70a:	89 d8                	mov    %ebx,%eax
 100b70c:	48 83 c4 10          	add    $0x10,%rsp
 100b710:	c3                   	retq   

000000000100b711 <runtime.gostringsize>:
}

uint32 runtime·maxstring = 256;

String
runtime·gostringsize(int32 l)
 100b711:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b718:	ff ff 
 100b71a:	48 3b 21             	cmp    (%rcx),%rsp
 100b71d:	77 05                	ja     100b724 <runtime.gostringsize+0x13>
 100b71f:	e8 31 62 ff ff       	callq  1001955 <runtime.morestack16>
 100b724:	48 83 ec 38          	sub    $0x38,%rsp
 100b728:	8b 54 24 48          	mov    0x48(%rsp),%edx
{
	String s;
	uint32 ms;

	if(l == 0)
 100b72c:	83 fa 00             	cmp    $0x0,%edx
 100b72f:	75 20                	jne    100b751 <runtime.gostringsize+0x40>
		return runtime·emptystring;
 100b731:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 100b736:	48 8d 14 25 08 4f 02 	lea    0x1024f08,%rdx
 100b73d:	01 
 100b73e:	48 8b 02             	mov    (%rdx),%rax
 100b741:	48 89 01             	mov    %rax,(%rcx)
 100b744:	48 8b 42 08          	mov    0x8(%rdx),%rax
 100b748:	48 89 41 08          	mov    %rax,0x8(%rcx)
 100b74c:	48 83 c4 38          	add    $0x38,%rsp
 100b750:	c3                   	retq   
	s.str = runtime·mal(l+1);	// leave room for NUL for C runtime (e.g., callers of getenv)
 100b751:	89 d1                	mov    %edx,%ecx
 100b753:	ff c1                	inc    %ecx
 100b755:	48 63 c9             	movslq %ecx,%rcx
 100b758:	48 89 0c 24          	mov    %rcx,(%rsp)
 100b75c:	e8 cf 79 ff ff       	callq  1003130 <runtime.mal>
 100b761:	8b 5c 24 48          	mov    0x48(%rsp),%ebx
 100b765:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	s.len = l;
 100b76a:	89 5c 24 30          	mov    %ebx,0x30(%rsp)
	for(;;) {
		ms = runtime·maxstring;
 100b76e:	8b 14 25 0c 30 02 01 	mov    0x102300c,%edx
		if((uint32)l <= ms || runtime·cas(&runtime·maxstring, ms, (uint32)l))
 100b775:	39 d3                	cmp    %edx,%ebx
 100b777:	76 1f                	jbe    100b798 <runtime.gostringsize+0x87>
 100b779:	b9 0c 30 02 01       	mov    $0x102300c,%ecx
 100b77e:	48 89 0c 24          	mov    %rcx,(%rsp)
 100b782:	89 54 24 08          	mov    %edx,0x8(%rsp)
 100b786:	89 5c 24 0c          	mov    %ebx,0xc(%rsp)
 100b78a:	e8 0c 62 ff ff       	callq  100199b <runtime.cas>
 100b78f:	8b 5c 24 48          	mov    0x48(%rsp),%ebx
 100b793:	80 f8 00             	cmp    $0x0,%al
 100b796:	74 d6                	je     100b76e <runtime.gostringsize+0x5d>
			break;
	}
	return s;
 100b798:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 100b79d:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100b7a2:	48 89 01             	mov    %rax,(%rcx)
 100b7a5:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100b7aa:	48 89 41 08          	mov    %rax,0x8(%rcx)
 100b7ae:	48 83 c4 38          	add    $0x38,%rsp
 100b7b2:	c3                   	retq   

000000000100b7b3 <runtime.gostring>:
}

String
runtime·gostring(byte *str)
 100b7b3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b7ba:	ff ff 
 100b7bc:	48 3b 21             	cmp    (%rcx),%rsp
 100b7bf:	77 05                	ja     100b7c6 <runtime.gostring+0x13>
 100b7c1:	e8 8f 61 ff ff       	callq  1001955 <runtime.morestack16>
 100b7c6:	48 83 ec 40          	sub    $0x40,%rsp
{
	int32 l;
	String s;

	l = runtime·findnull(str);
 100b7ca:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
 100b7cf:	48 89 0c 24          	mov    %rcx,(%rsp)
 100b7d3:	e8 f4 fe ff ff       	callq  100b6cc <runtime.findnull>
 100b7d8:	89 c1                	mov    %eax,%ecx
	s = runtime·gostringsize(l);
 100b7da:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100b7df:	48 89 04 24          	mov    %rax,(%rsp)
 100b7e3:	89 4c 24 3c          	mov    %ecx,0x3c(%rsp)
 100b7e7:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 100b7eb:	e8 21 ff ff ff       	callq  100b711 <runtime.gostringsize>
	runtime·memmove(s.str, str, l);
 100b7f0:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100b7f5:	48 89 04 24          	mov    %rax,(%rsp)
 100b7f9:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 100b7fe:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b803:	8b 44 24 3c          	mov    0x3c(%rsp),%eax
 100b807:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100b80b:	e8 c2 86 ff ff       	callq  1003ed2 <runtime.memmove>
	return s;
 100b810:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 100b815:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100b81a:	48 89 01             	mov    %rax,(%rcx)
 100b81d:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100b822:	48 89 41 08          	mov    %rax,0x8(%rcx)
 100b826:	48 83 c4 40          	add    $0x40,%rsp
 100b82a:	c3                   	retq   

000000000100b82b <runtime.gostringnocopy>:
	runtime·memmove(sl.array, p, n);
	return sl;
}

String
runtime·gostringnocopy(byte *str)
 100b82b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b832:	ff ff 
 100b834:	48 3b 21             	cmp    (%rcx),%rsp
 100b837:	77 05                	ja     100b83e <runtime.gostringnocopy+0x13>
 100b839:	e8 17 61 ff ff       	callq  1001955 <runtime.morestack16>
 100b83e:	48 83 ec 28          	sub    $0x28,%rsp
 100b842:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
{
	String s;
	
	s.str = str;
 100b847:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
	s.len = runtime·findnull(str);
 100b84c:	48 89 14 24          	mov    %rdx,(%rsp)
 100b850:	e8 77 fe ff ff       	callq  100b6cc <runtime.findnull>
 100b855:	89 44 24 20          	mov    %eax,0x20(%rsp)
	return s;
 100b859:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 100b85e:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 100b863:	48 89 01             	mov    %rax,(%rcx)
 100b866:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100b86b:	48 89 41 08          	mov    %rax,0x8(%rcx)
 100b86f:	48 83 c4 28          	add    $0x28,%rsp
 100b873:	c3                   	retq   

000000000100b874 <runtime.catstring>:
	s.len = n;
	return s;
}

String
runtime·catstring(String s1, String s2)
 100b874:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b87b:	ff ff 
 100b87d:	48 3b 21             	cmp    (%rcx),%rsp
 100b880:	77 05                	ja     100b887 <runtime.catstring+0x13>
 100b882:	e8 e9 60 ff ff       	callq  1001970 <runtime.morestack40>
 100b887:	48 83 ec 38          	sub    $0x38,%rsp
{
	String s3;

	if(s1.len == 0)
 100b88b:	83 7c 24 50 00       	cmpl   $0x0,0x50(%rsp)
 100b890:	75 1b                	jne    100b8ad <runtime.catstring+0x39>
		return s2;
 100b892:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 100b897:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 100b89c:	48 89 01             	mov    %rax,(%rcx)
 100b89f:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 100b8a4:	48 89 41 08          	mov    %rax,0x8(%rcx)
 100b8a8:	48 83 c4 38          	add    $0x38,%rsp
 100b8ac:	c3                   	retq   
	if(s2.len == 0)
 100b8ad:	83 7c 24 60 00       	cmpl   $0x0,0x60(%rsp)
 100b8b2:	75 1b                	jne    100b8cf <runtime.catstring+0x5b>
		return s1;
 100b8b4:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 100b8b9:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 100b8be:	48 89 01             	mov    %rax,(%rcx)
 100b8c1:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 100b8c6:	48 89 41 08          	mov    %rax,0x8(%rcx)
 100b8ca:	48 83 c4 38          	add    $0x38,%rsp
 100b8ce:	c3                   	retq   

	s3 = runtime·gostringsize(s1.len + s2.len);
 100b8cf:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100b8d4:	48 89 04 24          	mov    %rax,(%rsp)
 100b8d8:	8b 44 24 50          	mov    0x50(%rsp),%eax
 100b8dc:	03 44 24 60          	add    0x60(%rsp),%eax
 100b8e0:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100b8e4:	e8 28 fe ff ff       	callq  100b711 <runtime.gostringsize>
	runtime·memmove(s3.str, s1.str, s1.len);
 100b8e9:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100b8ee:	48 89 04 24          	mov    %rax,(%rsp)
 100b8f2:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 100b8f7:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b8fc:	8b 44 24 50          	mov    0x50(%rsp),%eax
 100b900:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100b904:	e8 c9 85 ff ff       	callq  1003ed2 <runtime.memmove>
	runtime·memmove(s3.str+s1.len, s2.str, s2.len);
 100b909:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
 100b90d:	48 63 c9             	movslq %ecx,%rcx
 100b910:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 100b915:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100b919:	48 89 04 24          	mov    %rax,(%rsp)
 100b91d:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
 100b922:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100b927:	8b 44 24 60          	mov    0x60(%rsp),%eax
 100b92b:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100b92f:	e8 9e 85 ff ff       	callq  1003ed2 <runtime.memmove>
	return s3;
 100b934:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
 100b939:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100b93e:	48 89 01             	mov    %rax,(%rcx)
 100b941:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100b946:	48 89 41 08          	mov    %rax,0x8(%rcx)
 100b94a:	48 83 c4 38          	add    $0x38,%rsp
 100b94e:	c3                   	retq   

000000000100b94f <concatstring>:
}

static String
concatstring(int32 n, String *s)
 100b94f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100b956:	ff ff 
 100b958:	48 3b 21             	cmp    (%rcx),%rsp
 100b95b:	77 05                	ja     100b962 <concatstring+0x13>
 100b95d:	e8 fc 5f ff ff       	callq  100195e <runtime.morestack24>
 100b962:	48 83 ec 40          	sub    $0x40,%rsp
 100b966:	48 8b 74 24 58       	mov    0x58(%rsp),%rsi
{
	int32 i, l;
	String out;

	l = 0;
 100b96b:	31 ed                	xor    %ebp,%ebp
	for(i=0; i<n; i++) {
 100b96d:	31 db                	xor    %ebx,%ebx
 100b96f:	3b 5c 24 50          	cmp    0x50(%rsp),%ebx
 100b973:	7d 51                	jge    100b9c6 <concatstring+0x77>
		if(l + s[i].len < l)
 100b975:	89 5c 24 3c          	mov    %ebx,0x3c(%rsp)
 100b979:	48 63 cb             	movslq %ebx,%rcx
 100b97c:	48 c1 e1 04          	shl    $0x4,%rcx
 100b980:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
 100b984:	8b 40 08             	mov    0x8(%rax),%eax
 100b987:	89 e9                	mov    %ebp,%ecx
 100b989:	01 c1                	add    %eax,%ecx
 100b98b:	39 e9                	cmp    %ebp,%ecx
 100b98d:	89 6c 24 38          	mov    %ebp,0x38(%rsp)
 100b991:	7d 1b                	jge    100b9ae <concatstring+0x5f>
			runtime·throw("string concatenation too long");
 100b993:	b8 90 30 02 01       	mov    $0x1023090,%eax
 100b998:	48 89 04 24          	mov    %rax,(%rsp)
 100b99c:	e8 98 e3 ff ff       	callq  1009d39 <runtime.throw>
 100b9a1:	48 8b 74 24 58       	mov    0x58(%rsp),%rsi
 100b9a6:	8b 6c 24 38          	mov    0x38(%rsp),%ebp
 100b9aa:	8b 5c 24 3c          	mov    0x3c(%rsp),%ebx
		l += s[i].len;
 100b9ae:	48 63 cb             	movslq %ebx,%rcx
 100b9b1:	48 c1 e1 04          	shl    $0x4,%rcx
 100b9b5:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
 100b9b9:	8b 40 08             	mov    0x8(%rax),%eax
 100b9bc:	01 c5                	add    %eax,%ebp
{
	int32 i, l;
	String out;

	l = 0;
	for(i=0; i<n; i++) {
 100b9be:	ff c3                	inc    %ebx
 100b9c0:	3b 5c 24 50          	cmp    0x50(%rsp),%ebx
 100b9c4:	7c af                	jl     100b975 <concatstring+0x26>
		if(l + s[i].len < l)
			runtime·throw("string concatenation too long");
		l += s[i].len;
	}
	
	out = runtime·gostringsize(l);
 100b9c6:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100b9cb:	48 89 04 24          	mov    %rax,(%rsp)
 100b9cf:	89 6c 24 08          	mov    %ebp,0x8(%rsp)
 100b9d3:	e8 39 fd ff ff       	callq  100b711 <runtime.gostringsize>
 100b9d8:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
	l = 0;
 100b9dd:	31 f6                	xor    %esi,%esi
	for(i=0; i<n; i++) {
 100b9df:	31 db                	xor    %ebx,%ebx
 100b9e1:	3b 5c 24 50          	cmp    0x50(%rsp),%ebx
 100b9e5:	7d 6d                	jge    100ba54 <concatstring+0x105>
		runtime·memmove(out.str+l, s[i].str, s[i].len);
 100b9e7:	89 74 24 38          	mov    %esi,0x38(%rsp)
 100b9eb:	48 63 ce             	movslq %esi,%rcx
 100b9ee:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
 100b9f3:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100b9f7:	48 89 04 24          	mov    %rax,(%rsp)
 100b9fb:	48 63 cb             	movslq %ebx,%rcx
 100b9fe:	48 c1 e1 04          	shl    $0x4,%rcx
 100ba02:	48 89 ea             	mov    %rbp,%rdx
 100ba05:	48 8b 04 0a          	mov    (%rdx,%rcx,1),%rax
 100ba09:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100ba0e:	89 5c 24 3c          	mov    %ebx,0x3c(%rsp)
 100ba12:	48 63 cb             	movslq %ebx,%rcx
 100ba15:	48 c1 e1 04          	shl    $0x4,%rcx
 100ba19:	48 89 ea             	mov    %rbp,%rdx
 100ba1c:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100ba20:	8b 40 08             	mov    0x8(%rax),%eax
 100ba23:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100ba27:	e8 a6 84 ff ff       	callq  1003ed2 <runtime.memmove>
 100ba2c:	8b 74 24 38          	mov    0x38(%rsp),%esi
 100ba30:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 100ba35:	8b 5c 24 3c          	mov    0x3c(%rsp),%ebx
		l += s[i].len;
 100ba39:	48 63 cb             	movslq %ebx,%rcx
 100ba3c:	48 c1 e1 04          	shl    $0x4,%rcx
 100ba40:	48 89 ea             	mov    %rbp,%rdx
 100ba43:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100ba47:	8b 40 08             	mov    0x8(%rax),%eax
 100ba4a:	01 c6                	add    %eax,%esi
		l += s[i].len;
	}
	
	out = runtime·gostringsize(l);
	l = 0;
	for(i=0; i<n; i++) {
 100ba4c:	ff c3                	inc    %ebx
 100ba4e:	3b 5c 24 50          	cmp    0x50(%rsp),%ebx
 100ba52:	7c 93                	jl     100b9e7 <concatstring+0x98>
		runtime·memmove(out.str+l, s[i].str, s[i].len);
		l += s[i].len;
	}
	return out;
 100ba54:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 100ba59:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100ba5e:	48 89 01             	mov    %rax,(%rcx)
 100ba61:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100ba66:	48 89 41 08          	mov    %rax,0x8(%rcx)
 100ba6a:	48 83 c4 40          	add    $0x40,%rsp
 100ba6e:	c3                   	retq   

000000000100ba6f <runtime.concatstring>:
}

#pragma textflag 7
// s1 is the first of n strings.
// the output string follows.
 100ba6f:	48 83 ec 20          	sub    $0x20,%rsp
 100ba73:	8b 54 24 28          	mov    0x28(%rsp),%edx
func concatstring(n int32, s1 String) {
	(&s1)[n] = concatstring(n, &s1);
 100ba77:	48 63 ca             	movslq %edx,%rcx
 100ba7a:	48 c1 e1 04          	shl    $0x4,%rcx
 100ba7e:	48 8d 44 0c 30       	lea    0x30(%rsp,%rcx,1),%rax
 100ba83:	48 89 04 24          	mov    %rax,(%rsp)
 100ba87:	89 54 24 08          	mov    %edx,0x8(%rsp)
 100ba8b:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
 100ba90:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100ba95:	e8 b5 fe ff ff       	callq  100b94f <concatstring>
 100ba9a:	48 83 c4 20          	add    $0x20,%rsp
 100ba9e:	c3                   	retq   

000000000100ba9f <runtime.strcmp>:
func cmpstring(s1 String, s2 String) (v int32) {
	v = cmpstring(s1, s2);
}

int32
runtime·strcmp(byte *s1, byte *s2)
 100ba9f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100baa6:	ff ff 
 100baa8:	48 3b 21             	cmp    (%rcx),%rsp
 100baab:	77 05                	ja     100bab2 <runtime.strcmp+0x13>
 100baad:	e8 a3 5e ff ff       	callq  1001955 <runtime.morestack16>
 100bab2:	48 83 ec 10          	sub    $0x10,%rsp
 100bab6:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
 100babb:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
{
	uint32 i;
	byte c1, c2;

	for(i=0;; i++) {
 100bac0:	31 ed                	xor    %ebp,%ebp
		c1 = s1[i];
 100bac2:	0f b6 04 2f          	movzbl (%rdi,%rbp,1),%eax
 100bac6:	88 c3                	mov    %al,%bl
		c2 = s2[i];
 100bac8:	89 e9                	mov    %ebp,%ecx
 100baca:	0f b6 04 2e          	movzbl (%rsi,%rbp,1),%eax
 100bace:	88 c1                	mov    %al,%cl
		if(c1 < c2)
 100bad0:	0f b6 c3             	movzbl %bl,%eax
 100bad3:	38 c8                	cmp    %cl,%al
 100bad5:	73 0a                	jae    100bae1 <runtime.strcmp+0x42>
			return -1;
 100bad7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 100badc:	48 83 c4 10          	add    $0x10,%rsp
 100bae0:	c3                   	retq   
		if(c1 > c2)
 100bae1:	0f b6 c3             	movzbl %bl,%eax
 100bae4:	38 c8                	cmp    %cl,%al
 100bae6:	76 0a                	jbe    100baf2 <runtime.strcmp+0x53>
			return +1;
 100bae8:	b8 01 00 00 00       	mov    $0x1,%eax
 100baed:	48 83 c4 10          	add    $0x10,%rsp
 100baf1:	c3                   	retq   
		if(c1 == 0)
 100baf2:	0f b6 c3             	movzbl %bl,%eax
 100baf5:	83 f8 00             	cmp    $0x0,%eax
 100baf8:	75 07                	jne    100bb01 <runtime.strcmp+0x62>
			return 0;
 100bafa:	31 c0                	xor    %eax,%eax
 100bafc:	48 83 c4 10          	add    $0x10,%rsp
 100bb00:	c3                   	retq   
runtime·strcmp(byte *s1, byte *s2)
{
	uint32 i;
	byte c1, c2;

	for(i=0;; i++) {
 100bb01:	ff c5                	inc    %ebp
		c1 = s1[i];
 100bb03:	eb bd                	jmp    100bac2 <runtime.strcmp+0x23>

000000000100bb05 <runtime.strstr>:
			return 0;
	}
}

byte*
runtime·strstr(byte *s1, byte *s2)
 100bb05:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100bb0c:	ff ff 
 100bb0e:	48 3b 21             	cmp    (%rcx),%rsp
 100bb11:	77 05                	ja     100bb18 <runtime.strstr+0x13>
 100bb13:	e8 3d 5e ff ff       	callq  1001955 <runtime.morestack16>
 100bb18:	48 83 ec 18          	sub    $0x18,%rsp
 100bb1c:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
 100bb21:	48 8b 6c 24 20       	mov    0x20(%rsp),%rbp
{
	byte *sp1, *sp2;

	if(*s2 == 0)
 100bb26:	0f b6 06             	movzbl (%rsi),%eax
 100bb29:	83 f8 00             	cmp    $0x0,%eax
 100bb2c:	75 08                	jne    100bb36 <runtime.strstr+0x31>
		return s1;
 100bb2e:	48 89 e8             	mov    %rbp,%rax
 100bb31:	48 83 c4 18          	add    $0x18,%rsp
 100bb35:	c3                   	retq   
	for(; *s1; s1++) {
 100bb36:	0f b6 45 00          	movzbl 0x0(%rbp),%eax
 100bb3a:	80 f8 00             	cmp    $0x0,%al
 100bb3d:	74 17                	je     100bb56 <runtime.strstr+0x51>
		if(*s1 != *s2)
 100bb3f:	0f b6 45 00          	movzbl 0x0(%rbp),%eax
 100bb43:	0f b6 0e             	movzbl (%rsi),%ecx
 100bb46:	38 c8                	cmp    %cl,%al
 100bb48:	74 14                	je     100bb5e <runtime.strstr+0x59>
{
	byte *sp1, *sp2;

	if(*s2 == 0)
		return s1;
	for(; *s1; s1++) {
 100bb4a:	48 ff c5             	inc    %rbp
 100bb4d:	0f b6 45 00          	movzbl 0x0(%rbp),%eax
 100bb51:	80 f8 00             	cmp    $0x0,%al
 100bb54:	75 e9                	jne    100bb3f <runtime.strstr+0x3a>
				return s1;
			if(*sp1++ != *sp2++)
				break;
		}
	}
	return nil;
 100bb56:	48 31 c0             	xor    %rax,%rax
 100bb59:	48 83 c4 18          	add    $0x18,%rsp
 100bb5d:	c3                   	retq   
	if(*s2 == 0)
		return s1;
	for(; *s1; s1++) {
		if(*s1 != *s2)
			continue;
		sp1 = s1;
 100bb5e:	48 89 eb             	mov    %rbp,%rbx
		sp2 = s2;
 100bb61:	48 89 f2             	mov    %rsi,%rdx
		for(;;) {
			if(*sp2 == 0)
 100bb64:	0f b6 02             	movzbl (%rdx),%eax
 100bb67:	83 f8 00             	cmp    $0x0,%eax
 100bb6a:	75 08                	jne    100bb74 <runtime.strstr+0x6f>
				return s1;
 100bb6c:	48 89 e8             	mov    %rbp,%rax
 100bb6f:	48 83 c4 18          	add    $0x18,%rsp
 100bb73:	c3                   	retq   
			if(*sp1++ != *sp2++)
 100bb74:	48 89 d8             	mov    %rbx,%rax
 100bb77:	48 ff c3             	inc    %rbx
 100bb7a:	0f b6 00             	movzbl (%rax),%eax
 100bb7d:	48 89 d1             	mov    %rdx,%rcx
 100bb80:	48 ff c2             	inc    %rdx
 100bb83:	0f b6 09             	movzbl (%rcx),%ecx
 100bb86:	38 c8                	cmp    %cl,%al
 100bb88:	75 c0                	jne    100bb4a <runtime.strstr+0x45>
 100bb8a:	eb d8                	jmp    100bb64 <runtime.strstr+0x5f>

000000000100bb8c <walksymtab>:
//	byte *gotype;
};

// Walk over symtab, calling fn(&s) for each symbol.
static void
walksymtab(void (*fn)(Sym*))
 100bb8c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100bb93:	ff ff 
 100bb95:	48 3b 21             	cmp    (%rcx),%rsp
 100bb98:	77 05                	ja     100bb9f <walksymtab+0x13>
 100bb9a:	e8 ad 5d ff ff       	callq  100194c <runtime.morestack8>
 100bb9f:	48 83 ec 58          	sub    $0x58,%rsp
{
	byte *p, *ep, *q;
	Sym s;

	p = symtab;
 100bba3:	ba a8 69 01 01       	mov    $0x10169a8,%edx
	ep = esymtab;
 100bba8:	bb ff 0b 02 01       	mov    $0x1020bff,%ebx
	while(p < ep) {
 100bbad:	48 39 da             	cmp    %rbx,%rdx
 100bbb0:	73 0c                	jae    100bbbe <walksymtab+0x32>
		if(p + 7 > ep)
 100bbb2:	48 89 d0             	mov    %rdx,%rax
 100bbb5:	48 83 c0 07          	add    $0x7,%rax
 100bbb9:	48 39 d8             	cmp    %rbx,%rax
 100bbbc:	76 05                	jbe    100bbc3 <walksymtab+0x37>
			if(q == nil)
				break;
			p = q+1;
		}
		p += 4;	// go type
		fn(&s);
 100bbbe:	48 83 c4 58          	add    $0x58,%rsp
 100bbc2:	c3                   	retq   
	p = symtab;
	ep = esymtab;
	while(p < ep) {
		if(p + 7 > ep)
			break;
		s.value = ((uint32)p[0]<<24) | ((uint32)p[1]<<16) | ((uint32)p[2]<<8) | ((uint32)p[3]);
 100bbc3:	0f b6 02             	movzbl (%rdx),%eax
 100bbc6:	c1 e0 18             	shl    $0x18,%eax
 100bbc9:	0f b6 4a 01          	movzbl 0x1(%rdx),%ecx
 100bbcd:	c1 e1 10             	shl    $0x10,%ecx
 100bbd0:	09 c8                	or     %ecx,%eax
 100bbd2:	0f b6 4a 02          	movzbl 0x2(%rdx),%ecx
 100bbd6:	c1 e1 08             	shl    $0x8,%ecx
 100bbd9:	09 c8                	or     %ecx,%eax
 100bbdb:	0f b6 4a 03          	movzbl 0x3(%rdx),%ecx
 100bbdf:	09 c8                	or     %ecx,%eax
 100bbe1:	48 89 44 24 28       	mov    %rax,0x28(%rsp)

		if(!(p[4]&0x80))
 100bbe6:	0f b6 42 04          	movzbl 0x4(%rdx),%eax
 100bbea:	25 80 00 00 00       	and    $0x80,%eax
 100bbef:	83 f8 00             	cmp    $0x0,%eax
 100bbf2:	74 ca                	je     100bbbe <walksymtab+0x32>
			break;
		s.symtype = p[4] & ~0x80;
 100bbf4:	0f b6 42 04          	movzbl 0x4(%rdx),%eax
 100bbf8:	25 7f ff ff ff       	and    $0xffffff7f,%eax
 100bbfd:	88 44 24 30          	mov    %al,0x30(%rsp)
		p += 5;
 100bc01:	48 83 c2 05          	add    $0x5,%rdx
		s.name = p;
 100bc05:	48 89 54 24 38       	mov    %rdx,0x38(%rsp)
		if(s.symtype == 'z' || s.symtype == 'Z') {
 100bc0a:	0f b6 44 24 30       	movzbl 0x30(%rsp),%eax
 100bc0f:	83 f8 7a             	cmp    $0x7a,%eax
 100bc12:	74 56                	je     100bc6a <walksymtab+0xde>
 100bc14:	0f b6 44 24 30       	movzbl 0x30(%rsp),%eax
 100bc19:	83 f8 5a             	cmp    $0x5a,%eax
 100bc1c:	74 4c                	je     100bc6a <walksymtab+0xde>
					break;
				q += 2;
			}
			p = q+2;
		}else{
			q = runtime·mchr(p, '\0', ep);
 100bc1e:	48 89 14 24          	mov    %rdx,(%rsp)
 100bc22:	c6 44 24 08 00       	movb   $0x0,0x8(%rsp)
 100bc27:	48 89 5c 24 48       	mov    %rbx,0x48(%rsp)
 100bc2c:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
 100bc31:	e8 76 e2 ff ff       	callq  1009eac <runtime.mchr>
			if(q == nil)
 100bc36:	48 83 f8 00          	cmp    $0x0,%rax
 100bc3a:	74 82                	je     100bbbe <walksymtab+0x32>
				break;
			p = q+1;
 100bc3c:	48 ff c0             	inc    %rax
 100bc3f:	48 89 c1             	mov    %rax,%rcx
		}
		p += 4;	// go type
 100bc42:	48 83 c1 04          	add    $0x4,%rcx
 100bc46:	48 89 4c 24 50       	mov    %rcx,0x50(%rsp)
		fn(&s);
 100bc4b:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100bc50:	48 89 04 24          	mov    %rax,(%rsp)
 100bc54:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 100bc59:	ff d0                	callq  *%rax
 100bc5b:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
 100bc60:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
	byte *p, *ep, *q;
	Sym s;

	p = symtab;
	ep = esymtab;
	while(p < ep) {
 100bc65:	e9 43 ff ff ff       	jmpq   100bbad <walksymtab+0x21>
		p += 5;
		s.name = p;
		if(s.symtype == 'z' || s.symtype == 'Z') {
			// path reference string - skip first byte,
			// then 2-byte pairs ending at two zeros.
			q = p+1;
 100bc6a:	48 89 d1             	mov    %rdx,%rcx
 100bc6d:	48 ff c1             	inc    %rcx
			for(;;) {
				if(q+2 > ep)
 100bc70:	48 89 c8             	mov    %rcx,%rax
 100bc73:	48 83 c0 02          	add    $0x2,%rax
 100bc77:	48 39 d8             	cmp    %rbx,%rax
 100bc7a:	48 89 5c 24 48       	mov    %rbx,0x48(%rsp)
 100bc7f:	76 05                	jbe    100bc86 <walksymtab+0xfa>
					return;
 100bc81:	48 83 c4 58          	add    $0x58,%rsp
 100bc85:	c3                   	retq   
				if(q[0] == '\0' && q[1] == '\0')
 100bc86:	0f b6 01             	movzbl (%rcx),%eax
 100bc89:	83 f8 00             	cmp    $0x0,%eax
 100bc8c:	75 09                	jne    100bc97 <walksymtab+0x10b>
 100bc8e:	0f b6 41 01          	movzbl 0x1(%rcx),%eax
 100bc92:	83 f8 00             	cmp    $0x0,%eax
 100bc95:	74 06                	je     100bc9d <walksymtab+0x111>
					break;
				q += 2;
 100bc97:	48 83 c1 02          	add    $0x2,%rcx
		if(s.symtype == 'z' || s.symtype == 'Z') {
			// path reference string - skip first byte,
			// then 2-byte pairs ending at two zeros.
			q = p+1;
			for(;;) {
				if(q+2 > ep)
 100bc9b:	eb d3                	jmp    100bc70 <walksymtab+0xe4>
					return;
				if(q[0] == '\0' && q[1] == '\0')
					break;
				q += 2;
			}
			p = q+2;
 100bc9d:	48 83 c1 02          	add    $0x2,%rcx
			q = runtime·mchr(p, '\0', ep);
			if(q == nil)
				break;
			p = q+1;
		}
		p += 4;	// go type
 100bca1:	eb 9f                	jmp    100bc42 <walksymtab+0xb6>

000000000100bca3 <dofunc>:

static uint32 funcinit;
static Lock funclock;

static void
dofunc(Sym *sym)
 100bca3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100bcaa:	ff ff 
 100bcac:	48 3b 21             	cmp    (%rcx),%rsp
 100bcaf:	77 05                	ja     100bcb6 <dofunc+0x13>
 100bcb1:	e8 96 5c ff ff       	callq  100194c <runtime.morestack8>
 100bcb6:	48 83 ec 28          	sub    $0x28,%rsp
 100bcba:	48 8b 34 25 78 4e 02 	mov    0x1024e78,%rsi
 100bcc1:	01 
 100bcc2:	48 8b 2c 25 80 4e 02 	mov    0x1024e80,%rbp
 100bcc9:	01 
 100bcca:	8b 14 25 00 4e 02 01 	mov    0x1024e00,%edx
 100bcd1:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
				nfname = sym->value+1;
			}
			break;
		}
		fname[sym->value] = sym->name;
		break;
 100bcd6:	0f b6 43 08          	movzbl 0x8(%rbx),%eax
 100bcda:	83 f8 6c             	cmp    $0x6c,%eax
 100bcdd:	0f 8f 22 01 00 00    	jg     100be05 <dofunc+0x162>
 100bce3:	74 7f                	je     100bd64 <dofunc+0xc1>
 100bce5:	83 f8 4c             	cmp    $0x4c,%eax
 100bce8:	74 7a                	je     100bd64 <dofunc+0xc1>
 100bcea:	83 f8 54             	cmp    $0x54,%eax
 100bced:	74 75                	je     100bd64 <dofunc+0xc1>
 100bcef:	83 f8 66             	cmp    $0x66,%eax
 100bcf2:	74 05                	je     100bcf9 <dofunc+0x56>
 100bcf4:	48 83 c4 28          	add    $0x28,%rsp
 100bcf8:	c3                   	retq   
			if(f->args < sym->value/4 + 2)
				f->args = sym->value/4 + 2;
		}
		break;
	case 'f':
		if(fname == nil) {
 100bcf9:	48 83 fe 00          	cmp    $0x0,%rsi
 100bcfd:	75 58                	jne    100bd57 <dofunc+0xb4>
			if(sym->value >= nfname) {
 100bcff:	48 8b 03             	mov    (%rbx),%rax
 100bd02:	8b 0c 25 fc 4d 02 01 	mov    0x1024dfc,%ecx
 100bd09:	48 63 c9             	movslq %ecx,%rcx
 100bd0c:	48 39 c8             	cmp    %rcx,%rax
 100bd0f:	72 e3                	jb     100bcf4 <dofunc+0x51>
				if(sym->value >= 0x10000) {
 100bd11:	48 8b 03             	mov    (%rbx),%rax
 100bd14:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
 100bd1a:	72 29                	jb     100bd45 <dofunc+0xa2>
					runtime·printf("invalid symbol file index %p\n", sym->value);
 100bd1c:	b8 06 31 02 01       	mov    $0x1023106,%eax
 100bd21:	48 89 04 24          	mov    %rax,(%rsp)
 100bd25:	48 8b 03             	mov    (%rbx),%rax
 100bd28:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100bd2d:	e8 0c b6 ff ff       	callq  100733e <runtime.printf>
					runtime·throw("mangled symbol table");
 100bd32:	b8 24 31 02 01       	mov    $0x1023124,%eax
 100bd37:	48 89 04 24          	mov    %rax,(%rsp)
 100bd3b:	e8 f9 df ff ff       	callq  1009d39 <runtime.throw>
 100bd40:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
				}
				nfname = sym->value+1;
 100bd45:	48 8b 03             	mov    (%rbx),%rax
 100bd48:	48 ff c0             	inc    %rax
 100bd4b:	48 63 c0             	movslq %eax,%rax
 100bd4e:	89 04 25 fc 4d 02 01 	mov    %eax,0x1024dfc
			}
			break;
		}
		fname[sym->value] = sym->name;
		break;
 100bd55:	eb 9d                	jmp    100bcf4 <dofunc+0x51>
				}
				nfname = sym->value+1;
			}
			break;
		}
		fname[sym->value] = sym->name;
 100bd57:	48 8b 43 10          	mov    0x10(%rbx),%rax
 100bd5b:	48 8b 0b             	mov    (%rbx),%rcx
 100bd5e:	48 89 04 ce          	mov    %rax,(%rsi,%rcx,8)
		break;
 100bd62:	eb 90                	jmp    100bcf4 <dofunc+0x51>
	switch(sym->symtype) {
	case 't':
	case 'T':
	case 'l':
	case 'L':
		if(runtime·strcmp(sym->name, (byte*)"etext") == 0)
 100bd64:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
 100bd68:	48 89 0c 24          	mov    %rcx,(%rsp)
 100bd6c:	b9 00 31 02 01       	mov    $0x1023100,%ecx
 100bd71:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100bd76:	e8 24 fd ff ff       	callq  100ba9f <runtime.strcmp>
 100bd7b:	48 8b 0c 25 80 4e 02 	mov    0x1024e80,%rcx
 100bd82:	01 
 100bd83:	83 f8 00             	cmp    $0x0,%eax
 100bd86:	0f 84 68 ff ff ff    	je     100bcf4 <dofunc+0x51>
			break;
		if(func == nil) {
 100bd8c:	48 83 f9 00          	cmp    $0x0,%rcx
 100bd90:	75 0c                	jne    100bd9e <dofunc+0xfb>
			nfunc++;
 100bd92:	ff 04 25 00 4e 02 01 	incl   0x1024e00
				nfname = sym->value+1;
			}
			break;
		}
		fname[sym->value] = sym->name;
		break;
 100bd99:	e9 56 ff ff ff       	jmpq   100bcf4 <dofunc+0x51>
			break;
		if(func == nil) {
			nfunc++;
			break;
		}
		f = &func[nfunc++];
 100bd9e:	8b 04 25 00 4e 02 01 	mov    0x1024e00,%eax
 100bda5:	ff 04 25 00 4e 02 01 	incl   0x1024e00
 100bdac:	48 63 c0             	movslq %eax,%rax
 100bdaf:	48 6b c0 60          	imul   $0x60,%rax,%rax
 100bdb3:	48 01 c8             	add    %rcx,%rax
		f->name = runtime·gostringnocopy(sym->name);
 100bdb6:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
 100bdbb:	48 89 04 24          	mov    %rax,(%rsp)
 100bdbf:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100bdc4:	48 8b 40 10          	mov    0x10(%rax),%rax
 100bdc8:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100bdcd:	e8 59 fa ff ff       	callq  100b82b <runtime.gostringnocopy>
 100bdd2:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
 100bdd7:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
		f->entry = sym->value;
 100bddc:	48 8b 0a             	mov    (%rdx),%rcx
 100bddf:	48 89 4b 40          	mov    %rcx,0x40(%rbx)
		if(sym->symtype == 'L' || sym->symtype == 'l')
 100bde3:	0f b6 42 08          	movzbl 0x8(%rdx),%eax
 100bde7:	83 f8 4c             	cmp    $0x4c,%eax
 100bdea:	74 0d                	je     100bdf9 <dofunc+0x156>
 100bdec:	0f b6 42 08          	movzbl 0x8(%rdx),%eax
 100bdf0:	83 f8 6c             	cmp    $0x6c,%eax
 100bdf3:	0f 85 fb fe ff ff    	jne    100bcf4 <dofunc+0x51>
			f->frame = -sizeof(uintptr);
 100bdf9:	c7 43 54 f8 ff ff ff 	movl   $0xfffffff8,0x54(%rbx)
				nfname = sym->value+1;
			}
			break;
		}
		fname[sym->value] = sym->name;
		break;
 100be00:	e9 ef fe ff ff       	jmpq   100bcf4 <dofunc+0x51>
 100be05:	83 f8 6d             	cmp    $0x6d,%eax
 100be08:	74 6b                	je     100be75 <dofunc+0x1d2>
 100be0a:	83 f8 70             	cmp    $0x70,%eax
 100be0d:	74 0e                	je     100be1d <dofunc+0x17a>
 100be0f:	83 f8 74             	cmp    $0x74,%eax
 100be12:	0f 85 dc fe ff ff    	jne    100bcf4 <dofunc+0x51>
	switch(sym->symtype) {
	case 't':
	case 'T':
	case 'l':
	case 'L':
		if(runtime·strcmp(sym->name, (byte*)"etext") == 0)
 100be18:	e9 47 ff ff ff       	jmpq   100bd64 <dofunc+0xc1>
	case 'm':
		if(nfunc > 0 && func != nil)
			func[nfunc-1].frame += sym->value;
		break;
	case 'p':
		if(nfunc > 0 && func != nil) {
 100be1d:	83 fa 00             	cmp    $0x0,%edx
 100be20:	0f 8e ce fe ff ff    	jle    100bcf4 <dofunc+0x51>
 100be26:	48 83 fd 00          	cmp    $0x0,%rbp
 100be2a:	0f 84 c4 fe ff ff    	je     100bcf4 <dofunc+0x51>
			f = &func[nfunc-1];
 100be30:	48 63 ca             	movslq %edx,%rcx
 100be33:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100be37:	48 89 ea             	mov    %rbp,%rdx
 100be3a:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100be3e:	48 83 c0 a0          	add    $0xffffffffffffffa0,%rax
 100be42:	48 89 c2             	mov    %rax,%rdx
			// args counts 32-bit words.
			// sym->value is the arg's offset.
			// don't know width of this arg, so assume it is 64 bits.
			if(f->args < sym->value/4 + 2)
 100be45:	48 8b 03             	mov    (%rbx),%rax
 100be48:	48 c1 e8 02          	shr    $0x2,%rax
 100be4c:	48 83 c0 02          	add    $0x2,%rax
 100be50:	8b 4a 58             	mov    0x58(%rdx),%ecx
 100be53:	48 63 c9             	movslq %ecx,%rcx
 100be56:	48 39 c1             	cmp    %rax,%rcx
 100be59:	0f 83 95 fe ff ff    	jae    100bcf4 <dofunc+0x51>
				f->args = sym->value/4 + 2;
 100be5f:	48 8b 03             	mov    (%rbx),%rax
 100be62:	48 c1 e8 02          	shr    $0x2,%rax
 100be66:	48 83 c0 02          	add    $0x2,%rax
 100be6a:	48 63 c0             	movslq %eax,%rax
 100be6d:	89 42 58             	mov    %eax,0x58(%rdx)
				nfname = sym->value+1;
			}
			break;
		}
		fname[sym->value] = sym->name;
		break;
 100be70:	e9 7f fe ff ff       	jmpq   100bcf4 <dofunc+0x51>
		f->entry = sym->value;
		if(sym->symtype == 'L' || sym->symtype == 'l')
			f->frame = -sizeof(uintptr);
		break;
	case 'm':
		if(nfunc > 0 && func != nil)
 100be75:	83 fa 00             	cmp    $0x0,%edx
 100be78:	0f 8e 76 fe ff ff    	jle    100bcf4 <dofunc+0x51>
 100be7e:	48 83 fd 00          	cmp    $0x0,%rbp
 100be82:	0f 84 6c fe ff ff    	je     100bcf4 <dofunc+0x51>
			func[nfunc-1].frame += sym->value;
 100be88:	48 63 ca             	movslq %edx,%rcx
 100be8b:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100be8f:	48 89 ea             	mov    %rbp,%rdx
 100be92:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100be96:	48 8b 0b             	mov    (%rbx),%rcx
 100be99:	48 63 c9             	movslq %ecx,%rcx
 100be9c:	01 48 f4             	add    %ecx,-0xc(%rax)
				nfname = sym->value+1;
			}
			break;
		}
		fname[sym->value] = sym->name;
		break;
 100be9f:	e9 50 fe ff ff       	jmpq   100bcf4 <dofunc+0x51>

000000000100bea4 <makepath>:
}

// put together the path name for a z entry.
// the f entries have been accumulated into fname already.
static void
makepath(byte *buf, int32 nbuf, byte *path)
 100bea4:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100beab:	ff ff 
 100bead:	48 3b 21             	cmp    (%rcx),%rsp
 100beb0:	77 05                	ja     100beb7 <makepath+0x13>
 100beb2:	e8 a7 5a ff ff       	callq  100195e <runtime.morestack24>
 100beb7:	48 83 ec 48          	sub    $0x48,%rsp
 100bebb:	8b 54 24 58          	mov    0x58(%rsp),%edx
 100bebf:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
 100bec4:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
{
	int32 n, len;
	byte *p, *ep, *q;

	if(nbuf <= 0)
 100bec9:	83 fa 00             	cmp    $0x0,%edx
 100becc:	7f 05                	jg     100bed3 <makepath+0x2f>
		return;
 100bece:	48 83 c4 48          	add    $0x48,%rsp
 100bed2:	c3                   	retq   

	p = buf;
	ep = buf + nbuf;
 100bed3:	48 63 ca             	movslq %edx,%rcx
 100bed6:	48 8d 04 0e          	lea    (%rsi,%rcx,1),%rax
 100beda:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
	*p = '\0';
 100bedf:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
 100bee4:	c6 06 00             	movb   $0x0,(%rsi)
	for(;;) {
		if(path[0] == 0 && path[1] == 0)
 100bee7:	0f b6 03             	movzbl (%rbx),%eax
 100beea:	83 f8 00             	cmp    $0x0,%eax
 100beed:	75 09                	jne    100bef8 <makepath+0x54>
 100beef:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
 100bef3:	83 f8 00             	cmp    $0x0,%eax
 100bef6:	74 1e                	je     100bf16 <makepath+0x72>
			break;
		n = (path[0]<<8) | path[1];
 100bef8:	0f b6 03             	movzbl (%rbx),%eax
 100befb:	c1 e0 08             	shl    $0x8,%eax
 100befe:	0f b6 4b 01          	movzbl 0x1(%rbx),%ecx
 100bf02:	09 c8                	or     %ecx,%eax
		path += 2;
 100bf04:	48 83 c3 02          	add    $0x2,%rbx
 100bf08:	48 89 5c 24 60       	mov    %rbx,0x60(%rsp)
		if(n >= nfname)
 100bf0d:	3b 04 25 fc 4d 02 01 	cmp    0x1024dfc,%eax
 100bf14:	7c 05                	jl     100bf1b <makepath+0x77>
		if(p+1+len >= ep)
			break;
		if(p > buf && p[-1] != '/')
			*p++ = '/';
		runtime·memmove(p, q, len+1);
		p += len;
 100bf16:	48 83 c4 48          	add    $0x48,%rsp
 100bf1a:	c3                   	retq   
			break;
		n = (path[0]<<8) | path[1];
		path += 2;
		if(n >= nfname)
			break;
		q = fname[n];
 100bf1b:	48 63 c8             	movslq %eax,%rcx
 100bf1e:	48 8b 14 25 78 4e 02 	mov    0x1024e78,%rdx
 100bf25:	01 
 100bf26:	48 8b 04 ca          	mov    (%rdx,%rcx,8),%rax
		len = runtime·findnull(q);
 100bf2a:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
 100bf2f:	48 89 04 24          	mov    %rax,(%rsp)
 100bf33:	e8 94 f7 ff ff       	callq  100b6cc <runtime.findnull>
 100bf38:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
 100bf3d:	89 c5                	mov    %eax,%ebp
		if(p+1+len >= ep)
 100bf3f:	48 63 c8             	movslq %eax,%rcx
 100bf42:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
 100bf46:	48 ff c0             	inc    %rax
 100bf49:	48 3b 44 24 30       	cmp    0x30(%rsp),%rax
 100bf4e:	73 c6                	jae    100bf16 <makepath+0x72>
			break;
		if(p > buf && p[-1] != '/')
 100bf50:	48 3b 5c 24 50       	cmp    0x50(%rsp),%rbx
 100bf55:	76 09                	jbe    100bf60 <makepath+0xbc>
 100bf57:	0f b6 43 ff          	movzbl -0x1(%rbx),%eax
 100bf5b:	83 f8 2f             	cmp    $0x2f,%eax
 100bf5e:	75 3a                	jne    100bf9a <makepath+0xf6>
			*p++ = '/';
		runtime·memmove(p, q, len+1);
 100bf60:	48 89 5c 24 38       	mov    %rbx,0x38(%rsp)
 100bf65:	48 89 1c 24          	mov    %rbx,(%rsp)
 100bf69:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
 100bf6e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100bf73:	89 e8                	mov    %ebp,%eax
 100bf75:	89 6c 24 40          	mov    %ebp,0x40(%rsp)
 100bf79:	ff c0                	inc    %eax
 100bf7b:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100bf7f:	e8 4e 7f ff ff       	callq  1003ed2 <runtime.memmove>
 100bf84:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
		p += len;
 100bf89:	8b 44 24 40          	mov    0x40(%rsp),%eax
 100bf8d:	48 63 c0             	movslq %eax,%rax
 100bf90:	48 01 44 24 38       	add    %rax,0x38(%rsp)

	p = buf;
	ep = buf + nbuf;
	*p = '\0';
	for(;;) {
		if(path[0] == 0 && path[1] == 0)
 100bf95:	e9 4d ff ff ff       	jmpq   100bee7 <makepath+0x43>
		q = fname[n];
		len = runtime·findnull(q);
		if(p+1+len >= ep)
			break;
		if(p > buf && p[-1] != '/')
			*p++ = '/';
 100bf9a:	48 89 d8             	mov    %rbx,%rax
 100bf9d:	48 ff c3             	inc    %rbx
 100bfa0:	c6 00 2f             	movb   $0x2f,(%rax)
		runtime·memmove(p, q, len+1);
 100bfa3:	eb bb                	jmp    100bf60 <makepath+0xbc>

000000000100bfa5 <dosrcline>:
// walk symtab accumulating path names for use by pc/ln table.
// don't need the full generality of the z entry history stack because
// there are no includes in go (and only sensible includes in our c);
// assume code only appear in top-level files.
static void
dosrcline(Sym *sym)
 100bfa5:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100bfac:	ff ff 
 100bfae:	48 3b 21             	cmp    (%rcx),%rsp
 100bfb1:	77 05                	ja     100bfb8 <dosrcline+0x13>
 100bfb3:	e8 94 59 ff ff       	callq  100194c <runtime.morestack8>
 100bfb8:	48 83 ec 38          	sub    $0x38,%rsp
 100bfbc:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
					// this is "line 0"
					files[nfile++].delta = sym->value - 1;
				}
			}else{
				if(--nhist == 0)
					files[nfile-1].delta += sym->value - incstart;
 100bfc1:	0f b6 42 08          	movzbl 0x8(%rdx),%eax
 100bfc5:	83 f8 54             	cmp    $0x54,%eax
 100bfc8:	0f 84 dd 01 00 00    	je     100c1ab <dosrcline+0x206>
 100bfce:	83 f8 74             	cmp    $0x74,%eax
 100bfd1:	0f 84 d4 01 00 00    	je     100c1ab <dosrcline+0x206>
 100bfd7:	83 f8 7a             	cmp    $0x7a,%eax
 100bfda:	74 05                	je     100bfe1 <dosrcline+0x3c>
 100bfdc:	48 83 c4 38          	add    $0x38,%rsp
 100bfe0:	c3                   	retq   
		}
		f->src = files[i].srcstring;
		f->ln0 -= files[i].delta;
		break;
	case 'z':
		if(sym->value == 1) {
 100bfe1:	48 8b 02             	mov    (%rdx),%rax
 100bfe4:	48 83 f8 01          	cmp    $0x1,%rax
 100bfe8:	0f 85 a2 00 00 00    	jne    100c090 <dosrcline+0xeb>
			// entry for main source file for a new object.
			makepath(srcbuf, sizeof srcbuf, sym->name+1);
 100bfee:	b8 70 5e 02 01       	mov    $0x1025e70,%eax
 100bff3:	48 89 04 24          	mov    %rax,(%rsp)
 100bff7:	b8 e8 03 00 00       	mov    $0x3e8,%eax
 100bffc:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100c000:	48 8b 42 10          	mov    0x10(%rdx),%rax
 100c004:	48 ff c0             	inc    %rax
 100c007:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100c00c:	e8 93 fe ff ff       	callq  100bea4 <makepath>
			nhist = 0;
 100c011:	c7 04 25 08 4e 02 01 	movl   $0x0,0x1024e08
 100c018:	00 00 00 00 
			nfile = 0;
 100c01c:	31 d2                	xor    %edx,%edx
			if(nfile == nelem(files))
 100c01e:	81 fa c8 00 00 00    	cmp    $0xc8,%edx
 100c024:	89 14 25 f8 4d 02 01 	mov    %edx,0x1024df8
 100c02b:	75 05                	jne    100c032 <dosrcline+0x8d>
				return;
 100c02d:	48 83 c4 38          	add    $0x38,%rsp
 100c031:	c3                   	retq   
			files[nfile].srcstring = runtime·gostring(srcbuf);
 100c032:	48 63 ca             	movslq %edx,%rcx
 100c035:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 100c039:	48 8d 04 0d b8 70 02 	lea    0x10270b8(,%rcx,1),%rax
 100c040:	01 
 100c041:	48 89 04 24          	mov    %rax,(%rsp)
 100c045:	b8 70 5e 02 01       	mov    $0x1025e70,%eax
 100c04a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100c04f:	e8 5f f7 ff ff       	callq  100b7b3 <runtime.gostring>
 100c054:	8b 0c 25 f8 4d 02 01 	mov    0x1024df8,%ecx
			files[nfile].aline = 0;
 100c05b:	48 63 c1             	movslq %ecx,%rax
 100c05e:	48 6b c0 18          	imul   $0x18,%rax,%rax
 100c062:	c7 04 05 c8 70 02 01 	movl   $0x0,0x10270c8(,%rax,1)
 100c069:	00 00 00 00 
			files[nfile++].delta = 0;
 100c06d:	89 c8                	mov    %ecx,%eax
 100c06f:	ff c1                	inc    %ecx
 100c071:	89 0c 25 f8 4d 02 01 	mov    %ecx,0x1024df8
 100c078:	48 63 c0             	movslq %eax,%rax
 100c07b:	48 6b c0 18          	imul   $0x18,%rax,%rax
 100c07f:	48 05 cc 70 02 01    	add    $0x10270cc,%rax
 100c085:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
					// this is "line 0"
					files[nfile++].delta = sym->value - 1;
				}
			}else{
				if(--nhist == 0)
					files[nfile-1].delta += sym->value - incstart;
 100c08b:	e9 4c ff ff ff       	jmpq   100bfdc <dosrcline+0x37>
			files[nfile].srcstring = runtime·gostring(srcbuf);
			files[nfile].aline = 0;
			files[nfile++].delta = 0;
		} else {
			// push or pop of included file.
			makepath(srcbuf, sizeof srcbuf, sym->name+1);
 100c090:	b8 70 5e 02 01       	mov    $0x1025e70,%eax
 100c095:	48 89 04 24          	mov    %rax,(%rsp)
 100c099:	b8 e8 03 00 00       	mov    $0x3e8,%eax
 100c09e:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100c0a2:	48 8b 42 10          	mov    0x10(%rdx),%rax
 100c0a6:	48 ff c0             	inc    %rax
 100c0a9:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100c0ae:	e8 f1 fd ff ff       	callq  100bea4 <makepath>
 100c0b3:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
 100c0b8:	8b 14 25 f8 4d 02 01 	mov    0x1024df8,%edx
 100c0bf:	8b 0c 25 08 4e 02 01 	mov    0x1024e08,%ecx
			if(srcbuf[0] != '\0') {
 100c0c6:	0f b6 04 25 70 5e 02 	movzbl 0x1025e70,%eax
 100c0cd:	01 
 100c0ce:	83 f8 00             	cmp    $0x0,%eax
 100c0d1:	0f 84 9c 00 00 00    	je     100c173 <dosrcline+0x1ce>
				if(nhist++ == 0)
 100c0d7:	89 c8                	mov    %ecx,%eax
 100c0d9:	ff c1                	inc    %ecx
 100c0db:	83 f8 00             	cmp    $0x0,%eax
 100c0de:	75 0d                	jne    100c0ed <dosrcline+0x148>
					incstart = sym->value;
 100c0e0:	48 8b 03             	mov    (%rbx),%rax
 100c0e3:	48 63 c0             	movslq %eax,%rax
 100c0e6:	89 04 25 f4 4d 02 01 	mov    %eax,0x1024df4
				if(nhist == 0 && nfile < nelem(files)) {
 100c0ed:	83 f9 00             	cmp    $0x0,%ecx
 100c0f0:	89 0c 25 08 4e 02 01 	mov    %ecx,0x1024e08
 100c0f7:	0f 85 df fe ff ff    	jne    100bfdc <dosrcline+0x37>
 100c0fd:	81 fa c8 00 00 00    	cmp    $0xc8,%edx
 100c103:	0f 8d d3 fe ff ff    	jge    100bfdc <dosrcline+0x37>
					// new top-level file
					files[nfile].srcstring = runtime·gostring(srcbuf);
 100c109:	48 63 ca             	movslq %edx,%rcx
 100c10c:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 100c110:	48 8d 04 0d b8 70 02 	lea    0x10270b8(,%rcx,1),%rax
 100c117:	01 
 100c118:	48 89 04 24          	mov    %rax,(%rsp)
 100c11c:	b8 70 5e 02 01       	mov    $0x1025e70,%eax
 100c121:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100c126:	e8 88 f6 ff ff       	callq  100b7b3 <runtime.gostring>
 100c12b:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
 100c130:	8b 14 25 f8 4d 02 01 	mov    0x1024df8,%edx
					files[nfile].aline = sym->value;
 100c137:	48 8b 03             	mov    (%rbx),%rax
 100c13a:	48 63 c0             	movslq %eax,%rax
 100c13d:	48 63 ca             	movslq %edx,%rcx
 100c140:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 100c144:	89 04 0d c8 70 02 01 	mov    %eax,0x10270c8(,%rcx,1)
					// this is "line 0"
					files[nfile++].delta = sym->value - 1;
 100c14b:	89 d0                	mov    %edx,%eax
 100c14d:	ff c2                	inc    %edx
 100c14f:	89 14 25 f8 4d 02 01 	mov    %edx,0x1024df8
 100c156:	48 63 c0             	movslq %eax,%rax
 100c159:	48 6b c0 18          	imul   $0x18,%rax,%rax
 100c15d:	48 05 cc 70 02 01    	add    $0x10270cc,%rax
 100c163:	48 8b 0b             	mov    (%rbx),%rcx
 100c166:	48 ff c9             	dec    %rcx
 100c169:	48 63 c9             	movslq %ecx,%rcx
 100c16c:	89 08                	mov    %ecx,(%rax)
				}
			}else{
				if(--nhist == 0)
					files[nfile-1].delta += sym->value - incstart;
 100c16e:	e9 69 fe ff ff       	jmpq   100bfdc <dosrcline+0x37>
					files[nfile].aline = sym->value;
					// this is "line 0"
					files[nfile++].delta = sym->value - 1;
				}
			}else{
				if(--nhist == 0)
 100c173:	ff c9                	dec    %ecx
 100c175:	89 0c 25 08 4e 02 01 	mov    %ecx,0x1024e08
 100c17c:	83 f9 00             	cmp    $0x0,%ecx
 100c17f:	0f 85 57 fe ff ff    	jne    100bfdc <dosrcline+0x37>
					files[nfile-1].delta += sym->value - incstart;
 100c185:	48 8b 03             	mov    (%rbx),%rax
 100c188:	8b 0c 25 f4 4d 02 01 	mov    0x1024df4,%ecx
 100c18f:	48 63 c9             	movslq %ecx,%rcx
 100c192:	48 29 c8             	sub    %rcx,%rax
 100c195:	48 63 c0             	movslq %eax,%rax
 100c198:	48 63 ca             	movslq %edx,%rcx
 100c19b:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 100c19f:	01 04 0d b4 70 02 01 	add    %eax,0x10270b4(,%rcx,1)
 100c1a6:	e9 31 fe ff ff       	jmpq   100bfdc <dosrcline+0x37>
	int32 i;

	switch(sym->symtype) {
	case 't':
	case 'T':
		if(runtime·strcmp(sym->name, (byte*)"etext") == 0)
 100c1ab:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
 100c1af:	48 89 0c 24          	mov    %rcx,(%rsp)
 100c1b3:	b9 39 31 02 01       	mov    $0x1023139,%ecx
 100c1b8:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100c1bd:	e8 dd f8 ff ff       	callq  100ba9f <runtime.strcmp>
 100c1c2:	8b 14 25 f8 4d 02 01 	mov    0x1024df8,%edx
 100c1c9:	83 f8 00             	cmp    $0x0,%eax
 100c1cc:	0f 84 0a fe ff ff    	je     100bfdc <dosrcline+0x37>
			break;
		f = &func[nfunc++];
 100c1d2:	8b 2c 25 04 4e 02 01 	mov    0x1024e04,%ebp
 100c1d9:	ff 04 25 04 4e 02 01 	incl   0x1024e04
 100c1e0:	48 63 ed             	movslq %ebp,%rbp
 100c1e3:	48 6b ed 60          	imul   $0x60,%rbp,%rbp
 100c1e7:	48 03 2c 25 80 4e 02 	add    0x1024e80,%rbp
 100c1ee:	01 
		// find source file
		for(i = 0; i < nfile - 1; i++) {
 100c1ef:	31 db                	xor    %ebx,%ebx
 100c1f1:	89 d0                	mov    %edx,%eax
 100c1f3:	ff c8                	dec    %eax
 100c1f5:	39 c3                	cmp    %eax,%ebx
 100c1f7:	7d 15                	jge    100c20e <dosrcline+0x269>
			if (files[i+1].aline > f->ln0)
 100c1f9:	48 63 cb             	movslq %ebx,%rcx
 100c1fc:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 100c200:	8b 04 0d e0 70 02 01 	mov    0x10270e0(,%rcx,1),%eax
 100c207:	8b 4d 50             	mov    0x50(%rbp),%ecx
 100c20a:	39 c8                	cmp    %ecx,%eax
 100c20c:	7e 34                	jle    100c242 <dosrcline+0x29d>
				break;
		}
		f->src = files[i].srcstring;
 100c20e:	48 63 d3             	movslq %ebx,%rdx
 100c211:	48 6b d2 18          	imul   $0x18,%rdx,%rdx
 100c215:	48 8d 0c 15 b8 70 02 	lea    0x10270b8(,%rdx,1),%rcx
 100c21c:	01 
 100c21d:	48 8b 01             	mov    (%rcx),%rax
 100c220:	48 89 45 20          	mov    %rax,0x20(%rbp)
 100c224:	48 8b 41 08          	mov    0x8(%rcx),%rax
 100c228:	48 89 45 28          	mov    %rax,0x28(%rbp)
		f->ln0 -= files[i].delta;
 100c22c:	48 63 cb             	movslq %ebx,%rcx
 100c22f:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
 100c233:	8b 04 0d cc 70 02 01 	mov    0x10270cc(,%rcx,1),%eax
 100c23a:	29 45 50             	sub    %eax,0x50(%rbp)
					// this is "line 0"
					files[nfile++].delta = sym->value - 1;
				}
			}else{
				if(--nhist == 0)
					files[nfile-1].delta += sym->value - incstart;
 100c23d:	e9 9a fd ff ff       	jmpq   100bfdc <dosrcline+0x37>
	case 'T':
		if(runtime·strcmp(sym->name, (byte*)"etext") == 0)
			break;
		f = &func[nfunc++];
		// find source file
		for(i = 0; i < nfile - 1; i++) {
 100c242:	ff c3                	inc    %ebx
 100c244:	eb ab                	jmp    100c1f1 <dosrcline+0x24c>

000000000100c246 <splitpcln>:
	}
}

// Interpret pc/ln table, saving the subpiece for each func.
static void
splitpcln(void)
 100c246:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100c24d:	ff ff 
 100c24f:	48 3b 21             	cmp    (%rcx),%rsp
 100c252:	77 05                	ja     100c259 <splitpcln+0x13>
 100c254:	e8 9a 56 ff ff       	callq  10018f3 <runtime.morestack00>
 100c259:	48 83 ec 40          	sub    $0x40,%rsp
 100c25d:	8b 14 25 00 4e 02 01 	mov    0x1024e00,%edx
 100c264:	4c 8b 1c 25 80 4e 02 	mov    0x1024e80,%r11
 100c26b:	01 
	uintptr pc;
	byte *p, *ep;
	Func *f, *ef;
	int32 pcquant;

	if(pclntab == epclntab || nfunc == 0)
 100c26c:	b8 00 0c 02 01       	mov    $0x1020c00,%eax
 100c271:	48 3d de 28 02 01    	cmp    $0x10228de,%rax
 100c277:	0f 84 84 01 00 00    	je     100c401 <splitpcln+0x1bb>
 100c27d:	83 fa 00             	cmp    $0x0,%edx
 100c280:	0f 84 7b 01 00 00    	je     100c401 <splitpcln+0x1bb>
	case '5':
		pcquant = 4;
		break;
	default:	// 6, 8
		pcquant = 1;
		break;
 100c286:	b8 36 00 00 00       	mov    $0x36,%eax
 100c28b:	83 f8 35             	cmp    $0x35,%eax
 100c28e:	0f 84 62 01 00 00    	je     100c3f6 <splitpcln+0x1b0>
	switch(thechar) {
	case '5':
		pcquant = 4;
		break;
	default:	// 6, 8
		pcquant = 1;
 100c294:	41 b8 01 00 00 00    	mov    $0x1,%r8d
		break;
	}

	// pc/ln table bounds
	p = pclntab;
 100c29a:	bb 00 0c 02 01       	mov    $0x1020c00,%ebx
	ep = epclntab;
 100c29f:	41 ba de 28 02 01    	mov    $0x10228de,%r10d

	f = func;
 100c2a5:	4c 89 dd             	mov    %r11,%rbp
	ef = func + nfunc;
 100c2a8:	48 63 ca             	movslq %edx,%rcx
 100c2ab:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100c2af:	4c 89 da             	mov    %r11,%rdx
 100c2b2:	49 8d 04 0b          	lea    (%r11,%rcx,1),%rax
 100c2b6:	49 89 c1             	mov    %rax,%r9
	pc = func[0].entry;	// text base
 100c2b9:	49 8b 73 40          	mov    0x40(%r11),%rsi
	f->pcln.array = p;
 100c2bd:	49 89 5b 30          	mov    %rbx,0x30(%r11)
	f->pc0 = pc;
 100c2c1:	49 89 73 48          	mov    %rsi,0x48(%r11)
	line = 0;
 100c2c5:	31 ff                	xor    %edi,%edi
	for(;;) {
		while(p < ep && *p > 128)
 100c2c7:	4c 39 d3             	cmp    %r10,%rbx
 100c2ca:	73 0e                	jae    100c2da <splitpcln+0x94>
 100c2cc:	0f b6 03             	movzbl (%rbx),%eax
 100c2cf:	3d 80 00 00 00       	cmp    $0x80,%eax
 100c2d4:	0f 87 03 01 00 00    	ja     100c3dd <splitpcln+0x197>
			pc += pcquant * (*p++ - 128);
		// runtime·printf("pc<%p targetpc=%p line=%d\n", pc, targetpc, line);
		if(*p == 0) {
 100c2da:	0f b6 03             	movzbl (%rbx),%eax
 100c2dd:	83 f8 00             	cmp    $0x0,%eax
 100c2e0:	0f 85 cc 00 00 00    	jne    100c3b2 <splitpcln+0x16c>
			if(p+5 > ep)
 100c2e6:	48 89 d8             	mov    %rbx,%rax
 100c2e9:	48 83 c0 05          	add    $0x5,%rax
 100c2ed:	4c 39 d0             	cmp    %r10,%rax
 100c2f0:	76 1d                	jbe    100c30f <splitpcln+0xc9>
			f->ln0 = line;
		}

		pc += pcquant;
	}
	if(f < ef) {
 100c2f2:	4c 39 cd             	cmp    %r9,%rbp
 100c2f5:	73 13                	jae    100c30a <splitpcln+0xc4>
		f->pcln.len = p - f->pcln.array;
 100c2f7:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
 100c2fb:	48 89 da             	mov    %rbx,%rdx
 100c2fe:	48 29 ca             	sub    %rcx,%rdx
 100c301:	89 55 38             	mov    %edx,0x38(%rbp)
		f->pcln.cap = f->pcln.len;
 100c304:	8b 4d 38             	mov    0x38(%rbp),%ecx
 100c307:	89 4d 3c             	mov    %ecx,0x3c(%rbp)
 100c30a:	48 83 c4 40          	add    $0x40,%rsp
 100c30e:	c3                   	retq   
		// runtime·printf("pc<%p targetpc=%p line=%d\n", pc, targetpc, line);
		if(*p == 0) {
			if(p+5 > ep)
				break;
			// 4 byte add to line
			line += (p[1]<<24) | (p[2]<<16) | (p[3]<<8) | p[4];
 100c30f:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
 100c313:	c1 e0 18             	shl    $0x18,%eax
 100c316:	0f b6 4b 02          	movzbl 0x2(%rbx),%ecx
 100c31a:	c1 e1 10             	shl    $0x10,%ecx
 100c31d:	09 c8                	or     %ecx,%eax
 100c31f:	0f b6 4b 03          	movzbl 0x3(%rbx),%ecx
 100c323:	c1 e1 08             	shl    $0x8,%ecx
 100c326:	09 c8                	or     %ecx,%eax
 100c328:	0f b6 4b 04          	movzbl 0x4(%rbx),%ecx
 100c32c:	09 c8                	or     %ecx,%eax
 100c32e:	01 c7                	add    %eax,%edi
			p += 5;
 100c330:	48 83 c3 05          	add    $0x5,%rbx
		// it can happen - just at the beginning! - that the update may
		// have updated line but left pc alone, to tell us the true line
		// number for pc==entry.  In that case, update f->ln0.
		// Having the correct initial line number is important for choosing
		// the correct file in dosrcline above.
		if(f == func && pc == f->pc0) {
 100c334:	4c 39 dd             	cmp    %r11,%rbp
 100c337:	75 09                	jne    100c342 <splitpcln+0xfc>
 100c339:	48 8b 45 48          	mov    0x48(%rbp),%rax
 100c33d:	48 39 c6             	cmp    %rax,%rsi
 100c340:	74 5a                	je     100c39c <splitpcln+0x156>
			f->pcln.array = p;
			f->pc0 = pc + pcquant;
			f->ln0 = line;
		}

		if(f < ef && pc >= (f+1)->entry) {
 100c342:	4c 39 cd             	cmp    %r9,%rbp
 100c345:	73 0c                	jae    100c353 <splitpcln+0x10d>
 100c347:	48 8b 85 a0 00 00 00 	mov    0xa0(%rbp),%rax
 100c34e:	48 39 c6             	cmp    %rax,%rsi
 100c351:	73 0b                	jae    100c35e <splitpcln+0x118>
			// that we're going to do as we continue our loop.
			f->pc0 = pc + pcquant;
			f->ln0 = line;
		}

		pc += pcquant;
 100c353:	49 63 c0             	movslq %r8d,%rax
 100c356:	48 01 c6             	add    %rax,%rsi
	pc = func[0].entry;	// text base
	f->pcln.array = p;
	f->pc0 = pc;
	line = 0;
	for(;;) {
		while(p < ep && *p > 128)
 100c359:	e9 69 ff ff ff       	jmpq   100c2c7 <splitpcln+0x81>
			f->pc0 = pc + pcquant;
			f->ln0 = line;
		}

		if(f < ef && pc >= (f+1)->entry) {
			f->pcln.len = p - f->pcln.array;
 100c35e:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
 100c362:	48 89 da             	mov    %rbx,%rdx
 100c365:	48 29 ca             	sub    %rcx,%rdx
 100c368:	89 55 38             	mov    %edx,0x38(%rbp)
			f->pcln.cap = f->pcln.len;
 100c36b:	8b 4d 38             	mov    0x38(%rbp),%ecx
 100c36e:	89 4d 3c             	mov    %ecx,0x3c(%rbp)
			do
				f++;
 100c371:	48 83 c5 60          	add    $0x60,%rbp
			while(f < ef && pc >= (f+1)->entry);
 100c375:	4c 39 cd             	cmp    %r9,%rbp
 100c378:	73 0c                	jae    100c386 <splitpcln+0x140>
 100c37a:	48 8b 85 a0 00 00 00 	mov    0xa0(%rbp),%rax
 100c381:	48 39 c6             	cmp    %rax,%rsi
 100c384:	73 eb                	jae    100c371 <splitpcln+0x12b>
			f->pcln.array = p;
 100c386:	48 89 5d 30          	mov    %rbx,0x30(%rbp)
			// pc0 and ln0 are the starting values for
			// the loop over f->pcln, so pc must be 
			// adjusted by the same pcquant update
			// that we're going to do as we continue our loop.
			f->pc0 = pc + pcquant;
 100c38a:	49 63 c8             	movslq %r8d,%rcx
 100c38d:	48 89 f2             	mov    %rsi,%rdx
 100c390:	48 01 ca             	add    %rcx,%rdx
 100c393:	48 89 55 48          	mov    %rdx,0x48(%rbp)
			f->ln0 = line;
 100c397:	89 7d 50             	mov    %edi,0x50(%rbp)
		}

		pc += pcquant;
 100c39a:	eb b7                	jmp    100c353 <splitpcln+0x10d>
		// have updated line but left pc alone, to tell us the true line
		// number for pc==entry.  In that case, update f->ln0.
		// Having the correct initial line number is important for choosing
		// the correct file in dosrcline above.
		if(f == func && pc == f->pc0) {
			f->pcln.array = p;
 100c39c:	48 89 5d 30          	mov    %rbx,0x30(%rbp)
			f->pc0 = pc + pcquant;
 100c3a0:	49 63 c8             	movslq %r8d,%rcx
 100c3a3:	48 89 f2             	mov    %rsi,%rdx
 100c3a6:	48 01 ca             	add    %rcx,%rdx
 100c3a9:	48 89 55 48          	mov    %rdx,0x48(%rbp)
			f->ln0 = line;
 100c3ad:	89 7d 50             	mov    %edi,0x50(%rbp)
		}

		if(f < ef && pc >= (f+1)->entry) {
 100c3b0:	eb 90                	jmp    100c342 <splitpcln+0xfc>
			if(p+5 > ep)
				break;
			// 4 byte add to line
			line += (p[1]<<24) | (p[2]<<16) | (p[3]<<8) | p[4];
			p += 5;
		} else if(*p <= 64)
 100c3b2:	0f b6 03             	movzbl (%rbx),%eax
 100c3b5:	83 f8 40             	cmp    $0x40,%eax
 100c3b8:	77 10                	ja     100c3ca <splitpcln+0x184>
			line += *p++;
 100c3ba:	48 89 d8             	mov    %rbx,%rax
 100c3bd:	48 ff c3             	inc    %rbx
 100c3c0:	0f b6 00             	movzbl (%rax),%eax
 100c3c3:	01 c7                	add    %eax,%edi
		// it can happen - just at the beginning! - that the update may
		// have updated line but left pc alone, to tell us the true line
		// number for pc==entry.  In that case, update f->ln0.
		// Having the correct initial line number is important for choosing
		// the correct file in dosrcline above.
		if(f == func && pc == f->pc0) {
 100c3c5:	e9 6a ff ff ff       	jmpq   100c334 <splitpcln+0xee>
			line += (p[1]<<24) | (p[2]<<16) | (p[3]<<8) | p[4];
			p += 5;
		} else if(*p <= 64)
			line += *p++;
		else
			line -= *p++ - 64;
 100c3ca:	48 89 d8             	mov    %rbx,%rax
 100c3cd:	48 ff c3             	inc    %rbx
 100c3d0:	0f b6 00             	movzbl (%rax),%eax
 100c3d3:	83 c0 c0             	add    $0xffffffffffffffc0,%eax
 100c3d6:	29 c7                	sub    %eax,%edi
		// it can happen - just at the beginning! - that the update may
		// have updated line but left pc alone, to tell us the true line
		// number for pc==entry.  In that case, update f->ln0.
		// Having the correct initial line number is important for choosing
		// the correct file in dosrcline above.
		if(f == func && pc == f->pc0) {
 100c3d8:	e9 57 ff ff ff       	jmpq   100c334 <splitpcln+0xee>
	f->pcln.array = p;
	f->pc0 = pc;
	line = 0;
	for(;;) {
		while(p < ep && *p > 128)
			pc += pcquant * (*p++ - 128);
 100c3dd:	48 89 d8             	mov    %rbx,%rax
 100c3e0:	48 ff c3             	inc    %rbx
 100c3e3:	0f b6 00             	movzbl (%rax),%eax
 100c3e6:	05 80 ff ff ff       	add    $0xffffff80,%eax
 100c3eb:	41 f7 e0             	mul    %r8d
 100c3ee:	48 01 c6             	add    %rax,%rsi
	pc = func[0].entry;	// text base
	f->pcln.array = p;
	f->pc0 = pc;
	line = 0;
	for(;;) {
		while(p < ep && *p > 128)
 100c3f1:	e9 d1 fe ff ff       	jmpq   100c2c7 <splitpcln+0x81>
	if(pclntab == epclntab || nfunc == 0)
		return;

	switch(thechar) {
	case '5':
		pcquant = 4;
 100c3f6:	41 b8 04 00 00 00    	mov    $0x4,%r8d
		pcquant = 1;
		break;
	}

	// pc/ln table bounds
	p = pclntab;
 100c3fc:	e9 99 fe ff ff       	jmpq   100c29a <splitpcln+0x54>
	byte *p, *ep;
	Func *f, *ef;
	int32 pcquant;

	if(pclntab == epclntab || nfunc == 0)
		return;
 100c401:	48 83 c4 40          	add    $0x40,%rsp
 100c405:	c3                   	retq   

000000000100c406 <runtime.funcline>:

// Return actual file line number for targetpc in func f.
// (Source file is f->src.)
// NOTE(rsc): If you edit this function, also edit extern.go:/FileLine
int32
runtime·funcline(Func *f, uintptr targetpc)
 100c406:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100c40d:	ff ff 
 100c40f:	48 3b 21             	cmp    (%rcx),%rsp
 100c412:	77 05                	ja     100c419 <runtime.funcline+0x13>
 100c414:	e8 3c 55 ff ff       	callq  1001955 <runtime.morestack16>
 100c419:	48 83 ec 60          	sub    $0x60,%rsp
 100c41d:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
 100c422:	4c 8b 4c 24 70       	mov    0x70(%rsp),%r9
	case '5':
		pcquant = 4;
		break;
	default:	// 6, 8
		pcquant = 1;
		break;
 100c427:	b8 36 00 00 00       	mov    $0x36,%eax
 100c42c:	83 f8 35             	cmp    $0x35,%eax
 100c42f:	0f 84 bd 00 00 00    	je     100c4f2 <runtime.funcline+0xec>
	switch(thechar) {
	case '5':
		pcquant = 4;
		break;
	default:	// 6, 8
		pcquant = 1;
 100c435:	41 b8 01 00 00 00    	mov    $0x1,%r8d
		break;
	}

	p = f->pcln.array;
 100c43b:	48 8b 57 30          	mov    0x30(%rdi),%rdx
	ep = p + f->pcln.len;
 100c43f:	8b 4f 38             	mov    0x38(%rdi),%ecx
 100c442:	48 89 d3             	mov    %rdx,%rbx
 100c445:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100c449:	48 89 c6             	mov    %rax,%rsi
	pc = f->pc0;
 100c44c:	48 8b 6f 48          	mov    0x48(%rdi),%rbp
	line = f->ln0;
 100c450:	8b 7f 50             	mov    0x50(%rdi),%edi
	for(;;) {
		// Table is a sequence of updates.

		// Each update says first how to adjust the pc,
		// in possibly multiple instructions...
		while(p < ep && *p > 128)
 100c453:	48 39 f3             	cmp    %rsi,%rbx
 100c456:	73 0a                	jae    100c462 <runtime.funcline+0x5c>
 100c458:	0f b6 03             	movzbl (%rbx),%eax
 100c45b:	3d 80 00 00 00       	cmp    $0x80,%eax
 100c460:	77 77                	ja     100c4d9 <runtime.funcline+0xd3>
		if(debug && !runtime·panicking)
			runtime·printf("pc<%p targetpc=%p line=%d\n", pc, targetpc, line);
		
		// If the pc has advanced too far or we're out of data,
		// stop and the last known line number.
		if(pc > targetpc || p >= ep)
 100c462:	4c 39 cd             	cmp    %r9,%rbp
 100c465:	77 19                	ja     100c480 <runtime.funcline+0x7a>
 100c467:	48 39 f3             	cmp    %rsi,%rbx
 100c46a:	73 14                	jae    100c480 <runtime.funcline+0x7a>
			break;

		// ... and then how to adjust the line number,
		// in a single instruction.
		if(*p == 0) {
 100c46c:	0f b6 03             	movzbl (%rbx),%eax
 100c46f:	83 f8 00             	cmp    $0x0,%eax
 100c472:	75 40                	jne    100c4b4 <runtime.funcline+0xae>
			if(p+5 > ep)
 100c474:	48 89 d8             	mov    %rbx,%rax
 100c477:	48 83 c0 05          	add    $0x5,%rax
 100c47b:	48 39 f0             	cmp    %rsi,%rax
 100c47e:	76 07                	jbe    100c487 <runtime.funcline+0x81>
			runtime·printf("pc=%p targetpc=%p line=%d\n", pc, targetpc, line);

		// PC increments implicitly on each iteration.
		pc += pcquant;
	}
	return line;
 100c480:	89 f8                	mov    %edi,%eax
 100c482:	48 83 c4 60          	add    $0x60,%rsp
 100c486:	c3                   	retq   
		// ... and then how to adjust the line number,
		// in a single instruction.
		if(*p == 0) {
			if(p+5 > ep)
				break;
			line += (p[1]<<24) | (p[2]<<16) | (p[3]<<8) | p[4];
 100c487:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
 100c48b:	c1 e0 18             	shl    $0x18,%eax
 100c48e:	0f b6 4b 02          	movzbl 0x2(%rbx),%ecx
 100c492:	c1 e1 10             	shl    $0x10,%ecx
 100c495:	09 c8                	or     %ecx,%eax
 100c497:	0f b6 4b 03          	movzbl 0x3(%rbx),%ecx
 100c49b:	c1 e1 08             	shl    $0x8,%ecx
 100c49e:	09 c8                	or     %ecx,%eax
 100c4a0:	0f b6 4b 04          	movzbl 0x4(%rbx),%ecx
 100c4a4:	09 c8                	or     %ecx,%eax
 100c4a6:	01 c7                	add    %eax,%edi
			p += 5;
 100c4a8:	48 83 c3 05          	add    $0x5,%rbx
		// Now pc, line pair is consistent.
		if(debug && !runtime·panicking)
			runtime·printf("pc=%p targetpc=%p line=%d\n", pc, targetpc, line);

		// PC increments implicitly on each iteration.
		pc += pcquant;
 100c4ac:	49 63 c0             	movslq %r8d,%rax
 100c4af:	48 01 c5             	add    %rax,%rbp
	for(;;) {
		// Table is a sequence of updates.

		// Each update says first how to adjust the pc,
		// in possibly multiple instructions...
		while(p < ep && *p > 128)
 100c4b2:	eb 9f                	jmp    100c453 <runtime.funcline+0x4d>
		if(*p == 0) {
			if(p+5 > ep)
				break;
			line += (p[1]<<24) | (p[2]<<16) | (p[3]<<8) | p[4];
			p += 5;
		} else if(*p <= 64)
 100c4b4:	0f b6 03             	movzbl (%rbx),%eax
 100c4b7:	83 f8 40             	cmp    $0x40,%eax
 100c4ba:	77 0d                	ja     100c4c9 <runtime.funcline+0xc3>
			line += *p++;
 100c4bc:	48 89 d8             	mov    %rbx,%rax
 100c4bf:	48 ff c3             	inc    %rbx
 100c4c2:	0f b6 00             	movzbl (%rax),%eax
 100c4c5:	01 c7                	add    %eax,%edi
		// Now pc, line pair is consistent.
		if(debug && !runtime·panicking)
			runtime·printf("pc=%p targetpc=%p line=%d\n", pc, targetpc, line);

		// PC increments implicitly on each iteration.
		pc += pcquant;
 100c4c7:	eb e3                	jmp    100c4ac <runtime.funcline+0xa6>
			line += (p[1]<<24) | (p[2]<<16) | (p[3]<<8) | p[4];
			p += 5;
		} else if(*p <= 64)
			line += *p++;
		else
			line -= *p++ - 64;
 100c4c9:	48 89 d8             	mov    %rbx,%rax
 100c4cc:	48 ff c3             	inc    %rbx
 100c4cf:	0f b6 00             	movzbl (%rax),%eax
 100c4d2:	83 c0 c0             	add    $0xffffffffffffffc0,%eax
 100c4d5:	29 c7                	sub    %eax,%edi
		// Now pc, line pair is consistent.
		if(debug && !runtime·panicking)
			runtime·printf("pc=%p targetpc=%p line=%d\n", pc, targetpc, line);

		// PC increments implicitly on each iteration.
		pc += pcquant;
 100c4d7:	eb d3                	jmp    100c4ac <runtime.funcline+0xa6>
		// Table is a sequence of updates.

		// Each update says first how to adjust the pc,
		// in possibly multiple instructions...
		while(p < ep && *p > 128)
			pc += pcquant * (*p++ - 128);
 100c4d9:	48 89 d8             	mov    %rbx,%rax
 100c4dc:	48 ff c3             	inc    %rbx
 100c4df:	0f b6 00             	movzbl (%rax),%eax
 100c4e2:	05 80 ff ff ff       	add    $0xffffff80,%eax
 100c4e7:	41 f7 e0             	mul    %r8d
 100c4ea:	48 01 c5             	add    %rax,%rbp
	for(;;) {
		// Table is a sequence of updates.

		// Each update says first how to adjust the pc,
		// in possibly multiple instructions...
		while(p < ep && *p > 128)
 100c4ed:	e9 61 ff ff ff       	jmpq   100c453 <runtime.funcline+0x4d>
		debug = 0
	};
	
	switch(thechar) {
	case '5':
		pcquant = 4;
 100c4f2:	41 b8 04 00 00 00    	mov    $0x4,%r8d
	default:	// 6, 8
		pcquant = 1;
		break;
	}

	p = f->pcln.array;
 100c4f8:	e9 3e ff ff ff       	jmpq   100c43b <runtime.funcline+0x35>

000000000100c4fd <buildfuncs>:
	}
	return line;
}

static void
buildfuncs(void)
 100c4fd:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100c504:	ff ff 
 100c506:	48 3b 21             	cmp    (%rcx),%rsp
 100c509:	77 05                	ja     100c510 <buildfuncs+0x13>
 100c50b:	e8 e3 53 ff ff       	callq  10018f3 <runtime.morestack00>
 100c510:	48 83 ec 10          	sub    $0x10,%rsp
{
	extern byte etext[];

	if(func != nil)
 100c514:	48 83 3c 25 80 4e 02 	cmpq   $0x0,0x1024e80
 100c51b:	01 00 
 100c51d:	74 05                	je     100c524 <buildfuncs+0x27>
		return;
 100c51f:	48 83 c4 10          	add    $0x10,%rsp
 100c523:	c3                   	retq   

	// Memory profiling uses this code;
	// can deadlock if the profiler ends
	// up back here.
	m->nomemprof++;
 100c524:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100c52b:	ff ff 
 100c52d:	ff 80 88 00 00 00    	incl   0x88(%rax)

	// count funcs, fnames
	nfunc = 0;
 100c533:	c7 04 25 00 4e 02 01 	movl   $0x0,0x1024e00
 100c53a:	00 00 00 00 
	nfname = 0;
 100c53e:	c7 04 25 fc 4d 02 01 	movl   $0x0,0x1024dfc
 100c545:	00 00 00 00 
	walksymtab(dofunc);
 100c549:	b8 a3 bc 00 01       	mov    $0x100bca3,%eax
 100c54e:	48 89 04 24          	mov    %rax,(%rsp)
 100c552:	e8 35 f6 ff ff       	callq  100bb8c <walksymtab>

	// initialize tables
	func = runtime·mal((nfunc+1)*sizeof func[0]);
 100c557:	8b 0c 25 00 4e 02 01 	mov    0x1024e00,%ecx
 100c55e:	48 63 d1             	movslq %ecx,%rdx
 100c561:	48 8d 0c 51          	lea    (%rcx,%rdx,2),%rcx
 100c565:	c1 e1 05             	shl    $0x5,%ecx
 100c568:	83 c1 60             	add    $0x60,%ecx
 100c56b:	48 63 c9             	movslq %ecx,%rcx
 100c56e:	48 89 0c 24          	mov    %rcx,(%rsp)
 100c572:	e8 b9 6b ff ff       	callq  1003130 <runtime.mal>
	func[nfunc].entry = (uint64)etext;
 100c577:	8b 0c 25 00 4e 02 01 	mov    0x1024e00,%ecx
 100c57e:	48 63 c9             	movslq %ecx,%rcx
 100c581:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100c585:	48 89 04 25 80 4e 02 	mov    %rax,0x1024e80
 100c58c:	01 
 100c58d:	48 8d 04 08          	lea    (%rax,%rcx,1),%rax
 100c591:	b9 24 dd 00 01       	mov    $0x100dd24,%ecx
 100c596:	48 89 48 40          	mov    %rcx,0x40(%rax)
	fname = runtime·mal(nfname*sizeof fname[0]);
 100c59a:	8b 0c 25 fc 4d 02 01 	mov    0x1024dfc,%ecx
 100c5a1:	c1 e1 03             	shl    $0x3,%ecx
 100c5a4:	48 63 c9             	movslq %ecx,%rcx
 100c5a7:	48 89 0c 24          	mov    %rcx,(%rsp)
 100c5ab:	e8 80 6b ff ff       	callq  1003130 <runtime.mal>
 100c5b0:	48 89 04 25 78 4e 02 	mov    %rax,0x1024e78
 100c5b7:	01 
	nfunc = 0;
 100c5b8:	c7 04 25 00 4e 02 01 	movl   $0x0,0x1024e00
 100c5bf:	00 00 00 00 
	walksymtab(dofunc);
 100c5c3:	b8 a3 bc 00 01       	mov    $0x100bca3,%eax
 100c5c8:	48 89 04 24          	mov    %rax,(%rsp)
 100c5cc:	e8 bb f5 ff ff       	callq  100bb8c <walksymtab>

	// split pc/ln table by func
	splitpcln();
 100c5d1:	e8 70 fc ff ff       	callq  100c246 <splitpcln>

	// record src file and line info for each func
	walksymtab(dosrcline);
 100c5d6:	b8 a5 bf 00 01       	mov    $0x100bfa5,%eax
 100c5db:	48 89 04 24          	mov    %rax,(%rsp)
 100c5df:	e8 a8 f5 ff ff       	callq  100bb8c <walksymtab>

	m->nomemprof--;
 100c5e4:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100c5eb:	ff ff 
 100c5ed:	ff 88 88 00 00 00    	decl   0x88(%rax)
 100c5f3:	48 83 c4 10          	add    $0x10,%rsp
 100c5f7:	c3                   	retq   

000000000100c5f8 <runtime.findfunc>:
}

Func*
runtime·findfunc(uintptr addr)
 100c5f8:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100c5ff:	ff ff 
 100c601:	48 3b 21             	cmp    (%rcx),%rsp
 100c604:	77 05                	ja     100c60b <runtime.findfunc+0x13>
 100c606:	e8 41 53 ff ff       	callq  100194c <runtime.morestack8>
 100c60b:	48 83 ec 30          	sub    $0x30,%rsp
	// handler, findfunc must run without
	// grabbing any locks.
	// (Before enabling the signal handler,
	// SetCPUProfileRate calls findfunc to trigger
	// the initialization outside the handler.)
	if(runtime·atomicload(&funcinit) == 0) {
 100c60f:	b9 ec 4d 02 01       	mov    $0x1024dec,%ecx
 100c614:	48 89 0c 24          	mov    %rcx,(%rsp)
 100c618:	e8 bc 54 ff ff       	callq  1001ad9 <runtime.atomicload>
 100c61d:	8b 34 25 00 4e 02 01 	mov    0x1024e00,%esi
 100c624:	48 8b 1c 25 80 4e 02 	mov    0x1024e80,%rbx
 100c62b:	01 
 100c62c:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
 100c631:	83 f8 00             	cmp    $0x0,%eax
 100c634:	75 56                	jne    100c68c <runtime.findfunc+0x94>
		runtime·lock(&funclock);
 100c636:	b8 88 4e 02 01       	mov    $0x1024e88,%eax
 100c63b:	48 89 04 24          	mov    %rax,(%rsp)
 100c63f:	e8 ec 07 00 00       	callq  100ce30 <runtime.lock>
		if(funcinit == 0) {
 100c644:	83 3c 25 ec 4d 02 01 	cmpl   $0x0,0x1024dec
 100c64b:	00 
 100c64c:	75 1c                	jne    100c66a <runtime.findfunc+0x72>
			buildfuncs();
 100c64e:	e8 aa fe ff ff       	callq  100c4fd <buildfuncs>
			runtime·atomicstore(&funcinit, 1);
 100c653:	b8 ec 4d 02 01       	mov    $0x1024dec,%eax
 100c658:	48 89 04 24          	mov    %rax,(%rsp)
 100c65c:	b8 01 00 00 00       	mov    $0x1,%eax
 100c661:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100c665:	e8 a4 53 ff ff       	callq  1001a0e <runtime.atomicstore>
		}
		runtime·unlock(&funclock);
 100c66a:	b8 88 4e 02 01       	mov    $0x1024e88,%eax
 100c66f:	48 89 04 24          	mov    %rax,(%rsp)
 100c673:	e8 0a 08 00 00       	callq  100ce82 <runtime.unlock>
 100c678:	8b 34 25 00 4e 02 01 	mov    0x1024e00,%esi
 100c67f:	48 8b 1c 25 80 4e 02 	mov    0x1024e80,%rbx
 100c686:	01 
 100c687:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
	}

	if(nfunc == 0)
 100c68c:	83 fe 00             	cmp    $0x0,%esi
 100c68f:	75 08                	jne    100c699 <runtime.findfunc+0xa1>
		return nil;
 100c691:	48 31 c0             	xor    %rax,%rax
 100c694:	48 83 c4 30          	add    $0x30,%rsp
 100c698:	c3                   	retq   
	if(addr < func[0].entry || addr >= func[nfunc].entry)
 100c699:	48 8b 43 40          	mov    0x40(%rbx),%rax
 100c69d:	48 39 c7             	cmp    %rax,%rdi
 100c6a0:	0f 82 c3 00 00 00    	jb     100c769 <runtime.findfunc+0x171>
 100c6a6:	48 63 ce             	movslq %esi,%rcx
 100c6a9:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100c6ad:	48 89 da             	mov    %rbx,%rdx
 100c6b0:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
 100c6b4:	48 8b 40 40          	mov    0x40(%rax),%rax
 100c6b8:	48 39 c7             	cmp    %rax,%rdi
 100c6bb:	0f 83 a8 00 00 00    	jae    100c769 <runtime.findfunc+0x171>
		return nil;

	// binary search to find func with entry <= addr.
	f = func;
 100c6c1:	48 89 dd             	mov    %rbx,%rbp
	nf = nfunc;
	while(nf > 0) {
 100c6c4:	83 fe 00             	cmp    $0x0,%esi
 100c6c7:	7e 5e                	jle    100c727 <runtime.findfunc+0x12f>
		n = nf/2;
 100c6c9:	89 f0                	mov    %esi,%eax
 100c6cb:	81 fe 00 00 00 80    	cmp    $0x80000000,%esi
 100c6d1:	83 d8 ff             	sbb    $0xffffffffffffffff,%eax
 100c6d4:	d1 f8                	sar    %eax
 100c6d6:	89 c3                	mov    %eax,%ebx
		if(f[n].entry <= addr && addr < f[n+1].entry)
 100c6d8:	48 63 c8             	movslq %eax,%rcx
 100c6db:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100c6df:	48 89 ea             	mov    %rbp,%rdx
 100c6e2:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100c6e6:	48 8b 40 40          	mov    0x40(%rax),%rax
 100c6ea:	48 39 f8             	cmp    %rdi,%rax
 100c6ed:	77 1a                	ja     100c709 <runtime.findfunc+0x111>
 100c6ef:	48 63 cb             	movslq %ebx,%rcx
 100c6f2:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100c6f6:	48 89 ea             	mov    %rbp,%rdx
 100c6f9:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100c6fd:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
 100c704:	48 39 c7             	cmp    %rax,%rdi
 100c707:	72 4d                	jb     100c756 <runtime.findfunc+0x15e>
			return &f[n];
		else if(addr < f[n].entry)
 100c709:	48 63 cb             	movslq %ebx,%rcx
 100c70c:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100c710:	48 89 ea             	mov    %rbp,%rdx
 100c713:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100c717:	48 8b 40 40          	mov    0x40(%rax),%rax
 100c71b:	48 39 c7             	cmp    %rax,%rdi
 100c71e:	73 1d                	jae    100c73d <runtime.findfunc+0x145>
			nf = n;
 100c720:	89 de                	mov    %ebx,%esi
		return nil;

	// binary search to find func with entry <= addr.
	f = func;
	nf = nfunc;
	while(nf > 0) {
 100c722:	83 fe 00             	cmp    $0x0,%esi
 100c725:	7f a2                	jg     100c6c9 <runtime.findfunc+0xd1>

	// can't get here -- we already checked above
	// that the address was in the table bounds.
	// this can only happen if the table isn't sorted
	// by address or if the binary search above is buggy.
	runtime·prints("findfunc unreachable\n");
 100c727:	b8 3f 31 02 01       	mov    $0x102313f,%eax
 100c72c:	48 89 04 24          	mov    %rax,(%rsp)
 100c730:	e8 bc ab ff ff       	callq  10072f1 <runtime.prints>
	return nil;
 100c735:	48 31 c0             	xor    %rax,%rax
 100c738:	48 83 c4 30          	add    $0x30,%rsp
 100c73c:	c3                   	retq   
		if(f[n].entry <= addr && addr < f[n+1].entry)
			return &f[n];
		else if(addr < f[n].entry)
			nf = n;
		else {
			f += n+1;
 100c73d:	48 63 c3             	movslq %ebx,%rax
 100c740:	48 6b c0 60          	imul   $0x60,%rax,%rax
 100c744:	48 83 c0 60          	add    $0x60,%rax
 100c748:	48 01 c5             	add    %rax,%rbp
			nf -= n+1;
 100c74b:	89 d8                	mov    %ebx,%eax
 100c74d:	ff c0                	inc    %eax
 100c74f:	29 c6                	sub    %eax,%esi
		return nil;

	// binary search to find func with entry <= addr.
	f = func;
	nf = nfunc;
	while(nf > 0) {
 100c751:	e9 6e ff ff ff       	jmpq   100c6c4 <runtime.findfunc+0xcc>
		n = nf/2;
		if(f[n].entry <= addr && addr < f[n+1].entry)
			return &f[n];
 100c756:	48 63 cb             	movslq %ebx,%rcx
 100c759:	48 6b c9 60          	imul   $0x60,%rcx,%rcx
 100c75d:	48 89 ea             	mov    %rbp,%rdx
 100c760:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100c764:	48 83 c4 30          	add    $0x30,%rsp
 100c768:	c3                   	retq   
 100c769:	48 31 c0             	xor    %rax,%rax
 100c76c:	48 83 c4 30          	add    $0x30,%rsp
 100c770:	c3                   	retq   

000000000100c771 <runtime.exit>:
//

#include "amd64/asm.h"

TEXT runtime·exit(SB),7,$0-8
	MOVL	8(SP), DI
 100c771:	8b 7c 24 08          	mov    0x8(%rsp),%edi
	MOVL	$231, AX	// exitgroup - force all os threads to exit
 100c775:	b8 e7 00 00 00       	mov    $0xe7,%eax
	SYSCALL
 100c77a:	0f 05                	syscall 
	RET
 100c77c:	c3                   	retq   

000000000100c77d <runtime.open>:
	MOVL	$60, AX	// exit - exit the current os thread
	SYSCALL
	RET

TEXT runtime·open(SB),7,$0-16
	MOVQ	8(SP), DI
 100c77d:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	MOVL	16(SP), SI
 100c782:	8b 74 24 10          	mov    0x10(%rsp),%esi
	MOVL	20(SP), DX
 100c786:	8b 54 24 14          	mov    0x14(%rsp),%edx
	MOVL	$2, AX			// syscall entry
 100c78a:	b8 02 00 00 00       	mov    $0x2,%eax
	SYSCALL
 100c78f:	0f 05                	syscall 
	RET
 100c791:	c3                   	retq   

000000000100c792 <runtime.close>:

TEXT runtime·close(SB),7,$0-16
	MOVL	8(SP), DI
 100c792:	8b 7c 24 08          	mov    0x8(%rsp),%edi
	MOVL	$3, AX			// syscall entry
 100c796:	b8 03 00 00 00       	mov    $0x3,%eax
	SYSCALL
 100c79b:	0f 05                	syscall 
	RET
 100c79d:	c3                   	retq   

000000000100c79e <runtime.write>:

TEXT runtime·write(SB),7,$0-24
	MOVL	8(SP), DI
 100c79e:	8b 7c 24 08          	mov    0x8(%rsp),%edi
	MOVQ	16(SP), SI
 100c7a2:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVL	24(SP), DX
 100c7a7:	8b 54 24 18          	mov    0x18(%rsp),%edx
	MOVL	$1, AX			// syscall entry
 100c7ab:	b8 01 00 00 00       	mov    $0x1,%eax
	SYSCALL
 100c7b0:	0f 05                	syscall 
	RET
 100c7b2:	c3                   	retq   

000000000100c7b3 <runtime.read>:

TEXT runtime·read(SB),7,$0-24
	MOVL	8(SP), DI
 100c7b3:	8b 7c 24 08          	mov    0x8(%rsp),%edi
	MOVQ	16(SP), SI
 100c7b7:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVL	24(SP), DX
 100c7bc:	8b 54 24 18          	mov    0x18(%rsp),%edx
	MOVL	$0, AX			// syscall entry
 100c7c0:	31 c0                	xor    %eax,%eax
	SYSCALL
 100c7c2:	0f 05                	syscall 
	RET
 100c7c4:	c3                   	retq   

000000000100c7c5 <runtime.setitimer>:
	MOVL	$200, AX	// syscall - tkill
	SYSCALL
	RET

TEXT runtime·setitimer(SB),7,$0-24
	MOVL	8(SP), DI
 100c7c5:	8b 7c 24 08          	mov    0x8(%rsp),%edi
	MOVQ	16(SP), SI
 100c7c9:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVQ	24(SP), DX
 100c7ce:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
	MOVL	$38, AX			// syscall entry
 100c7d3:	b8 26 00 00 00       	mov    $0x26,%eax
	SYSCALL
 100c7d8:	0f 05                	syscall 
	RET
 100c7da:	c3                   	retq   

000000000100c7db <runtime.mincore>:

TEXT runtime·mincore(SB),7,$0-24
	MOVQ	8(SP), DI
 100c7db:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	MOVQ	16(SP), SI
 100c7e0:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVQ	24(SP), DX
 100c7e5:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
	MOVL	$27, AX			// syscall entry
 100c7ea:	b8 1b 00 00 00       	mov    $0x1b,%eax
	SYSCALL
 100c7ef:	0f 05                	syscall 
	RET
 100c7f1:	c3                   	retq   

000000000100c7f2 <runtime.gettime>:

TEXT runtime·gettime(SB), 7, $32
 100c7f2:	48 83 ec 20          	sub    $0x20,%rsp
	LEAQ	8(SP), DI
 100c7f6:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
	MOVQ	$0, SI
 100c7fb:	48 31 f6             	xor    %rsi,%rsi
	MOVQ	$0xffffffffff600000, AX
 100c7fe:	48 c7 c0 00 00 60 ff 	mov    $0xffffffffff600000,%rax
	CALL	AX
 100c805:	ff d0                	callq  *%rax

	MOVQ	8(SP), BX	// sec
 100c807:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
	MOVQ	sec+0(FP), DI
 100c80c:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
	MOVQ	BX, (DI)
 100c811:	48 89 1f             	mov    %rbx,(%rdi)

	MOVL	16(SP), BX	// usec
 100c814:	8b 5c 24 10          	mov    0x10(%rsp),%ebx
	MOVQ	usec+8(FP), DI
 100c818:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
	MOVL	BX, (DI)
 100c81d:	89 1f                	mov    %ebx,(%rdi)
	RET
 100c81f:	48 83 c4 20          	add    $0x20,%rsp
 100c823:	c3                   	retq   

000000000100c824 <runtime.rt_sigaction>:

TEXT runtime·rt_sigaction(SB),7,$0-32
	MOVL	8(SP), DI
 100c824:	8b 7c 24 08          	mov    0x8(%rsp),%edi
	MOVQ	16(SP), SI
 100c828:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVQ	24(SP), DX
 100c82d:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
	MOVQ	32(SP), R10
 100c832:	4c 8b 54 24 20       	mov    0x20(%rsp),%r10
	MOVL	$13, AX			// syscall entry
 100c837:	b8 0d 00 00 00       	mov    $0xd,%eax
	SYSCALL
 100c83c:	0f 05                	syscall 
	RET
 100c83e:	c3                   	retq   

000000000100c83f <runtime.sigtramp>:

TEXT runtime·sigtramp(SB),7,$64
 100c83f:	48 83 ec 40          	sub    $0x40,%rsp
	get_tls(BX)

	// save g
	MOVQ	g(BX), R10
 100c843:	64 4c 8b 14 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%r10
 100c84a:	ff ff 
	MOVQ	R10, 40(SP)
 100c84c:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)

	// g = m->gsignal
	MOVQ	m(BX), BP
 100c851:	64 48 8b 2c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rbp
 100c858:	ff ff 
	MOVQ	m_gsignal(BP), BP
 100c85a:	48 8b 6d 48          	mov    0x48(%rbp),%rbp
	MOVQ	BP, g(BX)
 100c85e:	64 48 89 2c 25 f0 ff 	mov    %rbp,%fs:0xfffffffffffffff0
 100c865:	ff ff 

	MOVQ	DI, 0(SP)
 100c867:	48 89 3c 24          	mov    %rdi,(%rsp)
	MOVQ	SI, 8(SP)
 100c86b:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
	MOVQ	DX, 16(SP)
 100c870:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
	MOVQ	R10, 24(SP)
 100c875:	4c 89 54 24 18       	mov    %r10,0x18(%rsp)

	CALL	runtime·sighandler(SB)
 100c87a:	e8 2c e8 ff ff       	callq  100b0ab <runtime.sighandler>

	// restore g
	get_tls(BX)
	MOVQ	40(SP), R10
 100c87f:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
	MOVQ	R10, g(BX)
 100c884:	64 4c 89 14 25 f0 ff 	mov    %r10,%fs:0xfffffffffffffff0
 100c88b:	ff ff 
	RET
 100c88d:	48 83 c4 40          	add    $0x40,%rsp
 100c891:	c3                   	retq   

000000000100c892 <runtime.sigignore>:

TEXT runtime·sigignore(SB),7,$0
	RET
 100c892:	c3                   	retq   

000000000100c893 <runtime.sigreturn>:

TEXT runtime·sigreturn(SB),7,$0
	MOVL	$15, AX	// rt_sigreturn
 100c893:	b8 0f 00 00 00       	mov    $0xf,%eax
	SYSCALL
 100c898:	0f 05                	syscall 
	INT $3	// not reached
 100c89a:	cd 03                	int    $0x3

000000000100c89c <runtime.mmap>:

TEXT runtime·mmap(SB),7,$0
	MOVQ	8(SP), DI
 100c89c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	MOVQ	$0, SI
 100c8a1:	48 31 f6             	xor    %rsi,%rsi
	MOVQ	16(SP), SI
 100c8a4:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVL	24(SP), DX
 100c8a9:	8b 54 24 18          	mov    0x18(%rsp),%edx
	MOVL	28(SP), R10
 100c8ad:	44 8b 54 24 1c       	mov    0x1c(%rsp),%r10d
	MOVL	32(SP), R8
 100c8b2:	44 8b 44 24 20       	mov    0x20(%rsp),%r8d
	MOVL	36(SP), R9
 100c8b7:	44 8b 4c 24 24       	mov    0x24(%rsp),%r9d

	MOVL	$9, AX			// mmap
 100c8bc:	b8 09 00 00 00       	mov    $0x9,%eax
	SYSCALL
 100c8c1:	0f 05                	syscall 
	CMPQ	AX, $0xfffffffffffff001
 100c8c3:	48 3d 01 f0 ff ff    	cmp    $0xfffffffffffff001,%rax
	JLS	3(PC)
 100c8c9:	76 06                	jbe    100c8d1 <runtime.mmap+0x35>
	NOTQ	AX
 100c8cb:	48 f7 d0             	not    %rax
	INCQ	AX
 100c8ce:	48 ff c0             	inc    %rax
	RET
 100c8d1:	c3                   	retq   

000000000100c8d2 <runtime.munmap>:

TEXT runtime·munmap(SB),7,$0
	MOVQ	8(SP), DI
 100c8d2:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	MOVQ	16(SP), SI
 100c8d7:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVQ	$11, AX	// munmap
 100c8dc:	48 c7 c0 0b 00 00 00 	mov    $0xb,%rax
	SYSCALL
 100c8e3:	0f 05                	syscall 
	CMPQ	AX, $0xfffffffffffff001
 100c8e5:	48 3d 01 f0 ff ff    	cmp    $0xfffffffffffff001,%rax
	JLS	2(PC)
 100c8eb:	76 05                	jbe    100c8f2 <runtime.munmap+0x20>
	CALL	runtime·notok(SB)
 100c8ed:	e8 01 00 00 00       	callq  100c8f3 <runtime.notok>
	RET
 100c8f2:	c3                   	retq   

000000000100c8f3 <runtime.notok>:

TEXT runtime·notok(SB),7,$0
	MOVQ	$0xf1, BP
 100c8f3:	48 c7 c5 f1 00 00 00 	mov    $0xf1,%rbp
	MOVQ	BP, (BP)
 100c8fa:	48 89 6d 00          	mov    %rbp,0x0(%rbp)
	RET
 100c8fe:	c3                   	retq   

000000000100c8ff <runtime.futex>:

// int64 futex(int32 *uaddr, int32 op, int32 val,
//	struct timespec *timeout, int32 *uaddr2, int32 val2);
TEXT runtime·futex(SB),7,$0
	MOVQ	8(SP), DI
 100c8ff:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	MOVL	16(SP), SI
 100c904:	8b 74 24 10          	mov    0x10(%rsp),%esi
	MOVL	20(SP), DX
 100c908:	8b 54 24 14          	mov    0x14(%rsp),%edx
	MOVQ	24(SP), R10
 100c90c:	4c 8b 54 24 18       	mov    0x18(%rsp),%r10
	MOVQ	32(SP), R8
 100c911:	4c 8b 44 24 20       	mov    0x20(%rsp),%r8
	MOVL	40(SP), R9
 100c916:	44 8b 4c 24 28       	mov    0x28(%rsp),%r9d
	MOVL	$202, AX
 100c91b:	b8 ca 00 00 00       	mov    $0xca,%eax
	SYSCALL
 100c920:	0f 05                	syscall 
	RET
 100c922:	c3                   	retq   

000000000100c923 <runtime.clone>:

// int64 clone(int32 flags, void *stack, M *m, G *g, void (*fn)(void));
TEXT runtime·clone(SB),7,$0
	MOVL	flags+8(SP), DI
 100c923:	8b 7c 24 08          	mov    0x8(%rsp),%edi
	MOVQ	stack+16(SP), SI
 100c927:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi

	// Copy m, g, fn off parent stack for use by child.
	// Careful: Linux system call clobbers CX and R11.
	MOVQ	mm+24(SP), R8
 100c92c:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
	MOVQ	gg+32(SP), R9
 100c931:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9
	MOVQ	fn+40(SP), R12
 100c936:	4c 8b 64 24 28       	mov    0x28(%rsp),%r12

	MOVL	$56, AX
 100c93b:	b8 38 00 00 00       	mov    $0x38,%eax
	SYSCALL
 100c940:	0f 05                	syscall 

	// In parent, return.
	CMPQ	AX, $0
 100c942:	48 83 f8 00          	cmp    $0x0,%rax
	JEQ	2(PC)
 100c946:	74 01                	je     100c949 <runtime.clone+0x26>
	RET
 100c948:	c3                   	retq   
	
	// In child, on new stack.
	MOVQ	SI, SP
 100c949:	48 89 f4             	mov    %rsi,%rsp
	
	// Initialize m->procid to Linux tid
	MOVL	$186, AX	// gettid
 100c94c:	b8 ba 00 00 00       	mov    $0xba,%eax
	SYSCALL
 100c951:	0f 05                	syscall 
	MOVQ	AX, m_procid(R8)
 100c953:	49 89 40 40          	mov    %rax,0x40(%r8)

	// Set FS to point at m->tls.
	LEAQ	m_tls(R8), DI
 100c957:	49 8d 78 50          	lea    0x50(%r8),%rdi
	CALL	runtime·settls(SB)
 100c95b:	e8 49 00 00 00       	callq  100c9a9 <runtime.settls>

	// In child, set up new stack
	get_tls(CX)
	MOVQ	R8, m(CX)
 100c960:	64 4c 89 04 25 f8 ff 	mov    %r8,%fs:0xfffffffffffffff8
 100c967:	ff ff 
	MOVQ	R9, g(CX)
 100c969:	64 4c 89 0c 25 f0 ff 	mov    %r9,%fs:0xfffffffffffffff0
 100c970:	ff ff 
	CALL	runtime·stackcheck(SB)
 100c972:	e8 17 51 ff ff       	callq  1001a8e <runtime.stackcheck>

	// Call fn
	CALL	R12
 100c977:	41 ff d4             	callq  *%r12

	// It shouldn't return.  If it does, exit
	MOVL	$111, DI
 100c97a:	bf 6f 00 00 00       	mov    $0x6f,%edi
	MOVL	$60, AX
 100c97f:	b8 3c 00 00 00       	mov    $0x3c,%eax
	SYSCALL
 100c984:	0f 05                	syscall 

	// Call fn
	CALL	R12

	// It shouldn't return.  If it does, exit
	MOVL	$111, DI
 100c986:	eb f2                	jmp    100c97a <runtime.clone+0x57>

000000000100c988 <runtime.sigaltstack>:
	MOVL	$60, AX
	SYSCALL
	JMP	-3(PC)	// keep exiting

TEXT runtime·sigaltstack(SB),7,$-8
	MOVQ	new+8(SP), DI
 100c988:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	MOVQ	old+16(SP), SI
 100c98d:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
	MOVQ	$131, AX
 100c992:	48 c7 c0 83 00 00 00 	mov    $0x83,%rax
	SYSCALL
 100c999:	0f 05                	syscall 
	CMPQ	AX, $0xfffffffffffff001
 100c99b:	48 3d 01 f0 ff ff    	cmp    $0xfffffffffffff001,%rax
	JLS	2(PC)
 100c9a1:	76 05                	jbe    100c9a8 <runtime.sigaltstack+0x20>
	CALL	runtime·notok(SB)
 100c9a3:	e8 4b ff ff ff       	callq  100c8f3 <runtime.notok>
	RET
 100c9a8:	c3                   	retq   

000000000100c9a9 <runtime.settls>:

// set tls base to DI
TEXT runtime·settls(SB),7,$32
 100c9a9:	48 83 ec 20          	sub    $0x20,%rsp
	ADDQ	$16, DI	// ELF wants to use -16(FS), -8(FS)
 100c9ad:	48 83 c7 10          	add    $0x10,%rdi

	MOVQ	DI, SI
 100c9b1:	48 89 fe             	mov    %rdi,%rsi
	MOVQ	$0x1002, DI	// ARCH_SET_FS
 100c9b4:	48 c7 c7 02 10 00 00 	mov    $0x1002,%rdi
	MOVQ	$158, AX	// arch_prctl
 100c9bb:	48 c7 c0 9e 00 00 00 	mov    $0x9e,%rax
	SYSCALL
 100c9c2:	0f 05                	syscall 
	CMPQ	AX, $0xfffffffffffff001
 100c9c4:	48 3d 01 f0 ff ff    	cmp    $0xfffffffffffff001,%rax
	JLS	2(PC)
 100c9ca:	76 05                	jbe    100c9d1 <runtime.settls+0x28>
	CALL	runtime·notok(SB)
 100c9cc:	e8 22 ff ff ff       	callq  100c8f3 <runtime.notok>
	RET
 100c9d1:	48 83 c4 20          	add    $0x20,%rsp
 100c9d5:	c3                   	retq   

000000000100c9d6 <runtime.osyield>:

TEXT runtime·osyield(SB),7,$0
	MOVL	$24, AX
 100c9d6:	b8 18 00 00 00       	mov    $0x18,%eax
	SYSCALL
 100c9db:	0f 05                	syscall 
 100c9dd:	c3                   	retq   

000000000100c9de <futexsleep>:

// Atomically,
//	if(*addr == val) sleep
// Might be woken up spuriously; that's allowed.
static void
futexsleep(uint32 *addr, uint32 val)
 100c9de:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100c9e5:	ff ff 
 100c9e7:	48 3b 21             	cmp    (%rcx),%rsp
 100c9ea:	77 05                	ja     100c9f1 <futexsleep+0x13>
 100c9ec:	e8 64 4f ff ff       	callq  1001955 <runtime.morestack16>
 100c9f1:	48 83 ec 30          	sub    $0x30,%rsp
	// Some Linux kernels have a bug where futex of
	// FUTEX_WAIT returns an internal error code
	// as an errno.  Libpthread ignores the return value
	// here, and so can we: as it says a few lines up,
	// spurious wakeups are allowed.
	runtime·futex(addr, FUTEX_WAIT, val, &longtime, nil, 0);
 100c9f5:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100c9fa:	48 89 04 24          	mov    %rax,(%rsp)
 100c9fe:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
 100ca05:	00 
 100ca06:	8b 44 24 40          	mov    0x40(%rsp),%eax
 100ca0a:	89 44 24 0c          	mov    %eax,0xc(%rsp)
 100ca0e:	b8 60 30 02 01       	mov    $0x1023060,%eax
 100ca13:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100ca18:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
 100ca1f:	00 00 
 100ca21:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%rsp)
 100ca28:	00 
 100ca29:	e8 d1 fe ff ff       	callq  100c8ff <runtime.futex>
 100ca2e:	48 83 c4 30          	add    $0x30,%rsp
 100ca32:	c3                   	retq   

000000000100ca33 <futexwakeup>:
}

// If any procs are sleeping on addr, wake up at most cnt.
static void
futexwakeup(uint32 *addr, uint32 cnt)
 100ca33:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100ca3a:	ff ff 
 100ca3c:	48 3b 21             	cmp    (%rcx),%rsp
 100ca3f:	77 05                	ja     100ca46 <futexwakeup+0x13>
 100ca41:	e8 0f 4f ff ff       	callq  1001955 <runtime.morestack16>
 100ca46:	48 83 ec 40          	sub    $0x40,%rsp
{
	int64 ret;

	ret = runtime·futex(addr, FUTEX_WAKE, cnt, nil, nil, 0);
 100ca4a:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 100ca4f:	48 89 0c 24          	mov    %rcx,(%rsp)
 100ca53:	b9 01 00 00 00       	mov    $0x1,%ecx
 100ca58:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 100ca5c:	8b 4c 24 50          	mov    0x50(%rsp),%ecx
 100ca60:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 100ca64:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 100ca6b:	00 00 
 100ca6d:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
 100ca74:	00 00 
 100ca76:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%rsp)
 100ca7d:	00 
 100ca7e:	e8 7c fe ff ff       	callq  100c8ff <runtime.futex>
 100ca83:	48 63 c0             	movslq %eax,%rax
 100ca86:	48 89 c1             	mov    %rax,%rcx

	if(ret >= 0)
 100ca89:	48 83 f8 00          	cmp    $0x0,%rax
 100ca8d:	7c 05                	jl     100ca94 <futexwakeup+0x61>
		return;
 100ca8f:	48 83 c4 40          	add    $0x40,%rsp
 100ca93:	c3                   	retq   

	// I don't know that futex wakeup can return
	// EAGAIN or EINTR, but if it does, it would be
	// safe to loop and call futex again.
	runtime·printf("futexwakeup addr=%p returned %D\n", addr, ret);
 100ca94:	b8 08 37 02 01       	mov    $0x1023708,%eax
 100ca99:	48 89 04 24          	mov    %rax,(%rsp)
 100ca9d:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 100caa2:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100caa7:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
 100caac:	e8 8d a8 ff ff       	callq  100733e <runtime.printf>
	*(int32*)0x1006 = 0x1006;
 100cab1:	c7 04 25 06 10 00 00 	movl   $0x1006,0x1006
 100cab8:	06 10 00 00 
 100cabc:	48 83 c4 40          	add    $0x40,%rsp
 100cac0:	c3                   	retq   

000000000100cac1 <getproccount>:
}

static int32
getproccount(void)
 100cac1:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100cac8:	ff ff 
 100caca:	48 8d 84 24 30 ff ff 	lea    -0xd0(%rsp),%rax
 100cad1:	ff 
 100cad2:	48 3b 01             	cmp    (%rcx),%rax
 100cad5:	77 05                	ja     100cadc <getproccount+0x1b>
 100cad7:	e8 17 4e ff ff       	callq  10018f3 <runtime.morestack00>
 100cadc:	48 81 ec 50 01 00 00 	sub    $0x150,%rsp
{
	int32 fd, rd, cnt, cpustrlen;
	byte *cpustr, *pos, *bufpos;
	byte buf[256];

	fd = runtime·open((byte*)"/proc/stat", O_RDONLY|O_CLOEXEC, 0);
 100cae3:	b9 29 37 02 01       	mov    $0x1023729,%ecx
 100cae8:	48 89 0c 24          	mov    %rcx,(%rsp)
 100caec:	b9 00 00 08 00       	mov    $0x80000,%ecx
 100caf1:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 100caf5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
 100cafc:	00 
 100cafd:	e8 7b fc ff ff       	callq  100c77d <runtime.open>
	if(fd == -1)
 100cb02:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
 100cb05:	89 84 24 4c 01 00 00 	mov    %eax,0x14c(%rsp)
 100cb0c:	75 0d                	jne    100cb1b <getproccount+0x5a>
		return 1;
 100cb0e:	b8 01 00 00 00       	mov    $0x1,%eax
 100cb13:	48 81 c4 50 01 00 00 	add    $0x150,%rsp
 100cb1a:	c3                   	retq   
	cnt = 0;
 100cb1b:	c7 84 24 44 01 00 00 	movl   $0x0,0x144(%rsp)
 100cb22:	00 00 00 00 
	bufpos = buf;
 100cb26:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100cb2b:	48 89 84 24 28 01 00 	mov    %rax,0x128(%rsp)
 100cb32:	00 
	cpustr = (byte*)"\ncpu";
 100cb33:	b8 34 37 02 01       	mov    $0x1023734,%eax
	cpustrlen = runtime·findnull(cpustr);
 100cb38:	48 89 84 24 38 01 00 	mov    %rax,0x138(%rsp)
 100cb3f:	00 
 100cb40:	48 89 04 24          	mov    %rax,(%rsp)
 100cb44:	e8 83 eb ff ff       	callq  100b6cc <runtime.findnull>
 100cb49:	48 8b 94 24 28 01 00 	mov    0x128(%rsp),%rdx
 100cb50:	00 
 100cb51:	89 c3                	mov    %eax,%ebx
	for(;;) {
		rd = runtime·read(fd, bufpos, sizeof(buf)-cpustrlen);
 100cb53:	8b 8c 24 4c 01 00 00 	mov    0x14c(%rsp),%ecx
 100cb5a:	89 0c 24             	mov    %ecx,(%rsp)
 100cb5d:	48 89 94 24 28 01 00 	mov    %rdx,0x128(%rsp)
 100cb64:	00 
 100cb65:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 100cb6a:	b9 00 01 00 00       	mov    $0x100,%ecx
 100cb6f:	29 d9                	sub    %ebx,%ecx
 100cb71:	89 9c 24 40 01 00 00 	mov    %ebx,0x140(%rsp)
 100cb78:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
 100cb7c:	e8 32 fc ff ff       	callq  100c7b3 <runtime.read>
		if(rd == -1)
 100cb81:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
 100cb84:	75 2c                	jne    100cbb2 <getproccount+0xf1>
		if(rd < cpustrlen)
			break;
		runtime·memmove(buf, bufpos+rd-cpustrlen+1, cpustrlen-1);
		bufpos = buf+cpustrlen-1;
	}
	runtime·close(fd);
 100cb86:	8b 84 24 4c 01 00 00 	mov    0x14c(%rsp),%eax
 100cb8d:	89 04 24             	mov    %eax,(%rsp)
 100cb90:	e8 fd fb ff ff       	callq  100c792 <runtime.close>
 100cb95:	8b 8c 24 44 01 00 00 	mov    0x144(%rsp),%ecx
	return cnt ? cnt : 1;
 100cb9c:	83 f9 00             	cmp    $0x0,%ecx
 100cb9f:	74 0a                	je     100cbab <getproccount+0xea>
 100cba1:	89 c8                	mov    %ecx,%eax
 100cba3:	48 81 c4 50 01 00 00 	add    $0x150,%rsp
 100cbaa:	c3                   	retq   
 100cbab:	b8 01 00 00 00       	mov    $0x1,%eax
 100cbb0:	eb f1                	jmp    100cba3 <getproccount+0xe2>
	cpustrlen = runtime·findnull(cpustr);
	for(;;) {
		rd = runtime·read(fd, bufpos, sizeof(buf)-cpustrlen);
		if(rd == -1)
			break;
		bufpos[rd] = 0;
 100cbb2:	89 84 24 48 01 00 00 	mov    %eax,0x148(%rsp)
 100cbb9:	48 63 c0             	movslq %eax,%rax
 100cbbc:	48 8b 8c 24 28 01 00 	mov    0x128(%rsp),%rcx
 100cbc3:	00 
 100cbc4:	c6 04 01 00          	movb   $0x0,(%rcx,%rax,1)
		for(pos=buf; pos=runtime·strstr(pos, cpustr); cnt++, pos++) {
 100cbc8:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100cbcd:	48 89 c2             	mov    %rax,%rdx
 100cbd0:	48 89 14 24          	mov    %rdx,(%rsp)
 100cbd4:	48 8b 8c 24 38 01 00 	mov    0x138(%rsp),%rcx
 100cbdb:	00 
 100cbdc:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100cbe1:	e8 1f ef ff ff       	callq  100bb05 <runtime.strstr>
 100cbe6:	8b ac 24 48 01 00 00 	mov    0x148(%rsp),%ebp
 100cbed:	8b 9c 24 40 01 00 00 	mov    0x140(%rsp),%ebx
 100cbf4:	48 89 c2             	mov    %rax,%rdx
 100cbf7:	48 83 f8 00          	cmp    $0x0,%rax
 100cbfb:	74 0c                	je     100cc09 <getproccount+0x148>
 100cbfd:	ff 84 24 44 01 00 00 	incl   0x144(%rsp)
 100cc04:	48 ff c2             	inc    %rdx
 100cc07:	eb c7                	jmp    100cbd0 <getproccount+0x10f>
		}
		if(rd < cpustrlen)
 100cc09:	39 dd                	cmp    %ebx,%ebp
 100cc0b:	0f 8c 75 ff ff ff    	jl     100cb86 <getproccount+0xc5>
			break;
		runtime·memmove(buf, bufpos+rd-cpustrlen+1, cpustrlen-1);
 100cc11:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
 100cc16:	48 89 04 24          	mov    %rax,(%rsp)
 100cc1a:	48 63 cd             	movslq %ebp,%rcx
 100cc1d:	48 8b 94 24 28 01 00 	mov    0x128(%rsp),%rdx
 100cc24:	00 
 100cc25:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax
 100cc29:	48 63 cb             	movslq %ebx,%rcx
 100cc2c:	48 29 c8             	sub    %rcx,%rax
 100cc2f:	48 ff c0             	inc    %rax
 100cc32:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100cc37:	89 d8                	mov    %ebx,%eax
 100cc39:	ff c8                	dec    %eax
 100cc3b:	89 44 24 10          	mov    %eax,0x10(%rsp)
 100cc3f:	e8 8e 72 ff ff       	callq  1003ed2 <runtime.memmove>
 100cc44:	8b 9c 24 40 01 00 00 	mov    0x140(%rsp),%ebx
		bufpos = buf+cpustrlen-1;
 100cc4b:	48 63 cb             	movslq %ebx,%rcx
 100cc4e:	48 8d 44 0c 27       	lea    0x27(%rsp,%rcx,1),%rax
 100cc53:	48 89 c2             	mov    %rax,%rdx
	cnt = 0;
	bufpos = buf;
	cpustr = (byte*)"\ncpu";
	cpustrlen = runtime·findnull(cpustr);
	for(;;) {
		rd = runtime·read(fd, bufpos, sizeof(buf)-cpustrlen);
 100cc56:	e9 f8 fe ff ff       	jmpq   100cb53 <getproccount+0x92>

000000000100cc5b <futexlock>:
// Possible lock states are MUTEX_UNLOCKED, MUTEX_LOCKED and MUTEX_SLEEPING.
// MUTEX_SLEEPING means that there is presumably at least one sleeping thread.
// Note that there can be spinning threads during all states - they do not
// affect mutex's state.
static void
futexlock(Lock *l)
 100cc5b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100cc62:	ff ff 
 100cc64:	48 3b 21             	cmp    (%rcx),%rsp
 100cc67:	77 05                	ja     100cc6e <futexlock+0x13>
 100cc69:	e8 de 4c ff ff       	callq  100194c <runtime.morestack8>
 100cc6e:	48 83 ec 30          	sub    $0x30,%rsp
{
	uint32 i, v, wait, spin;

	// Speculative grab for lock.
	v = runtime·xchg(&l->key, MUTEX_LOCKED);
 100cc72:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
 100cc77:	48 89 0c 24          	mov    %rcx,(%rsp)
 100cc7b:	b9 01 00 00 00       	mov    $0x1,%ecx
 100cc80:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 100cc84:	e8 5f 4d ff ff       	callq  10019e8 <runtime.xchg>
 100cc89:	8b 1c 25 0c 4e 02 01 	mov    0x1024e0c,%ebx
 100cc90:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
	if(v == MUTEX_UNLOCKED)
 100cc95:	83 f8 00             	cmp    $0x0,%eax
 100cc98:	75 05                	jne    100cc9f <futexlock+0x44>
		return;
 100cc9a:	48 83 c4 30          	add    $0x30,%rsp
 100cc9e:	c3                   	retq   
	// on this mutex.  If we ever change l->key from
	// MUTEX_SLEEPING to some other value, we must be
	// careful to change it back to MUTEX_SLEEPING before
	// returning, to ensure that the sleeping thread gets
	// its wakeup call.
	wait = v;
 100cc9f:	89 44 24 24          	mov    %eax,0x24(%rsp)

	if(proccount == 0)
 100cca3:	83 fb 00             	cmp    $0x0,%ebx
 100cca6:	75 0c                	jne    100ccb4 <futexlock+0x59>
		proccount = getproccount();
 100cca8:	e8 14 fe ff ff       	callq  100cac1 <getproccount>
 100ccad:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 100ccb2:	89 c3                	mov    %eax,%ebx

	// On uniprocessor's, no point spinning.
	// On multiprocessors, spin for ACTIVE_SPIN attempts.
	spin = 0;
 100ccb4:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%rsp)
 100ccbb:	00 
	if(proccount > 1)
 100ccbc:	83 fb 01             	cmp    $0x1,%ebx
 100ccbf:	89 1c 25 0c 4e 02 01 	mov    %ebx,0x1024e0c
 100ccc6:	7e 08                	jle    100ccd0 <futexlock+0x75>
		spin = ACTIVE_SPIN;
 100ccc8:	c7 44 24 20 04 00 00 	movl   $0x4,0x20(%rsp)
 100cccf:	00 

	for(;;) {
		// Try for lock, spinning.
		for(i = 0; i < spin; i++) {
 100ccd0:	31 c9                	xor    %ecx,%ecx
 100ccd2:	89 4c 24 2c          	mov    %ecx,0x2c(%rsp)
 100ccd6:	3b 4c 24 20          	cmp    0x20(%rsp),%ecx
 100ccda:	73 51                	jae    100cd2d <futexlock+0xd2>
			while(l->key == MUTEX_UNLOCKED)
 100ccdc:	8b 02                	mov    (%rdx),%eax
 100ccde:	83 f8 00             	cmp    $0x0,%eax
 100cce1:	75 28                	jne    100cd0b <futexlock+0xb0>
				if(runtime·cas(&l->key, MUTEX_UNLOCKED, wait))
 100cce3:	48 89 14 24          	mov    %rdx,(%rsp)
 100cce7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
 100ccee:	00 
 100ccef:	8b 4c 24 24          	mov    0x24(%rsp),%ecx
 100ccf3:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 100ccf7:	e8 9f 4c ff ff       	callq  100199b <runtime.cas>
 100ccfc:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 100cd01:	80 f8 00             	cmp    $0x0,%al
 100cd04:	74 d6                	je     100ccdc <futexlock+0x81>
						return;
 100cd06:	48 83 c4 30          	add    $0x30,%rsp
 100cd0a:	c3                   	retq   
			runtime·procyield(ACTIVE_SPIN_CNT);
 100cd0b:	b8 1e 00 00 00       	mov    $0x1e,%eax
 100cd10:	89 04 24             	mov    %eax,(%rsp)
 100cd13:	e8 dc 4c ff ff       	callq  10019f4 <runtime.procyield>
 100cd18:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 100cd1d:	8b 4c 24 2c          	mov    0x2c(%rsp),%ecx
	if(proccount > 1)
		spin = ACTIVE_SPIN;

	for(;;) {
		// Try for lock, spinning.
		for(i = 0; i < spin; i++) {
 100cd21:	ff c1                	inc    %ecx
 100cd23:	89 4c 24 2c          	mov    %ecx,0x2c(%rsp)
 100cd27:	3b 4c 24 20          	cmp    0x20(%rsp),%ecx
 100cd2b:	72 af                	jb     100ccdc <futexlock+0x81>
						return;
			runtime·procyield(ACTIVE_SPIN_CNT);
		}

		// Try for lock, rescheduling.
		for(i=0; i < PASSIVE_SPIN; i++) {
 100cd2d:	31 c9                	xor    %ecx,%ecx
 100cd2f:	83 f9 01             	cmp    $0x1,%ecx
 100cd32:	89 4c 24 2c          	mov    %ecx,0x2c(%rsp)
 100cd36:	73 48                	jae    100cd80 <futexlock+0x125>
			while(l->key == MUTEX_UNLOCKED)
 100cd38:	8b 02                	mov    (%rdx),%eax
 100cd3a:	83 f8 00             	cmp    $0x0,%eax
 100cd3d:	75 28                	jne    100cd67 <futexlock+0x10c>
				if(runtime·cas(&l->key, MUTEX_UNLOCKED, wait))
 100cd3f:	48 89 14 24          	mov    %rdx,(%rsp)
 100cd43:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
 100cd4a:	00 
 100cd4b:	8b 4c 24 24          	mov    0x24(%rsp),%ecx
 100cd4f:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
 100cd53:	e8 43 4c ff ff       	callq  100199b <runtime.cas>
 100cd58:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 100cd5d:	80 f8 00             	cmp    $0x0,%al
 100cd60:	74 d6                	je     100cd38 <futexlock+0xdd>
					return;
 100cd62:	48 83 c4 30          	add    $0x30,%rsp
 100cd66:	c3                   	retq   
			runtime·osyield();
 100cd67:	e8 6a fc ff ff       	callq  100c9d6 <runtime.osyield>
 100cd6c:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
 100cd71:	8b 4c 24 2c          	mov    0x2c(%rsp),%ecx
						return;
			runtime·procyield(ACTIVE_SPIN_CNT);
		}

		// Try for lock, rescheduling.
		for(i=0; i < PASSIVE_SPIN; i++) {
 100cd75:	ff c1                	inc    %ecx
 100cd77:	83 f9 01             	cmp    $0x1,%ecx
 100cd7a:	89 4c 24 2c          	mov    %ecx,0x2c(%rsp)
 100cd7e:	72 b8                	jb     100cd38 <futexlock+0xdd>
					return;
			runtime·osyield();
		}

		// Sleep.
		v = runtime·xchg(&l->key, MUTEX_SLEEPING);
 100cd80:	48 89 14 24          	mov    %rdx,(%rsp)
 100cd84:	b9 02 00 00 00       	mov    $0x2,%ecx
 100cd89:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
 100cd8d:	e8 56 4c ff ff       	callq  10019e8 <runtime.xchg>
		if(v == MUTEX_UNLOCKED)
 100cd92:	83 f8 00             	cmp    $0x0,%eax
 100cd95:	75 05                	jne    100cd9c <futexlock+0x141>
			return;
 100cd97:	48 83 c4 30          	add    $0x30,%rsp
 100cd9b:	c3                   	retq   
		wait = MUTEX_SLEEPING;
 100cd9c:	c7 44 24 24 02 00 00 	movl   $0x2,0x24(%rsp)
 100cda3:	00 
		futexsleep(&l->key, MUTEX_SLEEPING);
 100cda4:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
 100cda9:	48 89 04 24          	mov    %rax,(%rsp)
 100cdad:	b8 02 00 00 00       	mov    $0x2,%eax
 100cdb2:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100cdb6:	e8 23 fc ff ff       	callq  100c9de <futexsleep>
 100cdbb:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
	if(proccount > 1)
		spin = ACTIVE_SPIN;

	for(;;) {
		// Try for lock, spinning.
		for(i = 0; i < spin; i++) {
 100cdc0:	e9 0b ff ff ff       	jmpq   100ccd0 <futexlock+0x75>

000000000100cdc5 <futexunlock>:
		futexsleep(&l->key, MUTEX_SLEEPING);
	}
}

static void
futexunlock(Lock *l)
 100cdc5:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100cdcc:	ff ff 
 100cdce:	48 3b 21             	cmp    (%rcx),%rsp
 100cdd1:	77 05                	ja     100cdd8 <futexunlock+0x13>
 100cdd3:	e8 74 4b ff ff       	callq  100194c <runtime.morestack8>
 100cdd8:	48 83 ec 28          	sub    $0x28,%rsp
{
	uint32 v;

	v = runtime·xchg(&l->key, MUTEX_UNLOCKED);
 100cddc:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 100cde1:	48 89 0c 24          	mov    %rcx,(%rsp)
 100cde5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
 100cdec:	00 
 100cded:	e8 f6 4b ff ff       	callq  10019e8 <runtime.xchg>
 100cdf2:	89 c1                	mov    %eax,%ecx
	if(v == MUTEX_UNLOCKED)
 100cdf4:	83 f8 00             	cmp    $0x0,%eax
 100cdf7:	89 44 24 24          	mov    %eax,0x24(%rsp)
 100cdfb:	75 12                	jne    100ce0f <futexunlock+0x4a>
		runtime·throw("unlock of unlocked lock");
 100cdfd:	b8 39 37 02 01       	mov    $0x1023739,%eax
 100ce02:	48 89 04 24          	mov    %rax,(%rsp)
 100ce06:	e8 2e cf ff ff       	callq  1009d39 <runtime.throw>
 100ce0b:	8b 4c 24 24          	mov    0x24(%rsp),%ecx
	if(v == MUTEX_SLEEPING)
 100ce0f:	83 f9 02             	cmp    $0x2,%ecx
 100ce12:	75 17                	jne    100ce2b <futexunlock+0x66>
		futexwakeup(&l->key, 1);
 100ce14:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100ce19:	48 89 04 24          	mov    %rax,(%rsp)
 100ce1d:	b8 01 00 00 00       	mov    $0x1,%eax
 100ce22:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100ce26:	e8 08 fc ff ff       	callq  100ca33 <futexwakeup>
 100ce2b:	48 83 c4 28          	add    $0x28,%rsp
 100ce2f:	c3                   	retq   

000000000100ce30 <runtime.lock>:
}

void
runtime·lock(Lock *l)
 100ce30:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100ce37:	ff ff 
 100ce39:	48 3b 21             	cmp    (%rcx),%rsp
 100ce3c:	77 05                	ja     100ce43 <runtime.lock+0x13>
 100ce3e:	e8 09 4b ff ff       	callq  100194c <runtime.morestack8>
 100ce43:	48 83 ec 10          	sub    $0x10,%rsp
{
	if(m->locks++ < 0)
 100ce47:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 100ce4e:	ff ff 
 100ce50:	8b 81 84 00 00 00    	mov    0x84(%rcx),%eax
 100ce56:	ff 81 84 00 00 00    	incl   0x84(%rcx)
 100ce5c:	83 f8 00             	cmp    $0x0,%eax
 100ce5f:	7d 0e                	jge    100ce6f <runtime.lock+0x3f>
		runtime·throw("runtime·lock: lock count");
 100ce61:	b8 51 37 02 01       	mov    $0x1023751,%eax
 100ce66:	48 89 04 24          	mov    %rax,(%rsp)
 100ce6a:	e8 ca ce ff ff       	callq  1009d39 <runtime.throw>
	futexlock(l);
 100ce6f:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 100ce74:	48 89 04 24          	mov    %rax,(%rsp)
 100ce78:	e8 de fd ff ff       	callq  100cc5b <futexlock>
 100ce7d:	48 83 c4 10          	add    $0x10,%rsp
 100ce81:	c3                   	retq   

000000000100ce82 <runtime.unlock>:
}

void
runtime·unlock(Lock *l)
 100ce82:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100ce89:	ff ff 
 100ce8b:	48 3b 21             	cmp    (%rcx),%rsp
 100ce8e:	77 05                	ja     100ce95 <runtime.unlock+0x13>
 100ce90:	e8 b7 4a ff ff       	callq  100194c <runtime.morestack8>
 100ce95:	48 83 ec 10          	sub    $0x10,%rsp
{
	if(--m->locks < 0)
 100ce99:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 100cea0:	ff ff 
 100cea2:	ff 89 84 00 00 00    	decl   0x84(%rcx)
 100cea8:	8b 81 84 00 00 00    	mov    0x84(%rcx),%eax
 100ceae:	83 f8 00             	cmp    $0x0,%eax
 100ceb1:	7d 0e                	jge    100cec1 <runtime.unlock+0x3f>
		runtime·throw("runtime·unlock: lock count");
 100ceb3:	b8 6b 37 02 01       	mov    $0x102376b,%eax
 100ceb8:	48 89 04 24          	mov    %rax,(%rsp)
 100cebc:	e8 78 ce ff ff       	callq  1009d39 <runtime.throw>
	futexunlock(l);
 100cec1:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
 100cec6:	48 89 04 24          	mov    %rax,(%rsp)
 100ceca:	e8 f6 fe ff ff       	callq  100cdc5 <futexunlock>
 100cecf:	48 83 c4 10          	add    $0x10,%rsp
 100ced3:	c3                   	retq   

000000000100ced4 <runtime.noteclear>:
}


// One-time notifications.
void
runtime·noteclear(Note *n)
 100ced4:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100cedb:	ff ff 
 100cedd:	48 3b 21             	cmp    (%rcx),%rsp
 100cee0:	77 05                	ja     100cee7 <runtime.noteclear+0x13>
 100cee2:	e8 65 4a ff ff       	callq  100194c <runtime.morestack8>
{
	n->state = 0;
 100cee7:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
 100ceec:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
 100cef2:	c3                   	retq   

000000000100cef3 <runtime.notewakeup>:
}

void
runtime·notewakeup(Note *n)
 100cef3:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100cefa:	ff ff 
 100cefc:	48 3b 21             	cmp    (%rcx),%rsp
 100ceff:	77 05                	ja     100cf06 <runtime.notewakeup+0x13>
 100cf01:	e8 46 4a ff ff       	callq  100194c <runtime.morestack8>
 100cf06:	48 83 ec 18          	sub    $0x18,%rsp
{
	runtime·xchg(&n->state, 1);
 100cf0a:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100cf0f:	48 89 04 24          	mov    %rax,(%rsp)
 100cf13:	b8 01 00 00 00       	mov    $0x1,%eax
 100cf18:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100cf1c:	e8 c7 4a ff ff       	callq  10019e8 <runtime.xchg>
	futexwakeup(&n->state, 1<<30);
 100cf21:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100cf26:	48 89 04 24          	mov    %rax,(%rsp)
 100cf2a:	b8 00 00 00 40       	mov    $0x40000000,%eax
 100cf2f:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100cf33:	e8 fb fa ff ff       	callq  100ca33 <futexwakeup>
 100cf38:	48 83 c4 18          	add    $0x18,%rsp
 100cf3c:	c3                   	retq   

000000000100cf3d <runtime.notesleep>:
}

void
runtime·notesleep(Note *n)
 100cf3d:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100cf44:	ff ff 
 100cf46:	48 3b 21             	cmp    (%rcx),%rsp
 100cf49:	77 05                	ja     100cf50 <runtime.notesleep+0x13>
 100cf4b:	e8 fc 49 ff ff       	callq  100194c <runtime.morestack8>
 100cf50:	48 83 ec 18          	sub    $0x18,%rsp
{
	while(runtime·atomicload(&n->state) == 0)
 100cf54:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
 100cf59:	48 89 0c 24          	mov    %rcx,(%rsp)
 100cf5d:	e8 77 4b ff ff       	callq  1001ad9 <runtime.atomicload>
 100cf62:	83 f8 00             	cmp    $0x0,%eax
 100cf65:	75 18                	jne    100cf7f <runtime.notesleep+0x42>
		futexsleep(&n->state, 0);
 100cf67:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
 100cf6c:	48 89 04 24          	mov    %rax,(%rsp)
 100cf70:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
 100cf77:	00 
 100cf78:	e8 61 fa ff ff       	callq  100c9de <futexsleep>
}

void
runtime·notesleep(Note *n)
{
	while(runtime·atomicload(&n->state) == 0)
 100cf7d:	eb d5                	jmp    100cf54 <runtime.notesleep+0x17>
		futexsleep(&n->state, 0);
 100cf7f:	48 83 c4 18          	add    $0x18,%rsp
 100cf83:	c3                   	retq   

000000000100cf84 <runtime.newosproc>:
	CLONE_NEWUTS = 0x4000000,
	CLONE_NEWIPC = 0x8000000,
};

void
runtime·newosproc(M *m, G *g, void *stk, void (*fn)(void))
 100cf84:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100cf8b:	ff ff 
 100cf8d:	48 3b 21             	cmp    (%rcx),%rsp
 100cf90:	77 05                	ja     100cf97 <runtime.newosproc+0x13>
 100cf92:	e8 d0 49 ff ff       	callq  1001967 <runtime.morestack32>
 100cf97:	48 83 ec 58          	sub    $0x58,%rsp
 100cf9b:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
	int32 flags;

	/*
	 * note: strace gets confused if we use CLONE_PTRACE here.
	 */
	flags = CLONE_VM	/* share memory */
 100cfa0:	bb 00 0f 01 00       	mov    $0x10f00,%ebx
		| CLONE_FILES	/* share fd table */
		| CLONE_SIGHAND	/* share sig handler table */
		| CLONE_THREAD	/* revisit - okay for now */
		;

	m->tls[0] = m->id;	// so 386 asm can find it
 100cfa5:	8b 4a 78             	mov    0x78(%rdx),%ecx
 100cfa8:	89 4a 50             	mov    %ecx,0x50(%rdx)
	if(0){
		runtime·printf("newosproc stk=%p m=%p g=%p fn=%p clone=%p id=%d/%d ostk=%p\n",
			stk, m, g, fn, runtime·clone, m->id, m->tls[0], &m);
	}

	if((ret = runtime·clone(flags, stk, m, g, fn)) < 0) {
 100cfab:	89 1c 24             	mov    %ebx,(%rsp)
 100cfae:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
 100cfb3:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100cfb8:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
 100cfbd:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
 100cfc2:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 100cfc7:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
 100cfcc:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 100cfd1:	e8 4d f9 ff ff       	callq  100c923 <runtime.clone>
 100cfd6:	89 44 24 54          	mov    %eax,0x54(%rsp)
 100cfda:	83 f8 00             	cmp    $0x0,%eax
 100cfdd:	7d 37                	jge    100d016 <runtime.newosproc+0x92>
		runtime·printf("runtime: failed to create new OS thread (have %d already; errno=%d)\n", runtime·mcount(), -ret);
 100cfdf:	e8 70 c9 ff ff       	callq  1009954 <runtime.mcount>
 100cfe4:	89 44 24 44          	mov    %eax,0x44(%rsp)
 100cfe8:	b8 87 37 02 01       	mov    $0x1023787,%eax
 100cfed:	48 89 04 24          	mov    %rax,(%rsp)
 100cff1:	8b 44 24 44          	mov    0x44(%rsp),%eax
 100cff5:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100cff9:	8b 44 24 54          	mov    0x54(%rsp),%eax
 100cffd:	f7 d8                	neg    %eax
 100cfff:	89 44 24 0c          	mov    %eax,0xc(%rsp)
 100d003:	e8 36 a3 ff ff       	callq  100733e <runtime.printf>
		runtime·throw("runtime.newosproc");
 100d008:	b8 cc 37 02 01       	mov    $0x10237cc,%eax
 100d00d:	48 89 04 24          	mov    %rax,(%rsp)
 100d011:	e8 23 cd ff ff       	callq  1009d39 <runtime.throw>
 100d016:	48 83 c4 58          	add    $0x58,%rsp
 100d01a:	c3                   	retq   

000000000100d01b <runtime.osinit>:
	}
}

void
runtime·osinit(void)
 100d01b:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100d022:	ff ff 
 100d024:	48 3b 21             	cmp    (%rcx),%rsp
 100d027:	77 05                	ja     100d02e <runtime.osinit+0x13>
 100d029:	e8 c5 48 ff ff       	callq  10018f3 <runtime.morestack00>
{
}
 100d02e:	c3                   	retq   

000000000100d02f <runtime.goenvs>:

void
runtime·goenvs(void)
 100d02f:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100d036:	ff ff 
 100d038:	48 3b 21             	cmp    (%rcx),%rsp
 100d03b:	77 05                	ja     100d042 <runtime.goenvs+0x13>
 100d03d:	e8 b1 48 ff ff       	callq  10018f3 <runtime.morestack00>
{
	runtime·goenvs_unix();
 100d042:	e8 b0 cf ff ff       	callq  1009ff7 <runtime.goenvs_unix>
 100d047:	c3                   	retq   

000000000100d048 <runtime.minit>:
}

// Called to initialize a new m (including the bootstrap m).
void
runtime·minit(void)
 100d048:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100d04f:	ff ff 
 100d051:	48 3b 21             	cmp    (%rcx),%rsp
 100d054:	77 05                	ja     100d05b <runtime.minit+0x13>
 100d056:	e8 98 48 ff ff       	callq  10018f3 <runtime.morestack00>
 100d05b:	48 83 ec 18          	sub    $0x18,%rsp
{
	// Initialize signal handling.
	m->gsignal = runtime·malg(32*1024);	// OS X wants >=8K, Linux >=2K
 100d05f:	b9 00 80 00 00       	mov    $0x8000,%ecx
 100d064:	89 0c 24             	mov    %ecx,(%rsp)
 100d067:	e8 6b c1 ff ff       	callq  10091d7 <runtime.malg>
 100d06c:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
 100d073:	ff ff 
 100d075:	48 89 41 48          	mov    %rax,0x48(%rcx)
	runtime·signalstack(m->gsignal->stackguard - StackGuard, 32*1024);
 100d079:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d080:	ff ff 
 100d082:	48 8b 40 48          	mov    0x48(%rax),%rax
 100d086:	48 8b 00             	mov    (%rax),%rax
 100d089:	48 05 00 ff ff ff    	add    $0xffffffffffffff00,%rax
 100d08f:	48 89 04 24          	mov    %rax,(%rsp)
 100d093:	b8 00 80 00 00       	mov    $0x8000,%eax
 100d098:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100d09c:	e8 4f e2 ff ff       	callq  100b2f0 <runtime.signalstack>
 100d0a1:	48 83 c4 18          	add    $0x18,%rsp
 100d0a5:	c3                   	retq   

000000000100d0a6 <runtime.sigpanic>:
}

void
runtime·sigpanic(void)
 100d0a6:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100d0ad:	ff ff 
 100d0af:	48 3b 21             	cmp    (%rcx),%rsp
 100d0b2:	77 05                	ja     100d0b9 <runtime.sigpanic+0x13>
 100d0b4:	e8 3a 48 ff ff       	callq  10018f3 <runtime.morestack00>
 100d0b9:	48 83 ec 18          	sub    $0x18,%rsp
		case FPE_INTDIV:
			runtime·panicstring("integer divide by zero");
		case FPE_INTOVF:
			runtime·panicstring("integer overflow");
		}
		runtime·panicstring("floating point error");
 100d0bd:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d0c4:	ff ff 
 100d0c6:	8b 80 a8 00 00 00    	mov    0xa8(%rax),%eax
 100d0cc:	83 f8 07             	cmp    $0x7,%eax
 100d0cf:	0f 84 39 01 00 00    	je     100d20e <runtime.sigpanic+0x168>
 100d0d5:	83 f8 08             	cmp    $0x8,%eax
 100d0d8:	0f 84 af 00 00 00    	je     100d18d <runtime.sigpanic+0xe7>
 100d0de:	83 f8 0b             	cmp    $0xb,%eax
 100d0e1:	74 2d                	je     100d110 <runtime.sigpanic+0x6a>
	}
	runtime·panicstring(runtime·sigtab[g->sig].name);
 100d0e3:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d0ea:	ff ff 
 100d0ec:	8b 80 a8 00 00 00    	mov    0xa8(%rax),%eax
 100d0f2:	48 63 c0             	movslq %eax,%rax
 100d0f5:	48 c1 e0 04          	shl    $0x4,%rax
 100d0f9:	48 05 b8 3c 02 01    	add    $0x1023cb8,%rax
 100d0ff:	48 8b 00             	mov    (%rax),%rax
 100d102:	48 89 04 24          	mov    %rax,(%rsp)
 100d106:	e8 8b cc ff ff       	callq  1009d96 <runtime.panicstring>
 100d10b:	48 83 c4 18          	add    $0x18,%rsp
 100d10f:	c3                   	retq   
		if(g->sigcode0 == BUS_ADRERR && g->sigcode1 < 0x1000)
			runtime·panicstring("invalid memory address or nil pointer dereference");
		runtime·printf("unexpected fault address %p\n", g->sigcode1);
		runtime·throw("fault");
	case SIGSEGV:
		if((g->sigcode0 == 0 || g->sigcode0 == SEGV_MAPERR || g->sigcode0 == SEGV_ACCERR) && g->sigcode1 < 0x1000)
 100d110:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d117:	ff ff 
 100d119:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
 100d120:	48 83 f8 00          	cmp    $0x0,%rax
 100d124:	74 1a                	je     100d140 <runtime.sigpanic+0x9a>
 100d126:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d12d:	ff ff 
 100d12f:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
 100d136:	48 83 f8 01          	cmp    $0x1,%rax
 100d13a:	0f 85 af 00 00 00    	jne    100d1ef <runtime.sigpanic+0x149>
 100d140:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d147:	ff ff 
 100d149:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 100d150:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
 100d156:	0f 82 80 00 00 00    	jb     100d1dc <runtime.sigpanic+0x136>
			runtime·panicstring("invalid memory address or nil pointer dereference");
		runtime·printf("unexpected fault address %p\n", g->sigcode1);
 100d15c:	b8 65 38 02 01       	mov    $0x1023865,%eax
 100d161:	48 89 04 24          	mov    %rax,(%rsp)
 100d165:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d16c:	ff ff 
 100d16e:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 100d175:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100d17a:	e8 bf a1 ff ff       	callq  100733e <runtime.printf>
		runtime·throw("fault");
 100d17f:	b8 82 38 02 01       	mov    $0x1023882,%eax
 100d184:	48 89 04 24          	mov    %rax,(%rsp)
 100d188:	e8 ac cb ff ff       	callq  1009d39 <runtime.throw>
	case SIGFPE:
		switch(g->sigcode0) {
		case FPE_INTDIV:
			runtime·panicstring("integer divide by zero");
		case FPE_INTOVF:
			runtime·panicstring("integer overflow");
 100d18d:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d194:	ff ff 
 100d196:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
 100d19d:	48 83 f8 01          	cmp    $0x1,%rax
 100d1a1:	74 29                	je     100d1cc <runtime.sigpanic+0x126>
 100d1a3:	48 83 f8 02          	cmp    $0x2,%rax
 100d1a7:	74 13                	je     100d1bc <runtime.sigpanic+0x116>
		}
		runtime·panicstring("floating point error");
 100d1a9:	b8 b0 38 02 01       	mov    $0x10238b0,%eax
 100d1ae:	48 89 04 24          	mov    %rax,(%rsp)
 100d1b2:	e8 df cb ff ff       	callq  1009d96 <runtime.panicstring>
	}
	runtime·panicstring(runtime·sigtab[g->sig].name);
 100d1b7:	e9 27 ff ff ff       	jmpq   100d0e3 <runtime.sigpanic+0x3d>
	case SIGFPE:
		switch(g->sigcode0) {
		case FPE_INTDIV:
			runtime·panicstring("integer divide by zero");
		case FPE_INTOVF:
			runtime·panicstring("integer overflow");
 100d1bc:	b8 9f 38 02 01       	mov    $0x102389f,%eax
 100d1c1:	48 89 04 24          	mov    %rax,(%rsp)
 100d1c5:	e8 cc cb ff ff       	callq  1009d96 <runtime.panicstring>
		}
		runtime·panicstring("floating point error");
 100d1ca:	eb dd                	jmp    100d1a9 <runtime.sigpanic+0x103>
		runtime·printf("unexpected fault address %p\n", g->sigcode1);
		runtime·throw("fault");
	case SIGFPE:
		switch(g->sigcode0) {
		case FPE_INTDIV:
			runtime·panicstring("integer divide by zero");
 100d1cc:	b8 88 38 02 01       	mov    $0x1023888,%eax
 100d1d1:	48 89 04 24          	mov    %rax,(%rsp)
 100d1d5:	e8 bc cb ff ff       	callq  1009d96 <runtime.panicstring>
		case FPE_INTOVF:
			runtime·panicstring("integer overflow");
 100d1da:	eb e0                	jmp    100d1bc <runtime.sigpanic+0x116>
			runtime·panicstring("invalid memory address or nil pointer dereference");
		runtime·printf("unexpected fault address %p\n", g->sigcode1);
		runtime·throw("fault");
	case SIGSEGV:
		if((g->sigcode0 == 0 || g->sigcode0 == SEGV_MAPERR || g->sigcode0 == SEGV_ACCERR) && g->sigcode1 < 0x1000)
			runtime·panicstring("invalid memory address or nil pointer dereference");
 100d1dc:	b8 33 38 02 01       	mov    $0x1023833,%eax
 100d1e1:	48 89 04 24          	mov    %rax,(%rsp)
 100d1e5:	e8 ac cb ff ff       	callq  1009d96 <runtime.panicstring>
		runtime·printf("unexpected fault address %p\n", g->sigcode1);
 100d1ea:	e9 6d ff ff ff       	jmpq   100d15c <runtime.sigpanic+0xb6>
		if(g->sigcode0 == BUS_ADRERR && g->sigcode1 < 0x1000)
			runtime·panicstring("invalid memory address or nil pointer dereference");
		runtime·printf("unexpected fault address %p\n", g->sigcode1);
		runtime·throw("fault");
	case SIGSEGV:
		if((g->sigcode0 == 0 || g->sigcode0 == SEGV_MAPERR || g->sigcode0 == SEGV_ACCERR) && g->sigcode1 < 0x1000)
 100d1ef:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d1f6:	ff ff 
 100d1f8:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
 100d1ff:	48 83 f8 02          	cmp    $0x2,%rax
 100d203:	0f 85 53 ff ff ff    	jne    100d15c <runtime.sigpanic+0xb6>
 100d209:	e9 32 ff ff ff       	jmpq   100d140 <runtime.sigpanic+0x9a>
void
runtime·sigpanic(void)
{
	switch(g->sig) {
	case SIGBUS:
		if(g->sigcode0 == BUS_ADRERR && g->sigcode1 < 0x1000)
 100d20e:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d215:	ff ff 
 100d217:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
 100d21e:	48 83 f8 02          	cmp    $0x2,%rax
 100d222:	75 18                	jne    100d23c <runtime.sigpanic+0x196>
 100d224:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d22b:	ff ff 
 100d22d:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 100d234:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
 100d23a:	72 36                	jb     100d272 <runtime.sigpanic+0x1cc>
			runtime·panicstring("invalid memory address or nil pointer dereference");
		runtime·printf("unexpected fault address %p\n", g->sigcode1);
 100d23c:	b8 10 38 02 01       	mov    $0x1023810,%eax
 100d241:	48 89 04 24          	mov    %rax,(%rsp)
 100d245:	64 48 8b 04 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rax
 100d24c:	ff ff 
 100d24e:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
 100d255:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100d25a:	e8 df a0 ff ff       	callq  100733e <runtime.printf>
		runtime·throw("fault");
 100d25f:	b8 2d 38 02 01       	mov    $0x102382d,%eax
 100d264:	48 89 04 24          	mov    %rax,(%rsp)
 100d268:	e8 cc ca ff ff       	callq  1009d39 <runtime.throw>
	case SIGSEGV:
		if((g->sigcode0 == 0 || g->sigcode0 == SEGV_MAPERR || g->sigcode0 == SEGV_ACCERR) && g->sigcode1 < 0x1000)
 100d26d:	e9 9e fe ff ff       	jmpq   100d110 <runtime.sigpanic+0x6a>
runtime·sigpanic(void)
{
	switch(g->sig) {
	case SIGBUS:
		if(g->sigcode0 == BUS_ADRERR && g->sigcode1 < 0x1000)
			runtime·panicstring("invalid memory address or nil pointer dereference");
 100d272:	b8 de 37 02 01       	mov    $0x10237de,%eax
 100d277:	48 89 04 24          	mov    %rax,(%rsp)
 100d27b:	e8 16 cb ff ff       	callq  1009d96 <runtime.panicstring>
 100d280:	eb ba                	jmp    100d23c <runtime.sigpanic+0x196>

000000000100d282 <runtime.gentraceback>:
// Generic traceback.  Handles runtime stack prints (pcbuf == nil)
// as well as the runtime.Callers function (pcbuf != nil).
// A little clunky to merge the two but avoids duplicating
// the code and all its subtlety.
int32
runtime·gentraceback(byte *pc0, byte *sp, byte *lr0, G *g, int32 skip, uintptr *pcbuf, int32 max)
 100d282:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100d289:	ff ff 
 100d28b:	48 3b 21             	cmp    (%rcx),%rsp
 100d28e:	77 0a                	ja     100d29a <runtime.gentraceback+0x18>
 100d290:	b8 38 00 00 00       	mov    $0x38,%eax
 100d295:	e8 70 46 ff ff       	callq  100190a <runtime.morestack01>
 100d29a:	48 83 ec 78          	sub    $0x78,%rsp
 100d29e:	48 8b 9c 24 80 00 00 	mov    0x80(%rsp),%rbx
 100d2a5:	00 
 100d2a6:	48 8b 94 24 88 00 00 	mov    0x88(%rsp),%rdx
 100d2ad:	00 
 100d2ae:	48 8b bc 24 98 00 00 	mov    0x98(%rsp),%rdi
 100d2b5:	00 
	Func *f;
	bool waspanic;

	USED(lr0);
	pc = (uintptr)pc0;
	lr = 0;
 100d2b6:	4d 31 c9             	xor    %r9,%r9
 100d2b9:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)
	fp = nil;
 100d2be:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
 100d2c5:	00 00 
	waspanic = false;
 100d2c7:	c6 44 24 2f 00       	movb   $0x0,0x2f(%rsp)
	
	// If the PC is goexit, the goroutine hasn't started yet.
	if(pc0 == g->sched.pc && sp == g->sched.sp && pc0 == (byte*)runtime·goexit) {
 100d2cc:	48 8b 47 28          	mov    0x28(%rdi),%rax
 100d2d0:	48 39 c3             	cmp    %rax,%rbx
 100d2d3:	75 0d                	jne    100d2e2 <runtime.gentraceback+0x60>
 100d2d5:	48 8b 47 20          	mov    0x20(%rdi),%rax
 100d2d9:	48 39 c2             	cmp    %rax,%rdx
 100d2dc:	0f 84 e0 06 00 00    	je     100d9c2 <runtime.gentraceback+0x740>
		pc = (uintptr)g->entry;
	}
	
	// If the PC is zero, it's likely a nil function call.
	// Start in the caller's frame.
	if(pc == 0) {
 100d2e2:	48 83 fb 00          	cmp    $0x0,%rbx
 100d2e6:	75 0b                	jne    100d2f3 <runtime.gentraceback+0x71>
		pc = lr;
 100d2e8:	4c 89 cb             	mov    %r9,%rbx
		lr = 0;
 100d2eb:	4d 31 c9             	xor    %r9,%r9
 100d2ee:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)
	}

	// If the PC is zero, it's likely a nil function call.
	// Start in the caller's frame.
	if(pc == 0) {
 100d2f3:	48 83 fb 00          	cmp    $0x0,%rbx
 100d2f7:	75 0f                	jne    100d308 <runtime.gentraceback+0x86>
		pc = *(uintptr*)sp;
 100d2f9:	48 8b 1a             	mov    (%rdx),%rbx
		sp += sizeof(uintptr);
 100d2fc:	48 83 c2 08          	add    $0x8,%rdx
 100d300:	48 89 94 24 88 00 00 	mov    %rdx,0x88(%rsp)
 100d307:	00 
	}

	n = 0;
 100d308:	c7 44 24 68 00 00 00 	movl   $0x0,0x68(%rsp)
 100d30f:	00 
	sawnewstack = 0;
 100d310:	c7 44 24 60 00 00 00 	movl   $0x0,0x60(%rsp)
 100d317:	00 
	stk = (Stktop*)g->stackbase;
 100d318:	4c 8b 47 08          	mov    0x8(%rdi),%r8
 100d31c:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
	for(iter = 0; iter < 100 && n < max; iter++) {	// iter avoids looping forever
 100d321:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%rsp)
 100d328:	00 
 100d329:	83 7c 24 64 64       	cmpl   $0x64,0x64(%rsp)
 100d32e:	7d 11                	jge    100d341 <runtime.gentraceback+0xbf>
 100d330:	8b 44 24 68          	mov    0x68(%rsp),%eax
 100d334:	3b 84 24 b0 00 00 00 	cmp    0xb0(%rsp),%eax
 100d33b:	0f 8c f2 00 00 00    	jl     100d433 <runtime.gentraceback+0x1b1>
		lr = 0;
		sp = fp;
		fp = nil;
	}
	
	if(pcbuf == nil && (pc = g->gopc) != 0 && (f = runtime·findfunc(pc)) != nil) {
 100d341:	48 83 bc 24 a8 00 00 	cmpq   $0x0,0xa8(%rsp)
 100d348:	00 00 
 100d34a:	75 0d                	jne    100d359 <runtime.gentraceback+0xd7>
 100d34c:	48 8b 87 c8 00 00 00 	mov    0xc8(%rdi),%rax
 100d353:	48 83 f8 00          	cmp    $0x0,%rax
 100d357:	75 09                	jne    100d362 <runtime.gentraceback+0xe0>
		if(n > 0 && pc > f->entry)
			tracepc--;
		runtime·printf(" %S:%d\n", f->src, runtime·funcline(f, tracepc));
	}
		
	return n;
 100d359:	8b 44 24 68          	mov    0x68(%rsp),%eax
 100d35d:	48 83 c4 78          	add    $0x78,%rsp
 100d361:	c3                   	retq   
		lr = 0;
		sp = fp;
		fp = nil;
	}
	
	if(pcbuf == nil && (pc = g->gopc) != 0 && (f = runtime·findfunc(pc)) != nil) {
 100d362:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
 100d367:	48 89 04 24          	mov    %rax,(%rsp)
 100d36b:	e8 88 f2 ff ff       	callq  100c5f8 <runtime.findfunc>
 100d370:	48 89 c2             	mov    %rax,%rdx
 100d373:	48 83 f8 00          	cmp    $0x0,%rax
 100d377:	74 e0                	je     100d359 <runtime.gentraceback+0xd7>
		runtime·printf("----- goroutine created by -----\n%S", f->name);
 100d379:	b8 6c 32 02 01       	mov    $0x102326c,%eax
 100d37e:	48 89 04 24          	mov    %rax,(%rsp)
 100d382:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
 100d387:	48 8b 02             	mov    (%rdx),%rax
 100d38a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100d38f:	48 8b 42 08          	mov    0x8(%rdx),%rax
 100d393:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100d398:	e8 a1 9f ff ff       	callq  100733e <runtime.printf>
 100d39d:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 100d3a2:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
		if(pc > f->entry)
 100d3a7:	48 8b 43 40          	mov    0x40(%rbx),%rax
 100d3ab:	48 39 c5             	cmp    %rax,%rbp
 100d3ae:	76 27                	jbe    100d3d7 <runtime.gentraceback+0x155>
			runtime·printf("+%p", (uintptr)(pc - f->entry));
 100d3b0:	b8 90 32 02 01       	mov    $0x1023290,%eax
 100d3b5:	48 89 04 24          	mov    %rax,(%rsp)
 100d3b9:	48 8b 43 40          	mov    0x40(%rbx),%rax
 100d3bd:	48 89 e9             	mov    %rbp,%rcx
 100d3c0:	48 29 c1             	sub    %rax,%rcx
 100d3c3:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100d3c8:	e8 71 9f ff ff       	callq  100733e <runtime.printf>
 100d3cd:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 100d3d2:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
		tracepc = pc;	// back up to CALL instruction for funcline.
 100d3d7:	48 89 ea             	mov    %rbp,%rdx
		if(n > 0 && pc > f->entry)
 100d3da:	83 7c 24 68 00       	cmpl   $0x0,0x68(%rsp)
 100d3df:	7e 09                	jle    100d3ea <runtime.gentraceback+0x168>
 100d3e1:	48 8b 43 40          	mov    0x40(%rbx),%rax
 100d3e5:	48 39 c5             	cmp    %rax,%rbp
 100d3e8:	77 44                	ja     100d42e <runtime.gentraceback+0x1ac>
			tracepc--;
		runtime·printf(" %S:%d\n", f->src, runtime·funcline(f, tracepc));
 100d3ea:	48 89 1c 24          	mov    %rbx,(%rsp)
 100d3ee:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 100d3f3:	e8 0e f0 ff ff       	callq  100c406 <runtime.funcline>
 100d3f8:	89 44 24 24          	mov    %eax,0x24(%rsp)
 100d3fc:	b8 94 32 02 01       	mov    $0x1023294,%eax
 100d401:	48 89 04 24          	mov    %rax,(%rsp)
 100d405:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 100d40a:	48 8b 41 20          	mov    0x20(%rcx),%rax
 100d40e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100d413:	48 8b 41 28          	mov    0x28(%rcx),%rax
 100d417:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100d41c:	8b 44 24 24          	mov    0x24(%rsp),%eax
 100d420:	89 44 24 18          	mov    %eax,0x18(%rsp)
 100d424:	e8 15 9f ff ff       	callq  100733e <runtime.printf>
	}
		
	return n;
 100d429:	e9 2b ff ff ff       	jmpq   100d359 <runtime.gentraceback+0xd7>
		runtime·printf("----- goroutine created by -----\n%S", f->name);
		if(pc > f->entry)
			runtime·printf("+%p", (uintptr)(pc - f->entry));
		tracepc = pc;	// back up to CALL instruction for funcline.
		if(n > 0 && pc > f->entry)
			tracepc--;
 100d42e:	48 ff ca             	dec    %rdx
		runtime·printf(" %S:%d\n", f->src, runtime·funcline(f, tracepc));
 100d431:	eb b7                	jmp    100d3ea <runtime.gentraceback+0x168>
		//	sp is the stack pointer at that program counter.
		//	fp is the frame pointer (caller's stack pointer) at that program counter, or nil if unknown.
		//	stk is the stack containing sp.
		//	The caller's program counter is lr, unless lr is zero, in which case it is *(uintptr*)sp.
	
		if(pc == (uintptr)runtime·lessstack) {
 100d433:	48 81 fb c4 18 00 01 	cmp    $0x10018c4,%rbx
 100d43a:	75 70                	jne    100d4ac <runtime.gentraceback+0x22a>
			// Hit top of stack segment.  Unwind to next segment.
			pc = (uintptr)stk->gobuf.pc;
 100d43c:	49 8b 58 18          	mov    0x18(%r8),%rbx
 100d440:	48 89 5c 24 58       	mov    %rbx,0x58(%rsp)
			sp = stk->gobuf.sp;
 100d445:	49 8b 50 10          	mov    0x10(%r8),%rdx
 100d449:	48 89 94 24 88 00 00 	mov    %rdx,0x88(%rsp)
 100d450:	00 
			lr = 0;
 100d451:	4d 31 c9             	xor    %r9,%r9
 100d454:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)
			fp = nil;
 100d459:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
 100d460:	00 00 
			if(pcbuf == nil)
 100d462:	48 83 bc 24 a8 00 00 	cmpq   $0x0,0xa8(%rsp)
 100d469:	00 00 
 100d46b:	75 2d                	jne    100d49a <runtime.gentraceback+0x218>
				runtime·printf("----- stack segment boundary -----\n");
 100d46d:	b8 c8 31 02 01       	mov    $0x10231c8,%eax
 100d472:	48 89 04 24          	mov    %rax,(%rsp)
 100d476:	e8 c3 9e ff ff       	callq  100733e <runtime.printf>
 100d47b:	4c 8b 4c 24 50       	mov    0x50(%rsp),%r9
 100d480:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
 100d485:	48 8b 94 24 88 00 00 	mov    0x88(%rsp),%rdx
 100d48c:	00 
 100d48d:	48 8b bc 24 98 00 00 	mov    0x98(%rsp),%rdi
 100d494:	00 
 100d495:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
			stk = (Stktop*)stk->stackbase;
 100d49a:	4d 8b 40 08          	mov    0x8(%r8),%r8
 100d49e:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
	}

	n = 0;
	sawnewstack = 0;
	stk = (Stktop*)g->stackbase;
	for(iter = 0; iter < 100 && n < max; iter++) {	// iter avoids looping forever
 100d4a3:	ff 44 24 64          	incl   0x64(%rsp)
 100d4a7:	e9 7d fe ff ff       	jmpq   100d329 <runtime.gentraceback+0xa7>
			if(pcbuf == nil)
				runtime·printf("----- stack segment boundary -----\n");
			stk = (Stktop*)stk->stackbase;
			continue;
		}
		if(pc <= 0x1000 || (f = runtime·findfunc(pc)) == nil) {
 100d4ac:	48 81 fb 00 10 00 00 	cmp    $0x1000,%rbx
 100d4b3:	0f 86 3b 04 00 00    	jbe    100d8f4 <runtime.gentraceback+0x672>
 100d4b9:	48 89 5c 24 58       	mov    %rbx,0x58(%rsp)
 100d4be:	48 89 1c 24          	mov    %rbx,(%rsp)
 100d4c2:	e8 31 f1 ff ff       	callq  100c5f8 <runtime.findfunc>
 100d4c7:	4c 8b 4c 24 50       	mov    0x50(%rsp),%r9
 100d4cc:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
 100d4d1:	48 8b 94 24 88 00 00 	mov    0x88(%rsp),%rdx
 100d4d8:	00 
 100d4d9:	48 8b bc 24 98 00 00 	mov    0x98(%rsp),%rdi
 100d4e0:	00 
 100d4e1:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
 100d4e6:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
 100d4eb:	48 89 c5             	mov    %rax,%rbp
 100d4ee:	48 83 f8 00          	cmp    $0x0,%rax
 100d4f2:	0f 84 fc 03 00 00    	je     100d8f4 <runtime.gentraceback+0x672>
			// Unknown pc: stop.
			break;
		}

		// Found an actual function.
		if(fp == nil) {
 100d4f8:	48 83 fe 00          	cmp    $0x0,%rsi
 100d4fc:	0f 85 db 03 00 00    	jne    100d8dd <runtime.gentraceback+0x65b>
			fp = sp;
 100d502:	48 89 d6             	mov    %rdx,%rsi
			if(pc > f->entry && f->frame >= sizeof(uintptr))
 100d505:	48 8b 45 40          	mov    0x40(%rbp),%rax
 100d509:	48 39 c3             	cmp    %rax,%rbx
 100d50c:	76 0c                	jbe    100d51a <runtime.gentraceback+0x298>
 100d50e:	8b 45 54             	mov    0x54(%rbp),%eax
 100d511:	83 f8 08             	cmp    $0x8,%eax
 100d514:	0f 8d b2 03 00 00    	jge    100d8cc <runtime.gentraceback+0x64a>
				fp += f->frame - sizeof(uintptr);
			if(lr == 0)
 100d51a:	49 83 f9 00          	cmp    $0x0,%r9
 100d51e:	75 08                	jne    100d528 <runtime.gentraceback+0x2a6>
				lr = *(uintptr*)fp;
 100d520:	4c 8b 0e             	mov    (%rsi),%r9
 100d523:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)
			fp += sizeof(uintptr);
 100d528:	48 83 c6 08          	add    $0x8,%rsi
 100d52c:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
		} else if(lr == 0)
			lr = *(uintptr*)fp;

		if(skip > 0)
 100d531:	83 bc 24 a0 00 00 00 	cmpl   $0x0,0xa0(%rsp)
 100d538:	00 
 100d539:	0f 8e e8 01 00 00    	jle    100d727 <runtime.gentraceback+0x4a5>
			skip--;
 100d53f:	ff 8c 24 a0 00 00 00 	decl   0xa0(%rsp)
			}
			runtime·prints(")\n");
			n++;
		}
		
		waspanic = f->entry == (uintptr)runtime·sigpanic;
 100d546:	48 8b 45 40          	mov    0x40(%rbp),%rax
 100d54a:	48 3d a6 d0 00 01    	cmp    $0x100d0a6,%rax
 100d550:	0f 85 ca 01 00 00    	jne    100d720 <runtime.gentraceback+0x49e>
 100d556:	b8 01 00 00 00       	mov    $0x1,%eax
 100d55b:	88 44 24 2f          	mov    %al,0x2f(%rsp)

		if(f->entry == (uintptr)runtime·deferproc || f->entry == (uintptr)runtime·newproc)
 100d55f:	48 8b 45 40          	mov    0x40(%rbp),%rax
 100d563:	48 3d 65 94 00 01    	cmp    $0x1009465,%rax
 100d569:	0f 84 a8 01 00 00    	je     100d717 <runtime.gentraceback+0x495>
 100d56f:	48 8b 45 40          	mov    0x40(%rbp),%rax
 100d573:	48 3d c6 92 00 01    	cmp    $0x10092c6,%rax
 100d579:	0f 84 98 01 00 00    	je     100d717 <runtime.gentraceback+0x495>
			fp += 2*sizeof(uintptr);

		if(f->entry == (uintptr)runtime·newstack)
 100d57f:	48 8b 45 40          	mov    0x40(%rbp),%rax
 100d583:	48 3d f2 8e 00 01    	cmp    $0x1008ef2,%rax
 100d589:	75 08                	jne    100d593 <runtime.gentraceback+0x311>
			sawnewstack = 1;
 100d58b:	c7 44 24 60 01 00 00 	movl   $0x1,0x60(%rsp)
 100d592:	00 

		if(pcbuf == nil && f->entry == (uintptr)runtime·morestack && g == m->g0 && sawnewstack) {
 100d593:	48 83 bc 24 a8 00 00 	cmpq   $0x0,0xa8(%rsp)
 100d59a:	00 00 
 100d59c:	75 10                	jne    100d5ae <runtime.gentraceback+0x32c>
 100d59e:	48 8b 45 40          	mov    0x40(%rbp),%rax
 100d5a2:	48 3d fe 17 00 01    	cmp    $0x10017fe,%rax
 100d5a8:	0f 84 b2 00 00 00    	je     100d660 <runtime.gentraceback+0x3de>
			g = m->curg;
			stk = (Stktop*)g->stackbase;
			continue;
		}

		if(pcbuf == nil && f->entry == (uintptr)runtime·lessstack && g == m->g0) {
 100d5ae:	48 83 bc 24 a8 00 00 	cmpq   $0x0,0xa8(%rsp)
 100d5b5:	00 00 
 100d5b7:	75 0c                	jne    100d5c5 <runtime.gentraceback+0x343>
 100d5b9:	48 8b 45 40          	mov    0x40(%rbp),%rax
 100d5bd:	48 3d c4 18 00 01    	cmp    $0x10018c4,%rax
 100d5c3:	74 24                	je     100d5e9 <runtime.gentraceback+0x367>
			lr = 0;
			continue;
		}

		// Unwind to next frame.
		pc = lr;
 100d5c5:	4c 89 cb             	mov    %r9,%rbx
		lr = 0;
 100d5c8:	4d 31 c9             	xor    %r9,%r9
 100d5cb:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)
		sp = fp;
 100d5d0:	48 89 f2             	mov    %rsi,%rdx
 100d5d3:	48 89 b4 24 88 00 00 	mov    %rsi,0x88(%rsp)
 100d5da:	00 
		fp = nil;
 100d5db:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
 100d5e2:	00 00 
	}

	n = 0;
	sawnewstack = 0;
	stk = (Stktop*)g->stackbase;
	for(iter = 0; iter < 100 && n < max; iter++) {	// iter avoids looping forever
 100d5e4:	e9 ba fe ff ff       	jmpq   100d4a3 <runtime.gentraceback+0x221>
			g = m->curg;
			stk = (Stktop*)g->stackbase;
			continue;
		}

		if(pcbuf == nil && f->entry == (uintptr)runtime·lessstack && g == m->g0) {
 100d5e9:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d5f0:	ff ff 
 100d5f2:	48 8b 00             	mov    (%rax),%rax
 100d5f5:	48 39 c7             	cmp    %rax,%rdi
 100d5f8:	75 cb                	jne    100d5c5 <runtime.gentraceback+0x343>
			// Lessstack is running on scheduler stack.  Switch to original goroutine.
			runtime·printf("----- lessstack called from goroutine %d -----\n", m->curg->goid);
 100d5fa:	b8 3c 32 02 01       	mov    $0x102323c,%eax
 100d5ff:	48 89 04 24          	mov    %rax,(%rsp)
 100d603:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d60a:	ff ff 
 100d60c:	48 8b 40 70          	mov    0x70(%rax),%rax
 100d610:	8b 40 74             	mov    0x74(%rax),%eax
 100d613:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100d617:	e8 22 9d ff ff       	callq  100733e <runtime.printf>
			g = m->curg;
 100d61c:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d623:	ff ff 
 100d625:	48 8b 78 70          	mov    0x70(%rax),%rdi
			stk = (Stktop*)g->stackbase;
 100d629:	48 89 bc 24 98 00 00 	mov    %rdi,0x98(%rsp)
 100d630:	00 
 100d631:	4c 8b 47 08          	mov    0x8(%rdi),%r8
			sp = stk->gobuf.sp;
 100d635:	49 8b 50 10          	mov    0x10(%r8),%rdx
 100d639:	48 89 94 24 88 00 00 	mov    %rdx,0x88(%rsp)
 100d640:	00 
			pc = (uintptr)stk->gobuf.pc;
 100d641:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
 100d646:	49 8b 58 18          	mov    0x18(%r8),%rbx
			fp = nil;
 100d64a:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
 100d651:	00 00 
			lr = 0;
 100d653:	4d 31 c9             	xor    %r9,%r9
 100d656:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)
	}

	n = 0;
	sawnewstack = 0;
	stk = (Stktop*)g->stackbase;
	for(iter = 0; iter < 100 && n < max; iter++) {	// iter avoids looping forever
 100d65b:	e9 43 fe ff ff       	jmpq   100d4a3 <runtime.gentraceback+0x221>
			fp += 2*sizeof(uintptr);

		if(f->entry == (uintptr)runtime·newstack)
			sawnewstack = 1;

		if(pcbuf == nil && f->entry == (uintptr)runtime·morestack && g == m->g0 && sawnewstack) {
 100d660:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d667:	ff ff 
 100d669:	48 8b 00             	mov    (%rax),%rax
 100d66c:	48 39 c7             	cmp    %rax,%rdi
 100d66f:	0f 85 39 ff ff ff    	jne    100d5ae <runtime.gentraceback+0x32c>
 100d675:	83 7c 24 60 00       	cmpl   $0x0,0x60(%rsp)
 100d67a:	0f 84 2e ff ff ff    	je     100d5ae <runtime.gentraceback+0x32c>
			// The fact that we saw newstack means that morestack
			// has managed to record its information in m, so we can
			// use it to keep unwinding the stack.
			runtime·printf("----- morestack called from goroutine %d -----\n", m->curg->goid);
 100d680:	b8 0c 32 02 01       	mov    $0x102320c,%eax
 100d685:	48 89 04 24          	mov    %rax,(%rsp)
 100d689:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d690:	ff ff 
 100d692:	48 8b 40 70          	mov    0x70(%rax),%rax
 100d696:	8b 40 74             	mov    0x74(%rax),%eax
 100d699:	89 44 24 08          	mov    %eax,0x8(%rsp)
 100d69d:	e8 9c 9c ff ff       	callq  100733e <runtime.printf>
			pc = (uintptr)m->morepc;
 100d6a2:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d6a9:	ff ff 
 100d6ab:	48 8b 58 08          	mov    0x8(%rax),%rbx
			sp = m->morebuf.sp - sizeof(void*);
 100d6af:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d6b6:	ff ff 
 100d6b8:	48 8b 50 18          	mov    0x18(%rax),%rdx
 100d6bc:	48 83 c2 f8          	add    $0xfffffffffffffff8,%rdx
 100d6c0:	48 89 94 24 88 00 00 	mov    %rdx,0x88(%rsp)
 100d6c7:	00 
			lr = (uintptr)m->morebuf.pc;
 100d6c8:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d6cf:	ff ff 
 100d6d1:	4c 8b 48 20          	mov    0x20(%rax),%r9
 100d6d5:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)
			fp = m->morebuf.sp;
 100d6da:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d6e1:	ff ff 
 100d6e3:	48 8b 40 18          	mov    0x18(%rax),%rax
 100d6e7:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
			sawnewstack = 0;
 100d6ec:	c7 44 24 60 00 00 00 	movl   $0x0,0x60(%rsp)
 100d6f3:	00 
			g = m->curg;
 100d6f4:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
 100d6fb:	ff ff 
 100d6fd:	48 8b 78 70          	mov    0x70(%rax),%rdi
			stk = (Stktop*)g->stackbase;
 100d701:	48 89 bc 24 98 00 00 	mov    %rdi,0x98(%rsp)
 100d708:	00 
 100d709:	4c 8b 47 08          	mov    0x8(%rdi),%r8
 100d70d:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
	}

	n = 0;
	sawnewstack = 0;
	stk = (Stktop*)g->stackbase;
	for(iter = 0; iter < 100 && n < max; iter++) {	// iter avoids looping forever
 100d712:	e9 8c fd ff ff       	jmpq   100d4a3 <runtime.gentraceback+0x221>
		}
		
		waspanic = f->entry == (uintptr)runtime·sigpanic;

		if(f->entry == (uintptr)runtime·deferproc || f->entry == (uintptr)runtime·newproc)
			fp += 2*sizeof(uintptr);
 100d717:	48 83 c6 10          	add    $0x10,%rsi

		if(f->entry == (uintptr)runtime·newstack)
 100d71b:	e9 5f fe ff ff       	jmpq   100d57f <runtime.gentraceback+0x2fd>
			}
			runtime·prints(")\n");
			n++;
		}
		
		waspanic = f->entry == (uintptr)runtime·sigpanic;
 100d720:	31 c0                	xor    %eax,%eax
 100d722:	e9 34 fe ff ff       	jmpq   100d55b <runtime.gentraceback+0x2d9>
		} else if(lr == 0)
			lr = *(uintptr*)fp;

		if(skip > 0)
			skip--;
		else if(pcbuf != nil)
 100d727:	48 83 bc 24 a8 00 00 	cmpq   $0x0,0xa8(%rsp)
 100d72e:	00 00 
 100d730:	74 1f                	je     100d751 <runtime.gentraceback+0x4cf>
			pcbuf[n++] = pc;
 100d732:	8b 44 24 68          	mov    0x68(%rsp),%eax
 100d736:	ff 44 24 68          	incl   0x68(%rsp)
 100d73a:	48 63 c0             	movslq %eax,%rax
 100d73d:	48 8b 94 24 a8 00 00 	mov    0xa8(%rsp),%rdx
 100d744:	00 
 100d745:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
 100d749:	48 89 18             	mov    %rbx,(%rax)
			}
			runtime·prints(")\n");
			n++;
		}
		
		waspanic = f->entry == (uintptr)runtime·sigpanic;
 100d74c:	e9 f5 fd ff ff       	jmpq   100d546 <runtime.gentraceback+0x2c4>
			pcbuf[n++] = pc;
		else {
			// Print during crash.
			//	main+0xf /home/rsc/go/src/runtime/x.go:23
			//		main(0x1, 0x2, 0x3)
			runtime·printf("%S", f->name);
 100d751:	b8 ec 31 02 01       	mov    $0x10231ec,%eax
 100d756:	48 89 04 24          	mov    %rax,(%rsp)
 100d75a:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
 100d75f:	48 8b 45 00          	mov    0x0(%rbp),%rax
 100d763:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100d768:	48 8b 45 08          	mov    0x8(%rbp),%rax
 100d76c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100d771:	e8 c8 9b ff ff       	callq  100733e <runtime.printf>
 100d776:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 100d77b:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
			if(pc > f->entry)
 100d780:	48 8b 43 40          	mov    0x40(%rbx),%rax
 100d784:	48 39 c5             	cmp    %rax,%rbp
 100d787:	76 27                	jbe    100d7b0 <runtime.gentraceback+0x52e>
				runtime·printf("+%p", (uintptr)(pc - f->entry));
 100d789:	b8 ef 31 02 01       	mov    $0x10231ef,%eax
 100d78e:	48 89 04 24          	mov    %rax,(%rsp)
 100d792:	48 8b 43 40          	mov    0x40(%rbx),%rax
 100d796:	48 89 e9             	mov    %rbp,%rcx
 100d799:	48 29 c1             	sub    %rax,%rcx
 100d79c:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100d7a1:	e8 98 9b ff ff       	callq  100733e <runtime.printf>
 100d7a6:	48 8b 6c 24 58       	mov    0x58(%rsp),%rbp
 100d7ab:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
			tracepc = pc;	// back up to CALL instruction for funcline.
 100d7b0:	48 89 ea             	mov    %rbp,%rdx
			if(n > 0 && pc > f->entry && !waspanic)
 100d7b3:	83 7c 24 68 00       	cmpl   $0x0,0x68(%rsp)
 100d7b8:	7e 0d                	jle    100d7c7 <runtime.gentraceback+0x545>
 100d7ba:	48 8b 43 40          	mov    0x40(%rbx),%rax
 100d7be:	48 39 c5             	cmp    %rax,%rbp
 100d7c1:	0f 87 f2 00 00 00    	ja     100d8b9 <runtime.gentraceback+0x637>
				tracepc--;
			runtime·printf(" %S:%d\n", f->src, runtime·funcline(f, tracepc));
 100d7c7:	48 89 1c 24          	mov    %rbx,(%rsp)
 100d7cb:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
 100d7d0:	e8 31 ec ff ff       	callq  100c406 <runtime.funcline>
 100d7d5:	89 44 24 24          	mov    %eax,0x24(%rsp)
 100d7d9:	b8 f3 31 02 01       	mov    $0x10231f3,%eax
 100d7de:	48 89 04 24          	mov    %rax,(%rsp)
 100d7e2:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 100d7e7:	48 8b 41 20          	mov    0x20(%rcx),%rax
 100d7eb:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100d7f0:	48 8b 41 28          	mov    0x28(%rcx),%rax
 100d7f4:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100d7f9:	8b 44 24 24          	mov    0x24(%rsp),%eax
 100d7fd:	89 44 24 18          	mov    %eax,0x18(%rsp)
 100d801:	e8 38 9b ff ff       	callq  100733e <runtime.printf>
			runtime·printf("\t%S(", f->name);
 100d806:	b8 fb 31 02 01       	mov    $0x10231fb,%eax
 100d80b:	48 89 04 24          	mov    %rax,(%rsp)
 100d80f:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
 100d814:	48 8b 01             	mov    (%rcx),%rax
 100d817:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100d81c:	48 8b 41 08          	mov    0x8(%rcx),%rax
 100d820:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
 100d825:	e8 14 9b ff ff       	callq  100733e <runtime.printf>
			for(i = 0; i < f->args; i++) {
 100d82a:	31 d2                	xor    %edx,%edx
 100d82c:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
 100d831:	8b 40 58             	mov    0x58(%rax),%eax
 100d834:	39 c2                	cmp    %eax,%edx
 100d836:	7d 47                	jge    100d87f <runtime.gentraceback+0x5fd>
				if(i != 0)
 100d838:	83 fa 00             	cmp    $0x0,%edx
 100d83b:	89 54 24 6c          	mov    %edx,0x6c(%rsp)
 100d83f:	74 12                	je     100d853 <runtime.gentraceback+0x5d1>
					runtime·prints(", ");
 100d841:	b8 00 32 02 01       	mov    $0x1023200,%eax
 100d846:	48 89 04 24          	mov    %rax,(%rsp)
 100d84a:	e8 a2 9a ff ff       	callq  10072f1 <runtime.prints>
 100d84f:	8b 54 24 6c          	mov    0x6c(%rsp),%edx
				runtime·printhex(((uintptr*)fp)[i]);
 100d853:	48 63 ca             	movslq %edx,%rcx
 100d856:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
 100d85b:	48 8b 04 ca          	mov    (%rdx,%rcx,8),%rax
 100d85f:	48 89 04 24          	mov    %rax,(%rsp)
 100d863:	e8 76 a3 ff ff       	callq  1007bde <runtime.printhex>
 100d868:	8b 54 24 6c          	mov    0x6c(%rsp),%edx
				if(i >= 4) {
 100d86c:	83 fa 04             	cmp    $0x4,%edx
 100d86f:	7c 41                	jl     100d8b2 <runtime.gentraceback+0x630>
					runtime·prints(", ...");
 100d871:	b8 03 32 02 01       	mov    $0x1023203,%eax
 100d876:	48 89 04 24          	mov    %rax,(%rsp)
 100d87a:	e8 72 9a ff ff       	callq  10072f1 <runtime.prints>
					break;
				}
			}
			runtime·prints(")\n");
 100d87f:	b8 09 32 02 01       	mov    $0x1023209,%eax
 100d884:	48 89 04 24          	mov    %rax,(%rsp)
 100d888:	e8 64 9a ff ff       	callq  10072f1 <runtime.prints>
 100d88d:	4c 8b 4c 24 50       	mov    0x50(%rsp),%r9
 100d892:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
 100d897:	48 8b bc 24 98 00 00 	mov    0x98(%rsp),%rdi
 100d89e:	00 
 100d89f:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
 100d8a4:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
			n++;
 100d8a9:	ff 44 24 68          	incl   0x68(%rsp)
		}
		
		waspanic = f->entry == (uintptr)runtime·sigpanic;
 100d8ad:	e9 94 fc ff ff       	jmpq   100d546 <runtime.gentraceback+0x2c4>
			tracepc = pc;	// back up to CALL instruction for funcline.
			if(n > 0 && pc > f->entry && !waspanic)
				tracepc--;
			runtime·printf(" %S:%d\n", f->src, runtime·funcline(f, tracepc));
			runtime·printf("\t%S(", f->name);
			for(i = 0; i < f->args; i++) {
 100d8b2:	ff c2                	inc    %edx
 100d8b4:	e9 73 ff ff ff       	jmpq   100d82c <runtime.gentraceback+0x5aa>
			//		main(0x1, 0x2, 0x3)
			runtime·printf("%S", f->name);
			if(pc > f->entry)
				runtime·printf("+%p", (uintptr)(pc - f->entry));
			tracepc = pc;	// back up to CALL instruction for funcline.
			if(n > 0 && pc > f->entry && !waspanic)
 100d8b9:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%rsp)
 100d8be:	0f 85 03 ff ff ff    	jne    100d7c7 <runtime.gentraceback+0x545>
				tracepc--;
 100d8c4:	48 ff ca             	dec    %rdx
			runtime·printf(" %S:%d\n", f->src, runtime·funcline(f, tracepc));
 100d8c7:	e9 fb fe ff ff       	jmpq   100d7c7 <runtime.gentraceback+0x545>

		// Found an actual function.
		if(fp == nil) {
			fp = sp;
			if(pc > f->entry && f->frame >= sizeof(uintptr))
				fp += f->frame - sizeof(uintptr);
 100d8cc:	8b 45 54             	mov    0x54(%rbp),%eax
 100d8cf:	83 c0 f8             	add    $0xfffffffffffffff8,%eax
 100d8d2:	48 63 c0             	movslq %eax,%rax
 100d8d5:	48 01 c6             	add    %rax,%rsi
			if(lr == 0)
 100d8d8:	e9 3d fc ff ff       	jmpq   100d51a <runtime.gentraceback+0x298>
				lr = *(uintptr*)fp;
			fp += sizeof(uintptr);
		} else if(lr == 0)
 100d8dd:	49 83 f9 00          	cmp    $0x0,%r9
 100d8e1:	0f 85 4a fc ff ff    	jne    100d531 <runtime.gentraceback+0x2af>
			lr = *(uintptr*)fp;
 100d8e7:	4c 8b 0e             	mov    (%rsi),%r9
 100d8ea:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)

		if(skip > 0)
 100d8ef:	e9 3d fc ff ff       	jmpq   100d531 <runtime.gentraceback+0x2af>
		if(pc <= 0x1000 || (f = runtime·findfunc(pc)) == nil) {
			// Dangerous, but worthwhile: see if this is a closure:
			//	ADDQ $wwxxyyzz, SP; RET
			//	[48] 81 c4 zz yy xx ww c3
			// The 0x48 byte is only on amd64.
			p = (byte*)pc;
 100d8f4:	48 89 d9             	mov    %rbx,%rcx
			// We check p < p+8 to avoid wrapping and faulting if we lose track.
			if(runtime·mheap.arena_start < p && p < p+8 && p+8 < runtime·mheap.arena_used &&  // pointer in allocated memory
 100d8f7:	48 8b 04 25 e8 e8 03 	mov    0x303e8e8,%rax
 100d8fe:	03 
 100d8ff:	48 39 d8             	cmp    %rbx,%rax
 100d902:	73 0c                	jae    100d910 <runtime.gentraceback+0x68e>
 100d904:	48 89 d8             	mov    %rbx,%rax
 100d907:	48 83 c0 08          	add    $0x8,%rax
 100d90b:	48 39 c3             	cmp    %rax,%rbx
 100d90e:	72 47                	jb     100d957 <runtime.gentraceback+0x6d5>
				fp = nil;
				continue;
			}
			
			// Closure at top of stack, not yet started.
			if(lr == (uintptr)runtime·goexit && (pc = isclosureentry(pc)) != 0) {
 100d910:	49 81 f9 4c 7f 00 01 	cmp    $0x1007f4c,%r9
 100d917:	0f 85 24 fa ff ff    	jne    100d341 <runtime.gentraceback+0xbf>
 100d91d:	48 89 1c 24          	mov    %rbx,(%rsp)
 100d921:	e8 98 01 00 00       	callq  100dabe <isclosureentry>
 100d926:	4c 8b 4c 24 50       	mov    0x50(%rsp),%r9
 100d92b:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
 100d930:	48 8b 94 24 88 00 00 	mov    0x88(%rsp),%rdx
 100d937:	00 
 100d938:	48 8b bc 24 98 00 00 	mov    0x98(%rsp),%rdi
 100d93f:	00 
 100d940:	48 89 c3             	mov    %rax,%rbx
 100d943:	48 83 f8 00          	cmp    $0x0,%rax
 100d947:	0f 84 f4 f9 ff ff    	je     100d341 <runtime.gentraceback+0xbf>
				fp = sp;
 100d94d:	48 89 54 24 40       	mov    %rdx,0x40(%rsp)
	}

	n = 0;
	sawnewstack = 0;
	stk = (Stktop*)g->stackbase;
	for(iter = 0; iter < 100 && n < max; iter++) {	// iter avoids looping forever
 100d952:	e9 4c fb ff ff       	jmpq   100d4a3 <runtime.gentraceback+0x221>
			//	ADDQ $wwxxyyzz, SP; RET
			//	[48] 81 c4 zz yy xx ww c3
			// The 0x48 byte is only on amd64.
			p = (byte*)pc;
			// We check p < p+8 to avoid wrapping and faulting if we lose track.
			if(runtime·mheap.arena_start < p && p < p+8 && p+8 < runtime·mheap.arena_used &&  // pointer in allocated memory
 100d957:	48 89 d8             	mov    %rbx,%rax
 100d95a:	48 83 c0 08          	add    $0x8,%rax
 100d95e:	48 3b 04 25 f0 e8 03 	cmp    0x303e8f0,%rax
 100d965:	03 
 100d966:	73 a8                	jae    100d910 <runtime.gentraceback+0x68e>
 100d968:	48 ff c1             	inc    %rcx
 100d96b:	0f b6 03             	movzbl (%rbx),%eax
 100d96e:	83 f8 48             	cmp    $0x48,%eax
 100d971:	75 9d                	jne    100d910 <runtime.gentraceback+0x68e>
 100d973:	0f b6 01             	movzbl (%rcx),%eax
 100d976:	3d 81 00 00 00       	cmp    $0x81,%eax
 100d97b:	75 93                	jne    100d910 <runtime.gentraceback+0x68e>
 100d97d:	0f b6 41 01          	movzbl 0x1(%rcx),%eax
 100d981:	3d c4 00 00 00       	cmp    $0xc4,%eax
 100d986:	75 88                	jne    100d910 <runtime.gentraceback+0x68e>
 100d988:	0f b6 41 06          	movzbl 0x6(%rcx),%eax
 100d98c:	3d c3 00 00 00       	cmp    $0xc3,%eax
 100d991:	0f 85 79 ff ff ff    	jne    100d910 <runtime.gentraceback+0x68e>
			   (sizeof(uintptr) != 8 || *p++ == 0x48) &&  // skip 0x48 byte on amd64
			   p[0] == 0x81 && p[1] == 0xc4 && p[6] == 0xc3) {
				sp += *(uint32*)(p+2);
 100d997:	8b 41 02             	mov    0x2(%rcx),%eax
 100d99a:	48 01 c2             	add    %rax,%rdx
				pc = *(uintptr*)sp;
 100d99d:	48 8b 1a             	mov    (%rdx),%rbx
				sp += sizeof(uintptr);
 100d9a0:	48 83 c2 08          	add    $0x8,%rdx
 100d9a4:	48 89 94 24 88 00 00 	mov    %rdx,0x88(%rsp)
 100d9ab:	00 
				lr = 0;
 100d9ac:	4d 31 c9             	xor    %r9,%r9
 100d9af:	4c 89 4c 24 50       	mov    %r9,0x50(%rsp)
				fp = nil;
 100d9b4:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
 100d9bb:	00 00 
	}

	n = 0;
	sawnewstack = 0;
	stk = (Stktop*)g->stackbase;
	for(iter = 0; iter < 100 && n < max; iter++) {	// iter avoids looping forever
 100d9bd:	e9 e1 fa ff ff       	jmpq   100d4a3 <runtime.gentraceback+0x221>
	lr = 0;
	fp = nil;
	waspanic = false;
	
	// If the PC is goexit, the goroutine hasn't started yet.
	if(pc0 == g->sched.pc && sp == g->sched.sp && pc0 == (byte*)runtime·goexit) {
 100d9c2:	48 81 fb 4c 7f 00 01 	cmp    $0x1007f4c,%rbx
 100d9c9:	0f 85 13 f9 ff ff    	jne    100d2e2 <runtime.gentraceback+0x60>
		fp = sp;
 100d9cf:	48 89 54 24 40       	mov    %rdx,0x40(%rsp)
		lr = pc;
 100d9d4:	49 89 d9             	mov    %rbx,%r9
 100d9d7:	48 89 5c 24 50       	mov    %rbx,0x50(%rsp)
		pc = (uintptr)g->entry;
 100d9dc:	48 8b 5f 58          	mov    0x58(%rdi),%rbx
	}
	
	// If the PC is zero, it's likely a nil function call.
	// Start in the caller's frame.
	if(pc == 0) {
 100d9e0:	e9 fd f8 ff ff       	jmpq   100d2e2 <runtime.gentraceback+0x60>

000000000100d9e5 <runtime.traceback>:
		
	return n;
}

void
runtime·traceback(byte *pc0, byte *sp, byte*, G *g)
 100d9e5:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100d9ec:	ff ff 
 100d9ee:	48 3b 21             	cmp    (%rcx),%rsp
 100d9f1:	77 05                	ja     100d9f8 <runtime.traceback+0x13>
 100d9f3:	e8 6f 3f ff ff       	callq  1001967 <runtime.morestack32>
 100d9f8:	48 83 ec 40          	sub    $0x40,%rsp
{
	runtime·gentraceback(pc0, sp, nil, g, 0, nil, 100);
 100d9fc:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
 100da01:	48 89 04 24          	mov    %rax,(%rsp)
 100da05:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
 100da0a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 100da0f:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 100da16:	00 00 
 100da18:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
 100da1d:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 100da22:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%rsp)
 100da29:	00 
 100da2a:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
 100da31:	00 00 
 100da33:	b8 64 00 00 00       	mov    $0x64,%eax
 100da38:	89 44 24 30          	mov    %eax,0x30(%rsp)
 100da3c:	e8 41 f8 ff ff       	callq  100d282 <runtime.gentraceback>
 100da41:	48 83 c4 40          	add    $0x40,%rsp
 100da45:	c3                   	retq   

000000000100da46 <runtime.callers>:
}

int32
runtime·callers(int32 skip, uintptr *pcbuf, int32 m)
 100da46:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100da4d:	ff ff 
 100da4f:	48 3b 21             	cmp    (%rcx),%rsp
 100da52:	77 05                	ja     100da59 <runtime.callers+0x13>
 100da54:	e8 05 3f ff ff       	callq  100195e <runtime.morestack24>
 100da59:	48 83 ec 58          	sub    $0x58,%rsp
{
	byte *pc, *sp;

	// our caller's pc, sp.
	sp = (byte*)&skip;
 100da5d:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
 100da62:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
	pc = runtime·getcallerpc(&skip);
 100da67:	48 8d 4c 24 60       	lea    0x60(%rsp),%rcx
 100da6c:	48 89 0c 24          	mov    %rcx,(%rsp)
 100da70:	e8 54 40 ff ff       	callq  1001ac9 <runtime.getcallerpc>

	return runtime·gentraceback(pc, sp, nil, g, skip, pcbuf, m);
 100da75:	48 89 04 24          	mov    %rax,(%rsp)
 100da79:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
 100da7e:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
 100da83:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
 100da8a:	00 00 
 100da8c:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100da93:	ff ff 
 100da95:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
 100da9a:	8b 4c 24 60          	mov    0x60(%rsp),%ecx
 100da9e:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
 100daa2:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
 100daa7:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
 100daac:	8b 4c 24 70          	mov    0x70(%rsp),%ecx
 100dab0:	89 4c 24 30          	mov    %ecx,0x30(%rsp)
 100dab4:	e8 c9 f7 ff ff       	callq  100d282 <runtime.gentraceback>
 100dab9:	48 83 c4 58          	add    $0x58,%rsp
 100dabd:	c3                   	retq   

000000000100dabe <isclosureentry>:
}

static uintptr
isclosureentry(uintptr pc)
 100dabe:	64 48 8b 0c 25 f0 ff 	mov    %fs:0xfffffffffffffff0,%rcx
 100dac5:	ff ff 
 100dac7:	48 3b 21             	cmp    (%rcx),%rsp
 100daca:	77 05                	ja     100dad1 <isclosureentry+0x13>
 100dacc:	e8 7b 3e ff ff       	callq  100194c <runtime.morestack8>
 100dad1:	48 83 ec 18          	sub    $0x18,%rsp
 100dad5:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
{
	byte *p;
	int32 i, siz;
	
	p = (byte*)pc;
	if(p < runtime·mheap.arena_start || p+32 > runtime·mheap.arena_used)
 100dada:	48 3b 0c 25 e8 e8 03 	cmp    0x303e8e8,%rcx
 100dae1:	03 
 100dae2:	0f 82 34 02 00 00    	jb     100dd1c <isclosureentry+0x25e>
 100dae8:	48 89 c8             	mov    %rcx,%rax
 100daeb:	48 83 c0 20          	add    $0x20,%rax
 100daef:	48 3b 04 25 f0 e8 03 	cmp    0x303e8f0,%rax
 100daf6:	03 
 100daf7:	0f 87 1f 02 00 00    	ja     100dd1c <isclosureentry+0x25e>
		return 0;

	if(*p == 0xe8) {
 100dafd:	0f b6 01             	movzbl (%rcx),%eax
 100db00:	3d e8 00 00 00       	cmp    $0xe8,%eax
 100db05:	75 12                	jne    100db19 <isclosureentry+0x5b>
		// CALL fn
		return pc+5+*(int32*)(p+1);
 100db07:	8b 41 01             	mov    0x1(%rcx),%eax
 100db0a:	48 63 c0             	movslq %eax,%rax
 100db0d:	48 01 c8             	add    %rcx,%rax
 100db10:	48 83 c0 05          	add    $0x5,%rax
 100db14:	48 83 c4 18          	add    $0x18,%rsp
 100db18:	c3                   	retq   
	}
	
	if(sizeof(uintptr) == 8 && p[0] == 0x48 && p[1] == 0xb9 && p[10] == 0xff && p[11] == 0xd1) {
 100db19:	0f b6 01             	movzbl (%rcx),%eax
 100db1c:	83 f8 48             	cmp    $0x48,%eax
 100db1f:	0f 84 c1 01 00 00    	je     100dce6 <isclosureentry+0x228>
		// MOVQ $fn, CX; CALL *CX
		return *(uintptr*)(p+2);
	}

	// SUBQ $siz, SP
	if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0x81 || *p++ != 0xec)
 100db25:	48 89 c8             	mov    %rcx,%rax
 100db28:	48 ff c1             	inc    %rcx
 100db2b:	0f b6 00             	movzbl (%rax),%eax
 100db2e:	83 f8 48             	cmp    $0x48,%eax
 100db31:	74 08                	je     100db3b <isclosureentry+0x7d>
		return 0;
 100db33:	48 31 c0             	xor    %rax,%rax
 100db36:	48 83 c4 18          	add    $0x18,%rsp
 100db3a:	c3                   	retq   
		// MOVQ $fn, CX; CALL *CX
		return *(uintptr*)(p+2);
	}

	// SUBQ $siz, SP
	if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0x81 || *p++ != 0xec)
 100db3b:	48 89 c8             	mov    %rcx,%rax
 100db3e:	48 ff c1             	inc    %rcx
 100db41:	0f b6 00             	movzbl (%rax),%eax
 100db44:	3d 81 00 00 00       	cmp    $0x81,%eax
 100db49:	75 e8                	jne    100db33 <isclosureentry+0x75>
 100db4b:	48 89 c8             	mov    %rcx,%rax
 100db4e:	48 ff c1             	inc    %rcx
 100db51:	0f b6 00             	movzbl (%rax),%eax
 100db54:	3d ec 00 00 00       	cmp    $0xec,%eax
 100db59:	75 d8                	jne    100db33 <isclosureentry+0x75>
		return 0;
	siz = *(uint32*)p;
 100db5b:	8b 19                	mov    (%rcx),%ebx
	p += 4;
 100db5d:	48 83 c1 04          	add    $0x4,%rcx
	
	// MOVQ $q, SI
	if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xbe)
 100db61:	48 89 c8             	mov    %rcx,%rax
 100db64:	48 ff c1             	inc    %rcx
 100db67:	0f b6 00             	movzbl (%rax),%eax
 100db6a:	83 f8 48             	cmp    $0x48,%eax
 100db6d:	74 08                	je     100db77 <isclosureentry+0xb9>
		return 0;
 100db6f:	48 31 c0             	xor    %rax,%rax
 100db72:	48 83 c4 18          	add    $0x18,%rsp
 100db76:	c3                   	retq   
		return 0;
	siz = *(uint32*)p;
	p += 4;
	
	// MOVQ $q, SI
	if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xbe)
 100db77:	48 89 c8             	mov    %rcx,%rax
 100db7a:	48 ff c1             	inc    %rcx
 100db7d:	0f b6 00             	movzbl (%rax),%eax
 100db80:	3d be 00 00 00       	cmp    $0xbe,%eax
 100db85:	75 e8                	jne    100db6f <isclosureentry+0xb1>
		return 0;
	p += sizeof(uintptr);
 100db87:	48 83 c1 08          	add    $0x8,%rcx

	// MOVQ SP, DI
	if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0x89 || *p++ != 0xe7)
 100db8b:	48 89 c8             	mov    %rcx,%rax
 100db8e:	48 ff c1             	inc    %rcx
 100db91:	0f b6 00             	movzbl (%rax),%eax
 100db94:	83 f8 48             	cmp    $0x48,%eax
 100db97:	74 08                	je     100dba1 <isclosureentry+0xe3>
		return 0;
 100db99:	48 31 c0             	xor    %rax,%rax
 100db9c:	48 83 c4 18          	add    $0x18,%rsp
 100dba0:	c3                   	retq   
	if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xbe)
		return 0;
	p += sizeof(uintptr);

	// MOVQ SP, DI
	if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0x89 || *p++ != 0xe7)
 100dba1:	48 89 c8             	mov    %rcx,%rax
 100dba4:	48 ff c1             	inc    %rcx
 100dba7:	0f b6 00             	movzbl (%rax),%eax
 100dbaa:	3d 89 00 00 00       	cmp    $0x89,%eax
 100dbaf:	75 e8                	jne    100db99 <isclosureentry+0xdb>
 100dbb1:	48 89 c8             	mov    %rcx,%rax
 100dbb4:	48 ff c1             	inc    %rcx
 100dbb7:	0f b6 00             	movzbl (%rax),%eax
 100dbba:	3d e7 00 00 00       	cmp    $0xe7,%eax
 100dbbf:	75 d8                	jne    100db99 <isclosureentry+0xdb>

	// CLD on 32-bit
	if(sizeof(uintptr) == 4 && *p++ != 0xfc)
		return 0;

	if(siz <= 4*sizeof(uintptr)) {
 100dbc1:	83 fb 20             	cmp    $0x20,%ebx
 100dbc4:	0f 8f a8 00 00 00    	jg     100dc72 <isclosureentry+0x1b4>
		// MOVSQ...
		for(i=0; i<siz; i+=sizeof(uintptr))
 100dbca:	31 d2                	xor    %edx,%edx
 100dbcc:	39 da                	cmp    %ebx,%edx
 100dbce:	7d 2d                	jge    100dbfd <isclosureentry+0x13f>
			if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xa5)
 100dbd0:	48 89 c8             	mov    %rcx,%rax
 100dbd3:	48 ff c1             	inc    %rcx
 100dbd6:	0f b6 00             	movzbl (%rax),%eax
 100dbd9:	83 f8 48             	cmp    $0x48,%eax
 100dbdc:	74 08                	je     100dbe6 <isclosureentry+0x128>
				return 0;
 100dbde:	48 31 c0             	xor    %rax,%rax
 100dbe1:	48 83 c4 18          	add    $0x18,%rsp
 100dbe5:	c3                   	retq   
		return 0;

	if(siz <= 4*sizeof(uintptr)) {
		// MOVSQ...
		for(i=0; i<siz; i+=sizeof(uintptr))
			if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xa5)
 100dbe6:	48 89 c8             	mov    %rcx,%rax
 100dbe9:	48 ff c1             	inc    %rcx
 100dbec:	0f b6 00             	movzbl (%rax),%eax
 100dbef:	3d a5 00 00 00       	cmp    $0xa5,%eax
 100dbf4:	75 e8                	jne    100dbde <isclosureentry+0x120>
	if(sizeof(uintptr) == 4 && *p++ != 0xfc)
		return 0;

	if(siz <= 4*sizeof(uintptr)) {
		// MOVSQ...
		for(i=0; i<siz; i+=sizeof(uintptr))
 100dbf6:	83 c2 08             	add    $0x8,%edx
 100dbf9:	39 da                	cmp    %ebx,%edx
 100dbfb:	7c d3                	jl     100dbd0 <isclosureentry+0x112>
		if(*p++ != 0xf3 || (sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xa5)
			return 0;
	}
	
	// CALL fn
	if(*p == 0xe8) {
 100dbfd:	0f b6 01             	movzbl (%rcx),%eax
 100dc00:	3d e8 00 00 00       	cmp    $0xe8,%eax
 100dc05:	75 14                	jne    100dc1b <isclosureentry+0x15d>
		p++;
 100dc07:	48 ff c1             	inc    %rcx
		return (uintptr)p+4 + *(int32*)p;
 100dc0a:	8b 01                	mov    (%rcx),%eax
 100dc0c:	48 63 c0             	movslq %eax,%rax
 100dc0f:	48 01 c8             	add    %rcx,%rax
 100dc12:	48 83 c0 04          	add    $0x4,%rax
 100dc16:	48 83 c4 18          	add    $0x18,%rsp
 100dc1a:	c3                   	retq   
	}
	
	// MOVQ $fn, CX; CALL *CX
	if(sizeof(uintptr) != 8 || *p++ != 0x48 || *p++ != 0xb9)
 100dc1b:	48 89 c8             	mov    %rcx,%rax
 100dc1e:	48 ff c1             	inc    %rcx
 100dc21:	0f b6 00             	movzbl (%rax),%eax
 100dc24:	83 f8 48             	cmp    $0x48,%eax
 100dc27:	74 08                	je     100dc31 <isclosureentry+0x173>
		return 0;
 100dc29:	48 31 c0             	xor    %rax,%rax
 100dc2c:	48 83 c4 18          	add    $0x18,%rsp
 100dc30:	c3                   	retq   
		p++;
		return (uintptr)p+4 + *(int32*)p;
	}
	
	// MOVQ $fn, CX; CALL *CX
	if(sizeof(uintptr) != 8 || *p++ != 0x48 || *p++ != 0xb9)
 100dc31:	48 89 c8             	mov    %rcx,%rax
 100dc34:	48 ff c1             	inc    %rcx
 100dc37:	0f b6 00             	movzbl (%rax),%eax
 100dc3a:	3d b9 00 00 00       	cmp    $0xb9,%eax
 100dc3f:	75 e8                	jne    100dc29 <isclosureentry+0x16b>
		return 0;

	pc = *(uintptr*)p;
 100dc41:	48 8b 11             	mov    (%rcx),%rdx
	p += 8;
 100dc44:	48 83 c1 08          	add    $0x8,%rcx
	
	if(*p++ != 0xff || *p != 0xd1)
 100dc48:	48 89 c8             	mov    %rcx,%rax
 100dc4b:	48 ff c1             	inc    %rcx
 100dc4e:	0f b6 00             	movzbl (%rax),%eax
 100dc51:	3d ff 00 00 00       	cmp    $0xff,%eax
 100dc56:	75 12                	jne    100dc6a <isclosureentry+0x1ac>
 100dc58:	0f b6 01             	movzbl (%rcx),%eax
 100dc5b:	3d d1 00 00 00       	cmp    $0xd1,%eax
 100dc60:	75 08                	jne    100dc6a <isclosureentry+0x1ac>
		return 0;

	return pc;
 100dc62:	48 89 d0             	mov    %rdx,%rax
 100dc65:	48 83 c4 18          	add    $0x18,%rsp
 100dc69:	c3                   	retq   

	pc = *(uintptr*)p;
	p += 8;
	
	if(*p++ != 0xff || *p != 0xd1)
		return 0;
 100dc6a:	48 31 c0             	xor    %rax,%rax
 100dc6d:	48 83 c4 18          	add    $0x18,%rsp
 100dc71:	c3                   	retq   
		for(i=0; i<siz; i+=sizeof(uintptr))
			if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xa5)
				return 0;
	} else {
		// MOVQ $(siz/8), CX  [32-bit immediate siz/8]
		if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xc7 || *p++ != 0xc1)
 100dc72:	48 89 c8             	mov    %rcx,%rax
 100dc75:	48 ff c1             	inc    %rcx
 100dc78:	0f b6 00             	movzbl (%rax),%eax
 100dc7b:	83 f8 48             	cmp    $0x48,%eax
 100dc7e:	74 08                	je     100dc88 <isclosureentry+0x1ca>
			return 0;
 100dc80:	48 31 c0             	xor    %rax,%rax
 100dc83:	48 83 c4 18          	add    $0x18,%rsp
 100dc87:	c3                   	retq   
		for(i=0; i<siz; i+=sizeof(uintptr))
			if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xa5)
				return 0;
	} else {
		// MOVQ $(siz/8), CX  [32-bit immediate siz/8]
		if((sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xc7 || *p++ != 0xc1)
 100dc88:	48 89 c8             	mov    %rcx,%rax
 100dc8b:	48 ff c1             	inc    %rcx
 100dc8e:	0f b6 00             	movzbl (%rax),%eax
 100dc91:	3d c7 00 00 00       	cmp    $0xc7,%eax
 100dc96:	75 e8                	jne    100dc80 <isclosureentry+0x1c2>
 100dc98:	48 89 c8             	mov    %rcx,%rax
 100dc9b:	48 ff c1             	inc    %rcx
 100dc9e:	0f b6 00             	movzbl (%rax),%eax
 100dca1:	3d c1 00 00 00       	cmp    $0xc1,%eax
 100dca6:	75 d8                	jne    100dc80 <isclosureentry+0x1c2>
			return 0;
		p += 4;
 100dca8:	48 83 c1 04          	add    $0x4,%rcx
		
		// REP MOVSQ
		if(*p++ != 0xf3 || (sizeof(uintptr) == 8 && *p++ != 0x48) || *p++ != 0xa5)
 100dcac:	48 89 c8             	mov    %rcx,%rax
 100dcaf:	48 ff c1             	inc    %rcx
 100dcb2:	0f b6 00             	movzbl (%rax),%eax
 100dcb5:	3d f3 00 00 00       	cmp    $0xf3,%eax
 100dcba:	75 22                	jne    100dcde <isclosureentry+0x220>
 100dcbc:	48 89 c8             	mov    %rcx,%rax
 100dcbf:	48 ff c1             	inc    %rcx
 100dcc2:	0f b6 00             	movzbl (%rax),%eax
 100dcc5:	83 f8 48             	cmp    $0x48,%eax
 100dcc8:	75 14                	jne    100dcde <isclosureentry+0x220>
 100dcca:	48 89 c8             	mov    %rcx,%rax
 100dccd:	48 ff c1             	inc    %rcx
 100dcd0:	0f b6 00             	movzbl (%rax),%eax
 100dcd3:	3d a5 00 00 00       	cmp    $0xa5,%eax
 100dcd8:	0f 84 1f ff ff ff    	je     100dbfd <isclosureentry+0x13f>
			return 0;
 100dcde:	48 31 c0             	xor    %rax,%rax
 100dce1:	48 83 c4 18          	add    $0x18,%rsp
 100dce5:	c3                   	retq   
	if(*p == 0xe8) {
		// CALL fn
		return pc+5+*(int32*)(p+1);
	}
	
	if(sizeof(uintptr) == 8 && p[0] == 0x48 && p[1] == 0xb9 && p[10] == 0xff && p[11] == 0xd1) {
 100dce6:	0f b6 41 01          	movzbl 0x1(%rcx),%eax
 100dcea:	3d b9 00 00 00       	cmp    $0xb9,%eax
 100dcef:	0f 85 30 fe ff ff    	jne    100db25 <isclosureentry+0x67>
 100dcf5:	0f b6 41 0a          	movzbl 0xa(%rcx),%eax
 100dcf9:	3d ff 00 00 00       	cmp    $0xff,%eax
 100dcfe:	0f 85 21 fe ff ff    	jne    100db25 <isclosureentry+0x67>
 100dd04:	0f b6 41 0b          	movzbl 0xb(%rcx),%eax
 100dd08:	3d d1 00 00 00       	cmp    $0xd1,%eax
 100dd0d:	0f 85 12 fe ff ff    	jne    100db25 <isclosureentry+0x67>
		// MOVQ $fn, CX; CALL *CX
		return *(uintptr*)(p+2);
 100dd13:	48 8b 41 02          	mov    0x2(%rcx),%rax
 100dd17:	48 83 c4 18          	add    $0x18,%rsp
 100dd1b:	c3                   	retq   
 100dd1c:	48 31 c0             	xor    %rax,%rax
 100dd1f:	48 83 c4 18          	add    $0x18,%rsp
 100dd23:	c3                   	retq   
